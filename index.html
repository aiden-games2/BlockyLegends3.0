<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Blocky Legends</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #111;
            color: #eee;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }
        
        canvas {
            background: #1a1a1a;
            display: block;
            border-radius: 8px;
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 80vh;
        }
        
        /* General Button Style */
        .game-btn {
            font-family: 'Press Start 2P', cursive;
            background-color: #fff;
            color: #000;
            border: none;
            border-bottom: 4px solid #999;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s ease;
            text-transform: uppercase;
            position: relative;
        }
        
        .game-btn:hover {
            background-color: #f0f0f0;
            transform: translateY(-2px);
        }
        
        .game-btn:active {
            transform: translateY(2px);
            border-bottom-width: 0;
            margin-top: 4px;
        }

        .game-btn:disabled {
            background-color: #555;
            border-color: #333;
            color: #888;
            cursor: not-allowed;
            transform: none;
            margin-top: 0;
            border-bottom-width: 4px;
        }

        /* Hero Cards */
        .char-select-card {
            border: 4px solid #555;
            border-radius: 8px;
            transition: all 0.2s ease;
            background-color: #2a2a2a;
            width: 160px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        .char-select-card:hover {
            transform: scale(1.05);
            border-color: #f7b42c;
            background-color: #333;
        }
        .char-block {
            width: 60px;
            height: 60px;
            margin-bottom: 1rem;
            border: 2px solid #000;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.3);
        }

        /* Shop Item Card */
        .shop-card {
            background-color: #2a2a2a;
            border: 2px solid #555;
            padding: 15px;
            border-radius: 8px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            text-align: center;
        }

        /* XP Bar Styles */
        .xp-container {
            width: 100%;
            height: 24px;
            background-color: #333;
            border: 2px solid #fff;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.2s ease-out;
        }

        /* Wave Text Animation */
        @keyframes wavePulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .wave-anim {
            animation: wavePulse 2s infinite;
        }

        /* Stats Grid */
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 2px solid #333;
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        

        /* Ability Sidebar */
#abilitySidebar::-webkit-scrollbar {
    width: 4px;
}
#abilitySidebar::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.3);
    border-radius: 2px;
}
#abilitySidebar::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.3);
    border-radius: 2px;
}
.ability-card {
    background: linear-gradient(135deg, rgba(30,30,30,0.95) 0%, rgba(20,20,20,0.95) 100%);
    border: 2px solid #444;
    border-radius: 8px;
    padding: 8px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
}
.ability-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    transition: left 0.5s;
}
.ability-card:hover::before {
    left: 100%;
}
.ability-card-offense {
    border-color: #dc2626;
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
}
.ability-card-defense {
    border-color: #2563eb;
    box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
}
.ability-card-utility {
    border-color: #9333ea;
    box-shadow: 0 4px 12px rgba(147, 51, 234, 0.4);
}
.ability-icon {
    font-size: 24px;
    display: block;
    margin-bottom: 4px;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8));
}
.ability-stack {
    position: absolute;
    top: 2px;
    right: 4px;
    background: rgba(0,0,0,0.8);
    color: #fbbf24;
    font-size: 10px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 10px;
    border: 1px solid #fbbf24;
}
</parameter>

.team-hero-card {
    background: #2a2a2a;
    border: 3px solid #555;
    padding: 15px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    color: white;
    text-align: center;
}

.team-hero-card:hover {
    transform: scale(1.05);
    border-color: #f7b42c;
    background: #333;
}

.team-hero-card.selected {
    border-color: #00ff00;
    background: #1a4d1a;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
}
        
    </style>
</head>
<body class="flex flex-col items-center justify-center h-full w-full p-2">

    <div class="w-full max-w-4xl text-center relative">
        
        <!-- Coin Display (Global) - MOVED LOWER & BIGGER -->
<div id="coinDisplayMenu" class="absolute top-24 right-4 text-yellow-400 flex items-center gap-3 bg-gray-900 p-3 rounded-lg border-2 border-yellow-600 z-50 shadow-lg">
    <div class="w-6 h-6 bg-yellow-400 rounded-full border-2 border-white"></div>
    <span id="menuCoins" class="text-xl font-bold">0</span>
</div>
<!-- Event Pass Button -->
<button id="btnEventPass" class="absolute top-1/2 right-8 transform -translate-y-1/2 bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 px-6 py-4 rounded-lg border-2 border-pink-300 text-white font-bold text-lg shadow-lg transition-transform hover:scale-105 z-50">
    üíùüéÜ EVENT
</button>
<!-- PAC Rank Display (Top Left) -->
<div id="pacDisplayMenu" class="absolute top-24 left-4 text-purple-400 flex items-center gap-3 bg-gray-900 p-3 rounded-lg border-2 border-purple-600 z-50 shadow-lg cursor-pointer hover:scale-105 transition-transform">
    <div class="w-6 h-6 bg-purple-400 rounded-full border-2 border-white animate-pulse"></div>
    <div>
        <div class="text-[10px] text-gray-400">RANK</div>
        <span id="pacRankText" class="text-lg font-bold uppercase">ROOKIE</span>
    </div>
</div>
<!-- Event Pass Display - MOVED RIGHT -->
<div id="eventPassDisplay" class="hidden absolute top-1/2 right-8 transform -translate-y-1/2 mt-20 bg-gradient-to-br from-pink-900 via-red-900 to-purple-900 p-3 rounded-lg border-2 border-pink-500 z-50 shadow-xl cursor-pointer hover:scale-105 transition-transform" style="right: 2rem;">
    <div class="flex items-center gap-2 mb-2">
        <span class="text-lg">üíùüéÜ</span>
        <div>
            <div class="text-[8px] text-gray-300">EVENT PASS</div>
            <div class="text-sm text-pink-300 font-bold">Hearts & Fireworks</div>
        </div>
    </div>
    <div class="flex items-center gap-2">
        <span id="eventPassIcon" class="text-xl">üåπ</span>
        <span id="eventPassCount" class="text-lg font-bold text-white">0</span>
        <span class="text-[10px] text-gray-400">/ 100</span>
    </div>
    <div class="w-full h-2 bg-gray-800 rounded-full mt-2 overflow-hidden">
        <div id="eventPassBar" class="h-full bg-gradient-to-r from-pink-500 to-red-500" style="width: 0%"></div>
    </div>
</div>
        
        <!-- Game Title -->
        <h1 id="gameTitle" class="text-2xl sm:text-5xl font-bold mb-8 text-yellow-400 drop-shadow-[4px_4px_0_rgba(0,0,0,1)] tracking-wider">
            BLOCKY LEGENDS
        </h1>

        <!-- MAIN MENU SCREEN -->
        <div id="mainMenuScreen" class="flex flex-col items-center gap-6">
           <!-- Main Action Buttons -->
<button id="btnPlay" class="game-btn px-8 py-4 text-xl sm:text-2xl w-64 bg-green-500 border-green-700 hover:bg-green-400 text-white">
    PLAY
</button>
<button id="btnShop" class="game-btn px-8 py-4 text-lg sm:text-xl w-64 bg-yellow-500 border-yellow-700 hover:bg-yellow-400 text-white">
    SHOP
</button>
<button id="btnStats" class="game-btn px-8 py-4 text-lg sm:text-xl w-64 bg-gray-200 border-gray-400">
    STATS
</button>

<!-- More Button -->
<div class="flex gap-3 mt-4 justify-center">
    <button id="btnMore" class="game-btn px-8 py-3 text-lg w-48 bg-gray-700 border-gray-900 text-white hover:bg-gray-600">
        üìã MORE
    </button>
</div>
</div>
<!-- Code Redemption Box (Left Side) - NOW INSIDE MAIN MENU -->
            <div id="codeRedemptionBox" class="absolute left-4 bottom-4 w-56 bg-gray-800 p-3 rounded-lg border-2 border-gray-600 z-40">
                <h3 class="text-xs text-yellow-400 mb-2">üéÅ REDEEM CODE</h3>
                <input 
                    type="text" 
                    id="codeInput" 
                    placeholder="Enter code..."
                    class="w-full px-3 py-2 bg-gray-900 text-white text-xs border border-gray-600 rounded mb-2 uppercase"
                    maxlength="20"
                >
                <button id="btnRedeem" class="game-btn px-4 py-2 text-xs w-full bg-green-500 border-green-700 text-white">
                    REDEEM
                </button>
                <div id="codeMessage" class="text-[10px] mt-2 text-center hidden"></div>
            </div>

       </div>

       <!-- Trader (Bottom Right Corner) -->
<div id="traderIcon" class="absolute bottom-20 right-8 w-20 h-20 cursor-pointer transition-transform hover:scale-125" title="Mysterious Trader">
    <div class="text-6xl">üßô‚Äç‚ôÇÔ∏è</div>
    <div class="text-[8px] text-center text-yellow-400 mt-1">TRADER</div>
</div>
 

<div class="text-[10px] text-gray-500 mt-6">v2.9 - Hearts & Fireworks</div>

        </div>
        
            

    
        
            

        

<!-- SHOP SCREEN -->
<div id="shopScreen" class="hidden w-full max-w-4xl mx-auto bg-gray-900 p-4 rounded-lg border-4 border-gray-700 max-h-[85vh] overflow-y-auto">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">SHOP</h2>
    
   <!-- Tab Navigation -->
<div class="flex gap-2 mb-6">
    <button id="tabUpgrades" class="game-btn px-6 py-3 text-sm bg-yellow-500 border-yellow-700 text-white">
        üõ†Ô∏è UPGRADES
    </button>
    <button id="tabSkins" class="game-btn px-6 py-3 text-sm bg-purple-500 border-purple-700 text-white">
        üé® SKINS
    </button>
    <button id="tabOutfits" class="game-btn px-6 py-3 text-sm bg-cyan-500 border-cyan-700 text-white">
        üëî OUTFITS
    </button>
</div>
    
    <!-- UPGRADES TAB CONTENT -->
    <div id="upgradesTab" class="tab-content">
        <div class="grid grid-cols-1 sm:grid-cols-4 gap-4 mb-6">
            <!-- Upgrade 1: Health -->
            <div class="shop-card">
                <div class="text-red-500 text-3xl">‚ô•</div>
                <h3 class="text-sm text-white mb-1">Iron Heart</h3>
                <p class="text-[10px] text-gray-400 mb-2">+15 Max HP</p>
                <p class="text-[10px] text-blue-300 mb-2">Level: <span id="lvlHealth">0</span></p>
                <button id="buyHealth" class="game-btn px-4 py-2 text-[10px] w-full bg-yellow-400 border-yellow-600">
                    <span id="costHealth">100</span> G
                </button>
            </div>

            <!-- Upgrade 2: Magnet -->
            <div class="shop-card">
                <div class="text-blue-400 text-3xl">üß≤</div>
                <h3 class="text-sm text-white mb-1">Loot Magnet</h3>
                <p class="text-[10px] text-gray-400 mb-2">+20% Range</p>
                <p class="text-[10px] text-blue-300 mb-2">Level: <span id="lvlMagnet">0</span></p>
                <button id="buyMagnet" class="game-btn px-4 py-2 text-[10px] w-full bg-yellow-400 border-yellow-600">
                    <span id="costMagnet">100</span> G
                </button>
            </div>

<!-- Valentine Healing Burst -->
<div class="shop-card" id="loveBurstCard" style="display: none;">
    <div class="text-pink-500 text-3xl">üíó</div>
    <h3 class="text-sm text-white mb-1">Love Burst</h3>
    <p class="text-[10px] text-gray-400 mb-2">Heal 15 HP</p>
    <p class="text-[10px] text-green-400 mb-2">Owned: <span id="invLoveBurst">0</span></p>
    <button id="buyLoveBurst" class="game-btn px-4 py-2 text-[10px] w-full bg-gray-300 border-gray-500">
        20 üåπ
    </button>
</div>
<!-- Lunar Burn Wave -->
<div class="shop-card" id="burnWaveCard" style="display: none;">
    <div class="text-orange-500 text-3xl">üî•</div>
    <h3 class="text-sm text-white mb-1">Burn Wave</h3>
    <p class="text-[10px] text-gray-400 mb-2">Fire AOE</p>
    <p class="text-[10px] text-green-400 mb-2">Owned: <span id="invBurnWave">0</span></p>
    <button id="buyBurnWave" class="game-btn px-4 py-2 text-[10px] w-full bg-gray-300 border-gray-500">
        20 üéÜ
    </button>
</div>

            <!-- Consumable: Turret -->
            <div class="shop-card border-gray-400">
                <div class="text-gray-300 text-3xl">üî´</div>
                <h3 class="text-sm text-white mb-1">Sentry</h3>
                <p class="text-[10px] text-gray-400 mb-2">Auto-Shooter</p>
                <p class="text-[10px] text-green-400 mb-2">Owned: <span id="invTurret">0</span></p>
                <button id="buyTurret" class="game-btn px-4 py-2 text-[10px] w-full bg-gray-300 border-gray-500">
                    <span id="txtTurretCost">40</span> G
                </button>
            </div>

            <!-- Consumable: Bomb -->
            <div class="shop-card border-gray-400">
                <div class="text-orange-500 text-3xl">üí£</div>
                <h3 class="text-sm text-white mb-1">Bomb</h3>
                <p class="text-[10px] text-gray-400 mb-2">AOE Explosion</p>
                <p class="text-[10px] text-green-400 mb-2">Owned: <span id="invBomb">0</span></p>
                <button id="buyBomb" class="game-btn px-4 py-2 text-[10px] w-full bg-gray-300 border-gray-500">
                    <span id="txtBombCost">80</span> G
                </button>
            </div>
        </div>
    </div>
    
    <!-- SKINS TAB CONTENT -->
    <div id="skinsTab" class="tab-content hidden">
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-6 mb-6">
            <!-- Golden Skin -->
            <div class="shop-card border-yellow-500 bg-gradient-to-br from-yellow-900 to-gray-900">
                <div class="text-yellow-300 text-5xl mb-3 animate-pulse">‚òÖ</div>
                <h3 class="text-lg text-yellow-300 mb-2 font-bold">Golden Hero</h3>
                <p class="text-[10px] text-gray-300 mb-3">Shine like a champion! Golden glow for all heroes.</p>
                <div class="flex flex-col gap-2 mb-3">
                    <div class="flex gap-1 justify-center">
                        <div class="w-8 h-8 bg-gradient-to-br from-yellow-300 to-yellow-600 border-2 border-white"></div>
                        <div class="w-8 h-8 bg-gradient-to-br from-yellow-300 to-yellow-600 border-2 border-white"></div>
                        <div class="w-8 h-8 bg-gradient-to-br from-yellow-300 to-yellow-600 border-2 border-white"></div>
                    </div>
                </div>
<p class="text-[10px] text-blue-300 mb-3" id="statusSkin">Locked</p>
<button id="buySkin" class="game-btn px-4 py-3 text-sm w-full bg-gradient-to-r from-yellow-500 to-yellow-600 border-yellow-700 text-white font-bold">
    üí∞ 500 G
</button>
<button id="unequipSkin" class="game-btn px-4 py-3 text-sm w-full bg-red-500 border-red-700 text-white font-bold hidden mt-2">
    UNEQUIP
</button>
            </div>
        
            
            <!-- Obsidian Knight Skin -->
<div class="shop-card border-purple-600 bg-gradient-to-br from-purple-900 to-gray-900">
    <div class="relative mb-3">
        <div class="text-purple-400 text-5xl mb-3 animate-pulse">üíé</div>
        <div class="absolute -top-2 -right-2 bg-purple-600 text-white text-[8px] px-2 py-1 rounded-full font-bold animate-bounce">LEGENDARY!</div>
    </div>
    <h3 class="text-lg text-purple-300 mb-2 font-bold">Obsidian Warrior</h3>
    <p class="text-[10px] text-gray-300 mb-3">Dark armor forged in obsidian runes</p>
    <div class="flex flex-col gap-2 mb-3">
        <div class="flex gap-1 justify-center">
            <div class="w-8 h-8 bg-gradient-to-br from-purple-900 via-black to-purple-600 border-2 border-purple-400 relative overflow-hidden">
                <div class="absolute inset-0 bg-gradient-to-br from-transparent via-purple-300 to-transparent opacity-30 animate-pulse"></div>
            </div>
            <div class="w-8 h-8 bg-gradient-to-br from-purple-900 via-black to-purple-600 border-2 border-purple-400 relative overflow-hidden">
                <div class="absolute inset-0 bg-gradient-to-br from-transparent via-purple-300 to-transparent opacity-30 animate-pulse"></div>
            </div>
            <div class="w-8 h-8 bg-gradient-to-br from-purple-900 via-black to-purple-600 border-2 border-purple-400 relative overflow-hidden">
                <div class="absolute inset-0 bg-gradient-to-br from-transparent via-purple-300 to-transparent opacity-30 animate-pulse"></div>
            </div>
        </div>
    </div>
    <p class="text-[10px] text-blue-300 mb-3" id="statusObsidianSkin">Locked</p>
    <button id="buyObsidianSkin" class="game-btn px-4 py-3 text-sm w-full bg-gradient-to-r from-purple-600 to-purple-800 border-purple-900 text-white font-bold">
        üíé 1500 G
    </button>
    <button id="unequipObsidianSkin" class="game-btn px-4 py-3 text-sm w-full bg-red-500 border-red-700 text-white font-bold hidden mt-2">
        UNEQUIP
    </button>
</div>
        </div>
   </div>

<!-- OUTFITS TAB CONTENT -->
<div id="outfitsTab" class="tab-content hidden">
    <div class="mb-4 text-xs text-gray-400">Mix and match your cosmetics! (One hat + one accessory max)</div>
    
    <div class="flex flex-col gap-4 mb-6">
       <!-- HATS AND ACCESSORIES SIDE BY SIDE -->
<div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
    <!-- HATS SECTION -->
    <div class="bg-gray-800 p-4 rounded-lg border-2 border-cyan-500 max-h-96 overflow-y-auto">
        <h3 class="text-sm text-cyan-300 mb-3 font-bold">üé© HATS (Choose One)</h3>
        
        <!-- Royal Crown -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üëë</div>
                    <div>
                        <h4 class="text-xs text-yellow-400">Royal Crown</h4>
                        <p class="text-[8px] text-gray-400" id="crownStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="toggleCrown" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buyCrown" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        1000G
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Santa Hat -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üéÖ</div>
                    <div>
                        <h4 class="text-xs text-red-400">Santa Hat</h4>
                        <p class="text-[8px] text-gray-400" id="santaHatStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleSantaHat" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
        
        <!-- Elf Hat -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üßù</div>
                    <div>
                        <h4 class="text-xs text-green-400">Elf Hat</h4>
                        <p class="text-[8px] text-gray-400" id="elfHatStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleElfHat" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
        
        <!-- Antlers -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">ü¶å</div>
                    <div>
                        <h4 class="text-xs text-orange-400">Antlers</h4>
                        <p class="text-[8px] text-gray-400" id="antlersStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleAntlers" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
        
        <!-- Halo -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üòá</div>
                    <div>
                        <h4 class="text-xs text-yellow-300">Halo</h4>
                        <p class="text-[8px] text-gray-400" id="haloStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="toggleHalo" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buyHalo" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        700G
                    </button>
                </div>
            </div>
        </div>

        <!-- Astronaut Helmet -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üë®‚ÄçüöÄ</div>
                    <div>
                        <h4 class="text-xs text-cyan-400">Astronaut</h4>
                        <p class="text-[8px] text-gray-400" id="astronautStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="toggleAstronaut" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buyAstronaut" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        700G
                    </button>
                </div>
            </div>
        </div>

        <!-- Party Hat -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üéâ</div>
                    <div>
                        <h4 class="text-xs text-pink-400">Party Hat</h4>
                        <p class="text-[8px] text-gray-400" id="partyHatStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="togglePartyHat" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buyPartyHat" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        700G
                    </button>
                </div>
            </div>
        </div>

        <!-- Top Hat -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üé©</div>
                    <div>
                        <h4 class="text-xs text-gray-300">Top Hat</h4>
                        <p class="text-[8px] text-gray-400" id="topHatStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="toggleTopHat" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buyTopHat" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        700G
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Heart Crown (Valentine Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üíò</div>
                    <div>
                        <h4 class="text-xs text-pink-400">Heart Crown</h4>
                        <p class="text-[8px] text-gray-400" id="heartCrownStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleHeartCrown" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>

        <!-- Red Lantern (Lunar Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üèÆ</div>
                    <div>
                        <h4 class="text-xs text-red-400">Red Lantern</h4>
                        <p class="text-[8px] text-gray-400" id="redLanternStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleRedLantern" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>

        <!-- Love Ribbon (Valentine Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üéÄ</div>
                    <div>
                        <h4 class="text-xs text-pink-400">Love Ribbon</h4>
                        <p class="text-[8px] text-gray-400" id="loveRibbonStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleLoveRibbon" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>

        <!-- Lucky Envelope (Lunar Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üßß</div>
                    <div>
                        <h4 class="text-xs text-yellow-400">Lucky Envelope</h4>
                        <p class="text-[8px] text-gray-400" id="luckyEnvelopeStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleLuckyEnvelope" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
    </div>

    <!-- ACCESSORIES SECTION -->
    <div class="bg-gray-800 p-4 rounded-lg border-2 border-purple-500 max-h-96 overflow-y-auto">
        <h3 class="text-sm text-purple-300 mb-3 font-bold">‚ú® ACCESSORIES</h3>
        
        <!-- Carrot Nose -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">‚õÑ</div>
                    <div>
                        <h4 class="text-xs text-orange-300">Carrot Nose</h4>
                        <p class="text-[8px] text-gray-400" id="carrotStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleCarrot" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
        
        <!-- Sunglasses -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üòé</div>
                    <div>
                        <h4 class="text-xs text-gray-300">Sunglasses</h4>
                        <p class="text-[8px] text-gray-400" id="sunglassesStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="toggleSunglasses" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buySunglasses" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        700G
                    </button>
                </div>
            </div>
        </div>

        <!-- Monocle -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üßê</div>
                    <div>
                        <h4 class="text-xs text-yellow-400">Monocle</h4>
                        <p class="text-[8px] text-gray-400" id="monocleStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="toggleMonocle" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buyMonocle" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        700G
                    </button>
                </div>
            </div>
        </div>

        <!-- Mustache -->
        <div class="hidden bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">ü•∏</div>
                    <div>
                        <h4 class="text-xs text-orange-400">Mustache</h4>
                        <p class="text-[8px] text-gray-400" id="mustacheStatus">Locked</p>
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    <button id="toggleMustache" class="game-btn px-3 py-1 text-[10px]" disabled>
                        LOCKED
                    </button>
                    <button id="buyMustache" class="game-btn px-3 py-1 text-[8px] bg-yellow-500 border-yellow-700 text-white">
                        700G
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Heart Eyes (Valentine Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üòç</div>
                    <div>
                        <h4 class="text-xs text-pink-400">Heart Eyes</h4>
                        <p class="text-[8px] text-gray-400" id="heartEyesStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleHeartEyes" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
        
        <!-- Dragon Mask (Lunar Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üêâ</div>
                    <div>
                        <h4 class="text-xs text-orange-400">Dragon Mask</h4>
                        <p class="text-[8px] text-gray-400" id="dragonMaskStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleDragonMask" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>

        <!-- Gift Box (Valentine Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üíù</div>
                    <div>
                        <h4 class="text-xs text-pink-400">Gift Box</h4>
                        <p class="text-[8px] text-gray-400" id="giftBoxStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleGiftBox" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>

        <!-- Fortune Coin (Lunar Event) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">ü™ô</div>
                    <div>
                        <h4 class="text-xs text-yellow-400">Fortune Coin</h4>
                        <p class="text-[8px] text-gray-400" id="fortuneCoinStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleFortuneCoin" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
        
        <!-- Cupid's Bow (Archer Only) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üíò</div>
                    <div>
                        <h4 class="text-xs text-pink-400">Cupid's Bow</h4>
                        <p class="text-[8px] text-gray-400" id="cupidBowStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleCupidBow" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
        <!-- Christmas Tree (Knight Only) -->
        <div class="bg-gray-900 p-3 rounded mb-3 border-2 border-gray-700">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">üéÑ</div>
                    <div>
                        <h4 class="text-xs text-green-400">Christmas Tree</h4>
                        <p class="text-[8px] text-gray-400" id="christmasTreeStatus">Locked</p>
                    </div>
                </div>
                <button id="toggleChristmasTree" class="game-btn px-3 py-1 text-[10px]" disabled>
                    LOCKED
                </button>
            </div>
        </div>
    </div>
</div>
            </div>
        </div>
    </div>
</div>

<button id="btnBackFromShop" class="game-btn px-6 py-2 text-sm w-full mt-4 hidden">BACK</button>
</div>

<!-- STATS SCREEN -->
<div id="statsScreen" class="hidden w-full max-w-2xl mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700">
    <h2 class="text-xl text-yellow-400 mb-4 border-b-4 border-yellow-400 pb-2 inline-block">CAREER STATS</h2>
    
    <!-- Top 3 Heroes Podium - COMPACT VERSION -->
    <div class="bg-gradient-to-b from-gray-800 to-gray-900 p-4 rounded-lg mb-4 border-2 border-yellow-600">
        <h3 class="text-left text-yellow-300 text-xs mb-3 font-bold">üèÜ TOP HEROES üèÜ</h3>
        <div class="flex items-end justify-center gap-3 h-36">
            <!-- 2nd Place -->
            <div class="flex flex-col items-center" id="podium2nd">
                <div class="text-center mb-1">
                    <div id="hero2ndBlock" class="w-12 h-12 mx-auto mb-1 border-2 border-gray-400 shadow-lg"></div>
                    <div id="hero2ndName" class="text-[8px] text-gray-300 font-bold">---</div>
                    <div id="hero2ndKills" class="text-xs text-white font-bold">0</div>
                </div>
                <div class="relative">
                    <div class="w-20 h-20 bg-gradient-to-b from-gray-400 to-gray-600 border-4 border-gray-500 flex items-center justify-center">
                        <span class="text-3xl font-bold text-white">2</span>
                    </div>
                    <div class="absolute -top-2 -right-2 text-xl">ü•à</div>
                </div>
            </div>
            
            <!-- 1st Place -->
            <div class="flex flex-col items-center" id="podium1st">
                <div class="text-center mb-1">
                    <div id="hero1stBlock" class="w-14 h-14 mx-auto mb-1 border-4 border-yellow-400 shadow-2xl"></div>
                    <div id="hero1stName" class="text-[9px] text-yellow-300 font-bold">---</div>
                    <div id="hero1stKills" class="text-sm text-white font-bold">0</div>
                </div>
                <div class="relative">
                    <div class="w-24 h-28 bg-gradient-to-b from-yellow-400 to-yellow-600 border-4 border-yellow-500 flex items-center justify-center">
                        <span class="text-4xl font-bold text-white">1</span>
                    </div>
                    <div class="absolute -top-2 -right-2 text-2xl animate-bounce">üëë</div>
                </div>
            </div>
            
            <!-- 3rd Place -->
            <div class="flex flex-col items-center" id="podium3rd">
                <div class="text-center mb-1">
                    <div id="hero3rdBlock" class="w-10 h-10 mx-auto mb-1 border-2 border-orange-600 shadow-md"></div>
                    <div id="hero3rdName" class="text-[8px] text-gray-400 font-bold">---</div>
                    <div id="hero3rdKills" class="text-[10px] text-white font-bold">0</div>
                </div>
                <div class="relative">
                    <div class="w-16 h-16 bg-gradient-to-b from-orange-600 to-orange-800 border-4 border-orange-700 flex items-center justify-center">
                        <span class="text-2xl font-bold text-white">3</span>
                    </div>
                    <div class="absolute -top-1 -right-1 text-lg">ü•â</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Overall Stats -->
    <div class="flex flex-col gap-2 text-sm mb-6">
        <div class="stat-row">
            <span class="text-gray-400">Best Wave</span>
            <span id="statBestWave" class="text-yellow-300">0</span>
        </div>
        <div class="stat-row">
            <span class="text-gray-400">Total Kills</span>
            <span id="statTotalKills" class="text-white">0</span>
        </div>
        <div class="stat-row">
            <span class="text-gray-400">Total Deaths</span>
            <span id="statTotalDeaths" class="text-white">0</span>
        </div>
        <div class="stat-row">
            <span class="text-gray-400">Highest Level</span>
            <span id="statBestLevel" class="text-blue-400">1</span>
        </div>
    </div>
    <button id="btnBackFromStats" class="game-btn px-6 py-2 text-sm w-full">BACK</button>
</div>

<!-- SETTINGS SCREEN -->
<div id="settingsScreen" class="hidden w-full max-w-md mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700 max-h-[85vh] overflow-y-auto">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">SETTINGS</h2>

    
    
    <div class="bg-gray-800 p-4 rounded mb-4">
        <h3 class="text-white text-sm mb-3">üéµ Audio</h3>
        <div class="flex items-center justify-between">
            <span class="text-gray-400 text-xs">Background Music</span>
            <button id="musicToggle" class="game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white">
                ON
            </button>
        </div>
    </div>

    <div class="bg-gray-800 p-4 rounded mb-4">
    <h3 class="text-white text-sm mb-3">‚ö° Performance</h3>
    <div class="flex items-center justify-between">
        <span class="text-gray-400 text-xs">Performance Boost</span>
        <button id="performanceToggle" class="game-btn px-4 py-2 text-xs bg-gray-600 border-gray-800 text-white">
            OFF
        </button>
    </div>
    <p class="text-[10px] text-gray-500 mt-2">Reduces graphics quality for better FPS</p>
</div>
    <div class="text-[10px] text-gray-400 space-y-1">
    <p>WASD / Arrows - Move</p>
    <p>Mouse - Aim & Shoot</p>
    <p>SPACE - Dash</p>
    <p>V - Special Ability</p>
    <p>T - Deploy Turret</p>
    <p>B - Use Bomb</p>
    <p>L - Love Burst</p>
<p>N - Burn Wave</p>
    <p>C - Tempest Ability</p>
    <p>Q - Switch Weapon (Knight/Unit-7)</p>
</div>
    </div>
</div>
    
    <button id="btnBackFromSettings" class="game-btn px-6 py-2 text-sm w-full mt-4 hidden">BACK</button>
</div>

<!-- CHRISTMAS SCREEN -->
<!-- CHRISTMAS SCREEN -->
<div id="christmasScreen" class="hidden w-full max-w-4xl mx-auto bg-gradient-to-br from-red-900 via-green-900 to-red-900 p-8 rounded-lg border-4 border-yellow-400 shadow-2xl relative overflow-y-auto max-h-[85vh]">
    <!-- Animated Christmas Lights Border -->
    <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-red-500 via-green-500 to-red-500 animate-pulse"></div>
    
    <h2 class="text-3xl text-yellow-300 mb-2 text-center font-bold tracking-wider">üéÖ CHRISTMAS EVENT üéÑ</h2>
    <p class="text-[10px] text-gray-300 text-center mb-6">Limited Time Holiday Celebration!</p>
    
    <!-- Snowflake Currency Display -->
    <div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 text-center border-2 border-cyan-400">
        <div class="text-sm text-gray-400 mb-2">YOUR SNOWFLAKES</div>
        <div class="flex items-center justify-center gap-3">
            <div class="text-5xl">‚ùÑÔ∏è</div>
            <span id="snowflakeCount" class="text-5xl font-bold text-cyan-300">0</span>
        </div>
        <p class="text-xs text-gray-400 mt-2">Collect snowflakes from defeated enemies!</p>
    </div>
    
    <!-- Present Opening Section -->
    <div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 border-2 border-yellow-400">
        <h3 class="text-xl text-yellow-300 mb-4 text-center font-bold">üéÅ MYSTERY PRESENTS</h3>
        <p class="text-xs text-gray-300 text-center mb-4">Open presents for amazing rewards!</p>
        
        <div class="grid grid-cols-3 gap-4 mb-6">
            <!-- Basic Present -->
            <div class="bg-gradient-to-b from-green-600 to-green-800 p-4 rounded-lg border-2 border-green-400 text-center">
                <div class="text-4xl mb-2">üéÅ</div>
                <h4 class="text-sm text-white mb-2">Basic Gift</h4>
                <p class="text-[10px] text-gray-200 mb-3">Small surprise!</p>
                <button id="buyBasicPresent" class="game-btn px-3 py-2 text-[10px] w-full bg-green-500 border-green-700 text-white">
                    10 ‚ùÑÔ∏è
                </button>
            </div>
            
            <!-- Premium Present -->
            <div class="bg-gradient-to-b from-red-600 to-red-800 p-4 rounded-lg border-2 border-red-400 text-center">
                <div class="text-4xl mb-2 animate-bounce">üéÅ</div>
                <h4 class="text-sm text-yellow-300 mb-2">Premium Gift</h4>
                <p class="text-[10px] text-gray-200 mb-3">Better rewards!</p>
                <button id="buyPremiumPresent" class="game-btn px-3 py-2 text-[10px] w-full bg-red-500 border-red-700 text-white">
                    25 ‚ùÑÔ∏è
                </button>
            </div>
            
            <!-- Legendary Present -->
            <div class="bg-gradient-to-b from-yellow-500 to-yellow-700 p-4 rounded-lg border-2 border-yellow-300 text-center relative">
                <div class="absolute -top-2 -right-2 bg-red-600 text-white text-[8px] px-2 py-1 rounded-full font-bold">RARE!</div>
                <div class="text-4xl mb-2 animate-pulse">üéÅ</div>
                <h4 class="text-sm text-white mb-2">Legendary Gift</h4>
                <p class="text-[10px] text-gray-900 mb-3">Epic loot!</p>
                <button id="buyLegendaryPresent" class="game-btn px-3 py-2 text-[10px] w-full bg-yellow-400 border-yellow-600 text-black font-bold">
                    50 ‚ùÑÔ∏è
                </button>
            </div>
        </div>
        
        <!-- Reward Display -->
        <div id="presentReward" class="hidden bg-green-900 border-2 border-green-400 rounded-lg p-4 text-center">
            <p id="rewardText" class="text-lg text-yellow-300 font-bold"></p>
        </div>
    </div>
    
   <!-- What You Can Get -->
<div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 border-2 border-purple-400">
    <h3 class="text-xl text-purple-300 mb-4 text-center font-bold">üéÅ POSSIBLE REWARDS</h3>
    <p class="text-xs text-gray-300 text-center mb-4">Open presents to unlock these cosmetics!</p>
    
    <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
        <!-- Santa Hat -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">üéÖ</div>
            <h4 class="text-xs text-red-400">Santa Hat</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="santaHatPreview">Locked</p>
        </div>
        
        <!-- Elf Hat -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">üßù</div>
            <h4 class="text-xs text-green-400">Elf Hat</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="elfHatPreview">Locked</p>
        </div>
        
        <!-- Reindeer Antlers -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">ü¶å</div>
            <h4 class="text-xs text-orange-400">Antlers</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="antlersPreview">Locked</p>
        </div>
        
        <!-- Carrot Nose -->
        <div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-600 text-center">
            <div class="text-3xl mb-2">‚õÑ</div>
            <h4 class="text-xs text-orange-300">Carrot Nose</h4>
            <p class="text-[8px] text-gray-400 mt-1" id="carrotPreview">Locked</p>
        </div>
    </div>
    
    <p class="text-[10px] text-cyan-300 text-center mt-4">üí° Equip these in the Shop ‚Üí Outfits tab!</p>
</div>

    
    <button id="btnBackFromChristmas" class="game-btn px-8 py-4 text-lg w-full bg-red-600 border-red-800 text-white hover:bg-red-500 shadow-xl mt-4">
    ‚¨ÖÔ∏è BACK TO MENU
</button>
    <!-- Christmas Snow Effect Styles -->
<style>
    @keyframes snowfall {
        0% { transform: translateY(-10px) rotate(0deg); }
        100% { transform: translateY(100vh) rotate(360deg); }
    }
    .snowflake {
        position: fixed;
        top: -20px;
        color: white;
        font-size: 20px;
        opacity: 0.8;
        pointer-events: none;
        z-index: 9999;
        animation: snowfall linear infinite;
    }
</style>
</div>

<!-- EVENT SELECTION SCREEN -->
<div id="eventSelectScreen" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-95 z-50">
    <div class="max-w-4xl w-full p-8">
        <h2 class="text-4xl text-center mb-4 bg-gradient-to-r from-pink-500 via-red-500 to-purple-500 bg-clip-text text-transparent font-bold">
            üíù Hearts & Fireworks Event üéÜ
        </h2>
        <p class="text-center text-gray-300 mb-8">Choose your celebration!</p>
        
        <div class="grid grid-cols-2 gap-8">
            <!-- Valentine's Path -->
            <div class="bg-gradient-to-br from-pink-900 to-red-900 p-6 rounded-lg border-4 border-pink-500 cursor-pointer hover:scale-105 transition-all" id="selectValentine">
                <div class="text-6xl text-center mb-4">üíù</div>
                <h3 class="text-2xl text-pink-300 text-center mb-3 font-bold">Valentine's Day</h3>
                <p class="text-sm text-gray-300 text-center mb-4">Collect roses, unlock romantic cosmetics!</p>
                <div class="space-y-2 text-xs text-gray-400">
                    <p>üåπ Roses drop from enemies</p>
                    <p>üíò Unlock: Cupid Wings, Heart Crown</p>
                    <p>üèπ Final Reward: Cupid Hero</p>
                </div>
            </div>
            
            <!-- Lunar New Year Path -->
            <div class="bg-gradient-to-br from-red-900 to-yellow-900 p-6 rounded-lg border-4 border-yellow-500 cursor-pointer hover:scale-105 transition-all" id="selectLunar">
                <div class="text-6xl text-center mb-4">üéÜ</div>
                <h3 class="text-2xl text-yellow-300 text-center mb-3 font-bold">Lunar New Year</h3>
                <p class="text-sm text-gray-300 text-center mb-4">Collect fireworks, unlock festive cosmetics!</p>
                <div class="space-y-2 text-xs text-gray-400">
                    <p>üéÜ Fireworks drop from enemies</p>
                    <p>üêâ Unlock: Dragon Mask, Fortune Coin</p>
                    <p>üî• Final Reward: Dragon Hero</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- EVENT PASS SCREEN -->
<div id="eventPassScreen" class="hidden w-full max-w-5xl mx-auto bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 p-6 rounded-lg border-4 border-pink-500 max-h-[85vh] overflow-y-auto">
    <h2 class="text-2xl text-pink-300 mb-4 text-center font-bold">üíù <span id="eventPassTitle">Hearts & Fireworks</span> Event Pass üéÜ</h2>
    
    <!-- Current Progress -->
    <div class="bg-black bg-opacity-60 p-4 rounded-lg mb-6 border-2 border-pink-500">
        <div class="flex items-center justify-between mb-3">
            <div>
                <div class="text-sm text-gray-400">Your Progress</div>
                <div class="text-3xl font-bold text-white">Level <span id="eventPassLevel">0</span> / 10</div>
            </div>
            <div class="text-right">
                <div class="text-sm text-gray-400">Currency</div>
                <div class="flex items-center gap-2">
                    <span id="eventCurrencyIcon" class="text-3xl">üåπ</span>
                    <span id="eventCurrencyCount" class="text-3xl font-bold text-pink-400">0</span>
                </div>
            </div>
        </div>
        <div class="w-full h-6 bg-gray-800 rounded-full overflow-hidden border-2 border-pink-600">
            <div id="eventProgressBar" class="h-full bg-gradient-to-r from-pink-500 to-red-500" style="width: 0%"></div>
        </div>
        <p class="text-xs text-gray-400 text-center mt-2">Collect <span id="eventDropName">Roses</span> from defeated enemies!</p>
    </div>
    
    <!-- Rewards Track -->
    <div class="grid grid-cols-2 sm:grid-cols-5 gap-4 mb-6">
        <!-- Level 1 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-1">
            <div class="text-3xl mb-2">üí∞</div>
            <div class="text-xs text-yellow-400 font-bold">LEVEL 1</div>
            <div class="text-[10px] text-gray-400">100 Coins</div>
            <div class="text-[10px] text-gray-500 mt-1">10 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 2 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-2">
            <div class="text-3xl mb-2" id="cosmetic-2">üíò</div>
            <div class="text-xs text-pink-400 font-bold">LEVEL 2</div>
            <div class="text-[10px] text-gray-400" id="cosmetic-2-name">Heart Crown</div>
            <div class="text-[10px] text-gray-500 mt-1">20 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 3 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-3">
            <div class="text-3xl mb-2">üí∞</div>
            <div class="text-xs text-yellow-400 font-bold">LEVEL 3</div>
            <div class="text-[10px] text-gray-400">250 Coins</div>
            <div class="text-[10px] text-gray-500 mt-1">30 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 4 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-4">
            <div class="text-3xl mb-2" id="cosmetic-4">üéÄ</div>
            <div class="text-xs text-pink-400 font-bold">LEVEL 4</div>
            <div class="text-[10px] text-gray-400" id="cosmetic-4-name">Love Ribbon</div>
            <div class="text-[10px] text-gray-500 mt-1">40 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 5 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-5">
            <div class="text-3xl mb-2">üí∞</div>
            <div class="text-xs text-yellow-400 font-bold">LEVEL 5</div>
            <div class="text-[10px] text-gray-400">500 Coins</div>
            <div class="text-[10px] text-gray-500 mt-1">50 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 6 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-6">
            <div class="text-3xl mb-2" id="cosmetic-6">üòç</div>
            <div class="text-xs text-pink-400 font-bold">LEVEL 6</div>
            <div class="text-[10px] text-gray-400" id="cosmetic-6-name">Heart Eyes</div>
            <div class="text-[10px] text-gray-500 mt-1">60 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 7 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-7">
            <div class="text-3xl mb-2">üí∞</div>
            <div class="text-xs text-yellow-400 font-bold">LEVEL 7</div>
            <div class="text-[10px] text-gray-400">750 Coins</div>
            <div class="text-[10px] text-gray-500 mt-1">70 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 8 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-8">
            <div class="text-3xl mb-2" id="cosmetic-8">üíù</div>
            <div class="text-xs text-pink-400 font-bold">LEVEL 8</div>
            <div class="text-[10px] text-gray-400" id="cosmetic-8-name">Gift Box</div>
            <div class="text-[10px] text-gray-500 mt-1">80 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 9 -->
        <div class="bg-gray-800 p-4 rounded-lg border-2 border-gray-600 text-center" id="reward-9">
            <div class="text-3xl mb-2">üí∞</div>
            <div class="text-xs text-yellow-400 font-bold">LEVEL 9</div>
            <div class="text-[10px] text-gray-400">1000 Coins</div>
            <div class="text-[10px] text-gray-500 mt-1">90 <span class="event-currency-text">üåπ</span></div>
        </div>
        
        <!-- Level 10 - HERO UNLOCK -->
        <div class="bg-gradient-to-br from-pink-900 to-red-900 p-4 rounded-lg border-4 border-yellow-500 text-center relative" id="reward-10">
            <div class="absolute -top-2 -right-2 bg-yellow-500 text-black text-[8px] px-2 py-1 rounded-full font-bold animate-pulse">HERO!</div>
            <div class="text-4xl mb-2" id="cosmetic-10">üèπ</div>
            <div class="text-xs text-yellow-300 font-bold">LEVEL 10</div>
            <div class="text-[10px] text-pink-300 font-bold" id="cosmetic-10-name">CUPID HERO</div>
            <div class="text-[10px] text-gray-300 mt-1">100 <span class="event-currency-text">üåπ</span></div>
        </div>
    </div>
    
    <button id="btnBackFromEventPass" class="game-btn px-6 py-2 text-sm w-full">BACK TO MENU</button>
</div>

<!-- MORE SCREEN -->
<div id="moreScreen" class="hidden w-full max-w-md mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">MORE OPTIONS</h2>
    
    <div class="grid grid-cols-1 gap-4">
        <button id="btnSettingsMore" class="game-btn px-6 py-4 text-md w-full bg-gray-600 border-gray-800 text-white hover:bg-gray-500">
            ‚öôÔ∏è SETTINGS
        </button>
        <button id="btnPerksMore" class="game-btn px-6 py-4 text-md w-full bg-cyan-500 border-cyan-700 text-white hover:bg-cyan-400">
            ‚≠ê PERKS
        </button>
    </div>
    
    <button id="btnBackFromMore" class="game-btn px-6 py-2 text-sm w-full mt-6">BACK</button>
</div>

<!-- PERKS SCREEN -->
<div id="perksScreen" class="hidden w-full max-w-2xl mx-auto bg-gray-900 p-6 rounded-lg border-4 border-gray-700 max-h-[85vh] overflow-y-auto">
    <h2 class="text-xl text-yellow-400 mb-6 border-b-4 border-yellow-400 pb-2 inline-block">HERO PERKS</h2>
    
    <div class="mb-4 text-xs text-gray-400">Unlock powerful special abilities! Press [V] in-game to activate.</div>
    
    <!-- Knight Perk -->
    <div class="bg-gray-800 p-4 rounded mb-4 border-2 border-blue-500">
        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
            <div class="flex-1">
                <h3 class="text-blue-300 text-sm mb-2">‚öîÔ∏è KNIGHT - Blade Storm</h3>
                <p class="text-[10px] text-gray-400 mb-2">Spin in a devastating circle, dealing massive damage to all nearby enemies.</p>
                <div class="flex items-center gap-4 text-[10px]">
                    <span class="text-red-400">Damage: 10</span>
                    <span class="text-yellow-400">Range: 120px</span>
                    <span class="text-cyan-400">Cooldown: 12s</span>
                </div>
            </div>
            <button id="btnKnightPerk" class="game-btn px-4 py-2 text-xs bg-blue-500 border-blue-700 text-white">
                UNLOCK<br>3000G
            </button>
        </div>
        <div id="knightPerkStatus" class="text-[10px] text-gray-500 mt-2">Status: Locked</div>
    </div>
    
    <!-- Archer Perk -->
    <div class="bg-gray-800 p-4 rounded mb-4 border-2 border-green-500">
        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
            <div class="flex-1">
                <h3 class="text-green-300 text-sm mb-2">üèπ ARCHER - Ricochet Shot</h3>
                <p class="text-[10px] text-gray-400 mb-2">Next shot shoots 6 arrows that bounce off walls and pierce enemies for 5 seconds!</p>
                <div class="flex items-center gap-4 text-[10px]">
                    <span class="text-yellow-400">Duration: 5s</span>
                    <span class="text-cyan-400">Cooldown: 22s</span>
                    <span class="text-purple-400">Max Bounces: 8</span>
                </div>
            </div>
            <button id="btnArcherPerk" class="game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white">
                UNLOCK<br>3000G
            </button>
        </div>
        <div id="archerPerkStatus" class="text-[10px] text-gray-500 mt-2">Status: Locked</div>
    </div>
    <!-- Mage Perk -->
<div class="bg-gray-800 p-4 rounded mb-4 border-2 border-red-500">
    <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
        <div class="flex-1">
            <h3 class="text-red-300 text-sm mb-2">üî• MAGE - Meteor Shower</h3>
            <p class="text-[10px] text-gray-400 mb-2">Call down devastating meteors at a target location, dealing massive AOE damage and burning enemies.</p>
            <div class="flex items-center gap-4 text-[10px]">
                <span class="text-red-400">Damage: 5 per meteor</span>
                <span class="text-orange-400">Burn: 3s</span>
                <span class="text-cyan-400">Cooldown: 25s</span>
            </div>
        </div>
        <button id="btnMagePerk" class="game-btn px-4 py-2 text-xs bg-red-500 border-red-700 text-white">
            UNLOCK<br>3000G
        </button>
    </div>
    <div id="magePerkStatus" class="text-[10px] text-gray-500 mt-2">Status: Locked</div>
</div>
    
    <!-- Placeholder for future perks -->
    <div class="bg-gray-800 p-4 rounded mb-4 border-2 border-gray-600 opacity-50">
        <div class="text-center text-gray-600 text-sm py-4">
            üîí More Hero Perks Coming Soon...
        </div>
    </div>
    
    <button id="btnBackFromPerks" class="game-btn px-6 py-2 text-sm w-full">BACK</button>
</div>

<!-- TRADER SCREEN -->
<div id="traderScreen" class="hidden w-full max-w-2xl mx-auto bg-gradient-to-br from-purple-900 via-gray-900 to-blue-900 p-6 rounded-lg border-4 border-cyan-500 max-h-[85vh] overflow-y-auto">
    <h2 class="text-2xl text-cyan-300 mb-2 text-center font-bold">üßô‚Äç‚ôÇÔ∏è MYSTERIOUS TRADER</h2>
    <p class="text-xs text-gray-400 text-center mb-4">Rare items appear daily...</p>
    
    <!-- Timer Display -->
    <div class="bg-black bg-opacity-60 p-3 rounded-lg mb-4 text-center border-2 border-cyan-500">
        <div class="text-sm text-gray-400 mb-1">NEXT REFRESH</div>
        <div class="text-2xl font-bold text-cyan-300" id="traderTimer">--:--</div>
    </div>
    
    <!-- Tokens Display -->
    <div class="bg-black bg-opacity-60 p-4 rounded-lg mb-4 text-center border-2 border-yellow-500">
        <div class="text-sm text-gray-400 mb-2">YOUR TOKENS</div>
        <div class="flex items-center justify-center gap-3">
            <div class="text-4xl">‚ú®</div>
            <span id="traderTokenCount" class="text-4xl font-bold text-yellow-300">0</span>
        </div>
        <p class="text-xs text-gray-400 mt-2">Earn 1 token every 25 kills</p>
    </div>
    
    <!-- Offers Grid -->
    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6" id="traderOffers">
        <!-- Offers generated by JavaScript -->
    </div>
    
    <button id="btnBackFromTrader" class="game-btn px-6 py-2 text-sm w-full bg-cyan-600 border-cyan-800 text-white">BACK TO MENU</button>
</div>
<!-- PAC RANKING SCREEN -->
<div id="pacRankScreen" class="hidden w-full max-w-3xl mx-auto bg-gradient-to-br from-purple-900 via-gray-900 to-purple-900 p-8 rounded-lg border-4 border-purple-500 shadow-2xl max-h-[85vh] overflow-y-auto">
    <h2 class="text-2xl text-purple-300 mb-2 text-center font-bold tracking-wider">‚ö° PAC SYSTEM ‚ö°</h2>
    <p class="text-[10px] text-gray-400 text-center mb-6">Performance Analyzed Coins</p>
    
    <!-- Current Rank Display -->
    <div class="bg-black bg-opacity-60 p-6 rounded-lg mb-6 text-center border-2 border-purple-500">
        <div class="text-sm text-gray-400 mb-2">CURRENT RANK</div>
        <div id="pacCurrentRank" class="text-5xl font-bold text-purple-400 mb-2 uppercase tracking-widest">ROOKIE</div>
        <div id="pacCurrentRankIcon" class="text-6xl mb-2">üéñÔ∏è</div>
        <div class="flex items-center justify-center gap-3">
            <div class="w-8 h-8 bg-purple-400 rounded-full border-2 border-white animate-pulse"></div>
            <span id="pacCoinsDisplay" class="text-3xl font-bold text-purple-300">0</span>
            <span class="text-sm text-gray-400">PAC</span>
        </div>
    </div>
    
    <!-- Progress Track -->
    <div class="mb-8">
        <div class="flex justify-between text-xs text-gray-400 mb-2">
            <span id="pacProgressLabel">Next: FIGHTER</span>
            <span id="pacProgressText">0 / 500 PAC</span>
        </div>
        <div class="w-full h-6 bg-gray-800 border-2 border-purple-600 rounded-full overflow-hidden relative">
            <div id="pacProgressBar" class="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-500" style="width: 0%"></div>
            <div class="absolute inset-0 flex items-center justify-center text-white text-xs font-bold drop-shadow-lg">
                <span id="pacProgressPercent">0%</span>
            </div>
        </div>
    </div>
    
    <!-- Rank Milestones -->
    <div class="grid grid-cols-5 gap-2 mb-6">
        <!-- Rookie -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600" id="rank-rookie">
            <div class="text-2xl mb-1">üéñÔ∏è</div>
            <div class="text-[10px] text-gray-400 font-bold">ROOKIE</div>
            <div class="text-[8px] text-gray-500">0 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-gray-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Fighter -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-fighter">
            <div class="text-2xl mb-1">ü•ä</div>
            <div class="text-[10px] text-red-400 font-bold">FIGHTER</div>
            <div class="text-[8px] text-gray-500">800 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-red-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Challenger -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-challenger">
            <div class="text-2xl mb-1">‚öîÔ∏è</div>
            <div class="text-[10px] text-blue-400 font-bold">CHALLENGER</div>
            <div class="text-[8px] text-gray-500">2500 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-blue-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Elite -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-elite">
            <div class="text-2xl mb-1">üëë</div>
            <div class="text-[10px] text-purple-400 font-bold">ELITE</div>
            <div class="text-[8px] text-gray-500">6000 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-purple-500 rounded" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Legend -->
        <div class="bg-gray-800 p-3 rounded-lg text-center border-2 border-gray-600 opacity-50" id="rank-legend">
            <div class="text-2xl mb-1">üèÜ</div>
            <div class="text-[10px] text-yellow-400 font-bold">LEGEND</div>
            <div class="text-[8px] text-gray-500">10000 PAC</div>
            <div class="w-full h-1 bg-gray-700 rounded mt-2">
                <div class="h-full bg-yellow-500 rounded" style="width: 0%"></div>
            </div>
        </div>
    </div>
    
    <!-- Rank Benefits -->
    <div class="bg-black bg-opacity-60 p-4 rounded-lg mb-6 border-2 border-purple-500">
        <h3 class="text-sm text-purple-300 mb-3 font-bold">‚ú® CURRENT BENEFITS</h3>
        <div id="pacBenefits" class="text-xs text-gray-300 space-y-1">
            <p>üå´Ô∏è Gray Mist Trail</p>
            <p>üìä Performance Tracking</p>
        </div>
    </div>
    
    <button id="btnBackFromPac" class="game-btn px-6 py-2 text-sm w-full bg-purple-600 border-purple-800 text-white">BACK TO MENU</button>
</div>

<!-- GAME MODE SELECTION SCREEN -->
<div id="gameModeScreen" class="hidden w-full max-w-5xl mx-auto overflow-y-auto" style="max-height: 90vh;">
    <h2 class="text-4xl text-yellow-400 mb-4 text-center font-bold tracking-wider drop-shadow-[4px_4px_0_rgba(0,0,0,1)]">SELECT MODE</h2>
    <p class="text-gray-400 text-center text-sm mb-10">Choose your battle type</p>
    
    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl mx-auto px-4">
        <!-- Standard Mode Card -->
        <button id="btnStandardMode" class="group relative overflow-hidden bg-gradient-to-br from-green-900 via-green-800 to-green-900 p-8 rounded-2xl border-4 border-green-600 hover:border-green-400 transform hover:scale-105 transition-all duration-300 shadow-2xl hover:shadow-green-500/50">
            <div class="absolute inset-0 bg-gradient-to-br from-green-400/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
            <div class="relative z-10">
                <div class="text-8xl mb-6 text-center animate-pulse">‚öîÔ∏è</div>
                <h3 class="text-3xl font-bold text-white mb-4 text-center">STANDARD</h3>
                <div class="h-1 w-20 bg-green-400 mx-auto mb-4"></div>
                <p class="text-green-200 text-center text-sm leading-relaxed">
                    Endless waves of enemies<br/>
                    Unlock upgrades & survive<br/>
                    Earn coins & rewards
                </p>
            </div>
            <div class="absolute top-4 right-4 bg-green-500 text-white text-xs px-3 py-1 rounded-full font-bold">POPULAR</div>
        </button>

        <!-- Practice Mode Card -->
        <button id="btnPracticeMode" class="group relative overflow-hidden bg-gradient-to-br from-blue-900 via-purple-900 to-blue-900 p-8 rounded-2xl border-4 border-purple-600 hover:border-purple-400 transform hover:scale-105 transition-all duration-300 shadow-2xl hover:shadow-purple-500/50">
            <div class="absolute inset-0 bg-gradient-to-br from-purple-400/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
            <div class="relative z-10">
                <div class="text-8xl mb-6 text-center">üéØ</div>
                <h3 class="text-3xl font-bold text-white mb-4 text-center">PRACTICE</h3>
                <div class="h-1 w-20 bg-purple-400 mx-auto mb-4"></div>
                <p class="text-purple-200 text-center text-sm leading-relaxed">
                    Test your skills freely<br/>
                    Training dummies<br/>
                    Switch heroes anytime
                </p>
            </div>
            <div class="absolute top-4 right-4 bg-purple-500 text-white text-xs px-3 py-1 rounded-full font-bold">NO RISK</div>
        </button>
        <!-- Team Mode Card -->
        <button id="btnTeamMode" class="group relative overflow-hidden bg-gradient-to-br from-red-900 via-orange-900 to-red-900 p-8 rounded-2xl border-4 border-orange-600 hover:border-orange-400 transform hover:scale-105 transition-all duration-300 shadow-2xl hover:shadow-orange-500/50">
            <div class="absolute inset-0 bg-gradient-to-br from-orange-400/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
            <div class="relative z-10">
                <div class="text-8xl mb-6 text-center">üë•</div>
                <h3 class="text-3xl font-bold text-white mb-4 text-center">TEAM MODE</h3>
                <div class="h-1 w-20 bg-orange-400 mx-auto mb-4"></div>
                <p class="text-orange-200 text-center text-sm leading-relaxed">
                    Pick 3 heroes to battle<br/>
                    30 HP per character<br/>
                    3 lives to survive
                </p>
            </div>
            <div class="absolute top-4 right-4 bg-orange-500 text-white text-xs px-3 py-1 rounded-full font-bold">NEW!</div>
        </button>
    </div>

    <button id="btnBackFromGameMode" class="game-btn px-8 py-3 text-lg w-full max-w-md mx-auto mt-12 bg-gray-700 border-gray-900 text-white hover:bg-gray-600 block">
        ‚¨ÖÔ∏è BACK TO MENU
    </button>
</div>

<!-- TEAM SELECTION SCREEN -->
<div id="teamSelectScreen" class="hidden w-full max-w-5xl mx-auto">
    <h2 class="text-4xl text-orange-400 mb-2 text-center font-bold tracking-wider drop-shadow-[4px_4px_0_rgba(0,0,0,1)]">BUILD YOUR TEAM</h2>
    <p class="text-gray-400 text-center text-sm mb-8">Select 3 heroes - Order matters!</p>
    
    <!-- Team Slots Display -->
    <div class="flex justify-center gap-6 mb-10">
        <div class="text-center">
            <div class="text-xs text-cyan-400 mb-2">1ST HERO</div>
            <div id="teamSlot1" class="w-32 h-32 bg-gray-800 border-4 border-cyan-500 rounded-lg flex items-center justify-center">
                <span class="text-6xl text-gray-600">?</span>
            </div>
        </div>
        <div class="text-center">
            <div class="text-xs text-green-400 mb-2">2ND HERO</div>
            <div id="teamSlot2" class="w-32 h-32 bg-gray-800 border-4 border-green-500 rounded-lg flex items-center justify-center">
                <span class="text-6xl text-gray-600">?</span>
            </div>
        </div>
        <div class="text-center">
            <div class="text-xs text-yellow-400 mb-2">3RD HERO</div>
            <div id="teamSlot3" class="w-32 h-32 bg-gray-800 border-4 border-yellow-500 rounded-lg flex items-center justify-center">
                <span class="text-6xl text-gray-600">?</span>
            </div>
        </div>
    </div>
    
    <!-- Hero Selection Grid -->
    <div class="w-full max-w-3xl mb-8 overflow-y-auto mx-auto" style="max-height: 50vh;">
        <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 px-4 pb-4">
            <button class="team-hero-card" data-hero="knight" data-icon="üõ°Ô∏è" data-color="#2563eb">
    <div class="w-16 h-16 mx-auto mb-2 bg-blue-600 rounded"></div>
    <div class="text-sm">Knight</div>
</button>
<button class="team-hero-card" data-hero="mage" data-icon="üî•" data-color="#dc2626">
    <div class="w-16 h-16 mx-auto mb-2 bg-red-600 rounded"></div>
    <div class="text-sm">Mage</div>
</button>
<button class="team-hero-card" data-hero="archer" data-icon="üèπ" data-color="#16a34a">
    <div class="w-16 h-16 mx-auto mb-2 bg-green-600 rounded"></div>
    <div class="text-sm">Archer</div>
</button>
<button class="team-hero-card" data-hero="ninja" data-icon="‚öîÔ∏è" data-color="#000000">
    <div class="w-16 h-16 mx-auto mb-2 bg-black rounded"></div>
    <div class="text-sm">Ninja</div>
</button>
<button class="team-hero-card" data-hero="tempest" data-icon="üå™Ô∏è" data-color="#d1d5db">
    <div class="w-16 h-16 mx-auto mb-2 bg-gray-300 rounded"></div>
    <div class="text-sm">Tempest</div>
</button>
<button class="team-hero-card" data-hero="volt" data-icon="‚ö°" data-color="#facc15">
    <div class="w-16 h-16 mx-auto mb-2 bg-yellow-400 rounded"></div>
    <div class="text-sm">Volt</div>
</button>
<button class="team-hero-card" data-hero="mino" data-icon="üíß" data-color="#0ea5e9">
    <div class="w-16 h-16 mx-auto mb-2 bg-cyan-400 rounded"></div>
    <div class="text-sm">Minnow</div>
</button>
<button class="team-hero-card" data-hero="necromancer" data-icon="üíÄ" data-color="#7c3aed">
    <div class="w-16 h-16 mx-auto mb-2 bg-purple-600 rounded"></div>
    <div class="text-sm">Necro</div>
</button>
        </div>
    </div>
    
    <div class="flex gap-4 justify-center">
        <button id="btnStartTeamGame" class="game-btn px-12 py-4 text-xl bg-orange-500 border-orange-700 text-white disabled:opacity-50 disabled:cursor-not-allowed" disabled>
            START BATTLE
        </button>
        <button id="btnBackFromTeamSelect" class="game-btn px-8 py-3 text-lg bg-gray-700 border-gray-900 text-white">
            ‚¨ÖÔ∏è BACK
        </button>
    </div>
</div>

<!-- HERO SELECT SCREEN -->
<div id="heroSelectScreen" class="hidden flex flex-col items-center w-full max-w-4xl mx-auto">
    <h2 class="text-sm sm:text-xl text-gray-300 mb-4">SELECT YOUR HERO</h2>
    
    <!-- Scrollable container with fixed height -->
    <div class="w-full max-w-2xl mb-8 overflow-y-auto" style="max-height: 60vh;">
        <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 px-4 pb-4">
            <!-- Knight -->
            <button class="char-select-card p-4 sm:p-6" data-type="knight">
                <div class="char-block bg-blue-600 mx-auto"></div>
                <h3 class="text-xs sm:text-md text-blue-300 mb-2">Knight</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Wide Cleave</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">High HP</p>
            </button>
            
            <!-- Mage -->
            <button class="char-select-card p-4 sm:p-6" data-type="mage">
                <div class="char-block bg-red-600 mx-auto"></div>
                <h3 class="text-xs sm:text-md text-red-300 mb-2">Mage</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Explosive AOE</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">High Dmg</p>
            </button>
            
            <!-- Archer -->
            <button class="char-select-card p-4 sm:p-6" data-type="archer">
                <div class="char-block bg-green-600 mx-auto"></div>
                <h3 class="text-xs sm:text-md text-green-300 mb-2">Archer</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Machine Gun</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">Fast Fire</p>
            </button>
            
            <!-- Ninja -->
            <button class="char-select-card p-4 sm:p-6" data-type="ninja">
                <div class="char-block bg-black mx-auto relative">
                    <div class="absolute top-2 left-0 w-full h-3 bg-red-600"></div>
                </div>
                <h3 class="text-xs sm:text-md text-gray-300 mb-2">Ninja</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Shuriken Storm</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">Double Dash</p>
            </button>
            
            <!-- Tempest -->
            <button class="char-select-card p-4 sm:p-6" data-type="tempest">
                <div class="char-block bg-gray-300 mx-auto relative">
                    <div class="absolute inset-0 flex items-center justify-center text-2xl">üå™Ô∏è</div>
                </div>
                <h3 class="text-xs sm:text-md text-gray-300 mb-2">Tempest</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Wind Boomerangs</p>
                <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">Fury Wave</p>
            </button>

            <!-- Volt (High-Tech Whip Character) -->
<button class="char-select-card p-4 sm:p-6" data-type="volt">
    <div class="char-block bg-gradient-to-br from-yellow-400 to-yellow-600 mx-auto relative">
        <div class="absolute inset-0 flex items-center justify-center text-3xl">‚ö°</div>
    </div>
    <h3 class="text-xs sm:text-md text-yellow-300 mb-2">Volt</h3>
    <p class="text-[8px] sm:text-[10px] text-gray-400">Arc Lash</p>
    <p class="text-[8px] sm:text-[10px] text-yellow-500 mt-1">Awesome Sauce</p>
</button>

<!-- Mino (Water Character) -->
<button class="char-select-card p-4 sm:p-6" data-type="mino">
    <div class="char-block bg-gradient-to-br from-cyan-400 to-blue-600 mx-auto relative">
        <div class="absolute inset-0 flex items-center justify-center text-3xl">üíß</div>
    </div>
    <h3 class="text-xs sm:text-md text-cyan-300 mb-2">Minnow</h3>
    <p class="text-[8px] sm:text-[10px] text-gray-400">Water Gun</p>
    <p class="text-[8px] sm:text-[10px] text-cyan-500 mt-1">Water Spray</p>
</button>

<!-- Necromancer -->
<button class="char-select-card p-4 sm:p-6" data-type="necromancer">
    <div class="char-block bg-gradient-to-br from-purple-900 to-violet-600 mx-auto relative">
        <div class="absolute inset-0 flex items-center justify-center text-3xl">üíÄ</div>
    </div>
    <h3 class="text-xs sm:text-md text-purple-300 mb-2">Necromancer</h3>
    <p class="text-[8px] sm:text-[10px] text-gray-400">Soul Orbs</p>
    <p class="text-[8px] sm:text-[10px] text-purple-500 mt-1">Summons Skeletons</p>
</button>
            
            <!-- Zap (LOCKED - Legend Rank) -->
            <button class="char-select-card p-4 sm:p-6 opacity-50 cursor-not-allowed" data-type="zap" id="zapCard">
                <div class="char-block bg-gradient-to-br from-yellow-400 to-blue-500 mx-auto relative">
                    <div class="absolute inset-0 flex items-center justify-center text-3xl">‚ö°</div>
                    <div class="absolute top-0 right-0 text-2xl">üîí</div>
                </div>
                <h3 class="text-xs sm:text-md text-yellow-300 mb-2">Zap</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Chain Lightning</p>
                <p class="text-[8px] sm:text-[10px] text-purple-500 mt-1">Legend Rank Required</p>
            </button>
            
            <!-- Unit-7 (LOCKED - Elite Rank) -->
            <button class="char-select-card p-4 sm:p-6 opacity-50 cursor-not-allowed" data-type="unit7" id="unit7Card">
                <div class="char-block bg-gradient-to-br from-blue-400 to-gray-600 mx-auto relative">
                    <div class="absolute inset-0 flex items-center justify-center text-3xl">ü§ñ</div>
                    <div class="absolute top-0 right-0 text-2xl">üîí</div>
                </div>
                <h3 class="text-xs sm:text-md text-blue-300 mb-2">Unit-7</h3>
                <p class="text-[8px] sm:text-[10px] text-gray-400">Dual-Core</p>
                <p class="text-[8px] sm:text-[10px] text-purple-500 mt-1">Elite Rank Required</p>
            </button>

<!-- Cupid (LOCKED - Valentine Event) -->
<button class="char-select-card p-4 sm:p-6 opacity-50 cursor-not-allowed" data-type="cupid" id="cupidCard">
    <div class="char-block bg-gradient-to-br from-pink-400 to-pink-600 mx-auto relative">
        <div class="absolute inset-0 flex items-center justify-center text-3xl">üíò</div>
        <div class="absolute top-0 right-0 text-2xl">üîí</div>
    </div>
    <h3 class="text-xs sm:text-md text-pink-300 mb-2">Cupid</h3>
    <p class="text-[8px] sm:text-[10px] text-gray-400">Heart Splitter</p>
    <p class="text-[8px] sm:text-[10px] text-purple-500 mt-1">Event Pass Reward</p>
</button>

<!-- Dragon (LOCKED - Lunar Event) -->
<button class="char-select-card p-4 sm:p-6 opacity-50 cursor-not-allowed" data-type="dragon" id="dragonCard">
    <div class="char-block bg-gradient-to-br from-orange-500 to-red-600 mx-auto relative">
        <div class="absolute inset-0 flex items-center justify-center text-3xl">üê≤</div>
        <div class="absolute top-0 right-0 text-2xl">üîí</div>
    </div>
    <h3 class="text-xs sm:text-md text-orange-300 mb-2">Dragon</h3>
    <p class="text-[8px] sm:text-[10px] text-gray-400">Flame Breath</p>
    <p class="text-[8px] sm:text-[10px] text-purple-500 mt-1">Event Pass Reward</p>
</button>
        </div>
    </div>
    

    <button id="btnBackFromSelect" class="text-gray-500 hover:text-white text-xs underline mt-4">Back to Menu</button>
</div>
        <!-- Game UI Overlay (Hidden by default) -->
<div id="gameUI" class="hidden w-full absolute top-0 left-0 pointer-events-none flex flex-col gap-2 z-10 h-full">
    <!-- Team Mode UI - Lives Indicator -->
    <div id="teamLivesUI" class="hidden absolute top-20 left-4 bg-black bg-opacity-80 p-4 rounded-lg border-2 border-orange-500 z-50">
        <div class="text-orange-300 text-xs mb-2 font-bold">YOUR TEAM</div>
        <div class="flex flex-col gap-2">
            <div id="teamLife1" class="flex items-center gap-2 p-2 bg-gray-900 rounded border-2 border-cyan-500">
                <span class="text-2xl" id="teamIcon1">üõ°Ô∏è</span>
                <span class="text-xs text-white font-bold" id="teamName1">Knight</span>
                <span class="text-xs text-green-400 ml-auto" id="teamStatus1">ACTIVE</span>
            </div>
            <div id="teamLife2" class="flex items-center gap-2 p-2 bg-gray-900 rounded border-2 border-gray-600">
                <span class="text-2xl" id="teamIcon2">üî•</span>
                <span class="text-xs text-white font-bold" id="teamName2">Mage</span>
                <span class="text-xs text-gray-400 ml-auto" id="teamStatus2">READY</span>
            </div>
            <div id="teamLife3" class="flex items-center gap-2 p-2 bg-gray-900 rounded border-2 border-gray-600">
                <span class="text-2xl" id="teamIcon3">üèπ</span>
                <span class="text-xs text-white font-bold" id="teamName3">Archer</span>
                <span class="text-xs text-gray-400 ml-auto" id="teamStatus3">READY</span>
            </div>
        </div>
    </div>
    <!-- Practice Mode UI -->
    <div id="practiceUI" class="hidden absolute top-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-80 p-4 rounded-lg border-2 border-cyan-400 z-50">
        <div class="text-center mb-3">
            <div class="text-cyan-300 text-sm mb-1">PRACTICE MODE</div>
            <div class="text-yellow-400 text-xs">Press F to switch heroes</div>
        </div>
    </div>
    <!-- Top Bar -->
    <div class="flex justify-between items-start px-4 text-white drop-shadow-lg w-full mt-3">
        <div class="text-left bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-gray-700">
            <!-- ENHANCED: Much Larger Wave Text with better contrast -->
            <div class="text-base sm:text-lg text-gray-300 font-bold">WAVE</div>
            <div id="waveDisplay" class="text-yellow-400 text-5xl font-bold wave-anim leading-none">1</div>
            <div class="text-sm text-gray-400 font-bold mt-1" id="waveTimer">Next: 30s</div>
        </div>
        
        <!-- In-Game Coin Count -->
        <div class="flex flex-col items-center">
            <div class="flex items-center gap-3 bg-black bg-opacity-70 px-5 py-3 rounded-lg border-2 border-yellow-500 shadow-lg">
                <div class="w-6 h-6 bg-yellow-400 rounded-full border-2 border-white"></div>
                <!-- ENHANCED: Much Larger Coin Text -->
                <span id="gameCoins" class="text-yellow-300 text-2xl font-bold">0</span>
            </div>
            <!-- ENHANCED: Larger Dash Indicators -->
            <div id="dashIndicator" class="text-sm text-cyan-400 mt-2 font-bold hidden bg-black bg-opacity-60 px-3 py-1 rounded">‚ö° DASH READY</div>
            <div id="doubleDashIndicator" class="text-sm text-red-400 mt-2 font-bold hidden bg-black bg-opacity-60 px-3 py-1 rounded">‚ö°‚ö° DOUBLE DASH</div>
            <!-- Tempest Fury Bar -->
<div id="furyBarContainer" class="hidden mt-2 w-32">
    <div class="text-[10px] text-cyan-300 text-center mb-1">FURY</div>
    <div class="w-full h-3 bg-gray-800 border-2 border-cyan-400 rounded overflow-hidden">
        <div id="furyBarFill" class="h-full bg-gradient-to-r from-cyan-400 to-blue-500" style="width: 0%"></div>
    </div>
</div>
        </div>

        <div class="text-right bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-gray-700">
            <!-- ENHANCED: Much Larger Level Text -->
            <div class="text-base sm:text-lg text-gray-300 font-bold">LEVEL</div>
            <div id="levelDisplay" class="text-white text-5xl font-bold leading-none">1</div>
        </div>
    </div>
    <!-- LEFT SIDEBAR: Active Abilities -->
<div id="abilitySidebar" class="absolute left-2 top-24 flex flex-col gap-2 w-16 max-h-[70vh] overflow-y-auto">
    <!-- Abilities will be dynamically added here -->
</div>


    <!-- Bottom Right: Skills -->
    <div class="absolute bottom-20 right-2 flex gap-2">
        <!-- Turret UI -->
        <div id="turretHud" class="hidden flex flex-col items-center bg-black bg-opacity-70 p-3 rounded-lg border-2 border-gray-500">
            <div class="text-gray-300 text-2xl mb-1">üî´</div>
            <div class="text-sm text-white text-center font-bold">
                [T] <br> x<span id="hudTurretCount" class="text-green-400 font-bold text-lg">0</span>
            </div>
        </div>
        <!-- Bomb UI -->
        <div id="bombHud" class="hidden flex flex-col items-center bg-black bg-opacity-70 p-3 rounded-lg border-2 border-gray-500">
            <div class="text-orange-500 text-2xl mb-1">üí£</div>
            <div class="text-sm text-white text-center font-bold">
                [B] <br> x<span id="hudBombCount" class="text-orange-400 font-bold text-lg">0</span>
            </div>
        </div>
        <!-- Love Burst UI -->
<div id="loveBurstHud" class="hidden flex flex-col items-center bg-black bg-opacity-70 p-3 rounded-lg border-2 border-gray-500">
    <div class="text-pink-500 text-2xl mb-1">üíó</div>
    <div class="text-sm text-white text-center font-bold">
        [L] <br> x<span id="hudLoveBurstCount" class="text-pink-400 font-bold text-lg">0</span>
    </div>
</div>
<!-- Burn Wave UI -->
<div id="burnWaveHud" class="hidden flex flex-col items-center bg-black bg-opacity-70 p-3 rounded-lg border-2 border-gray-500">
    <div class="text-orange-500 text-2xl mb-1">üî•</div>
    <div class="text-sm text-white text-center font-bold">
        [N] <br> x<span id="hudBurnWaveCount" class="text-orange-400 font-bold text-lg">0</span>
    </div>
</div>
    </div>
    
    <!-- XP Bar (Bottom) -->
    <div class="absolute bottom-2 left-0 px-4 w-full">
        <!-- ENHANCED: Much Larger HP & Kills with better backgrounds -->
        <div class="flex justify-between px-4 mt-1 text-lg font-bold pb-3">
            <span class="bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-red-500">
                <span class="text-red-400 drop-shadow-lg">‚ù§Ô∏è HP: <span id="hpDisplay" class="text-white text-xl">100/100</span></span>
            </span>
            <span class="bg-black bg-opacity-60 px-4 py-2 rounded-lg border-2 border-purple-500">
                <span class="text-gray-300 drop-shadow-lg">üíÄ Kills: <span id="kills" class="text-white text-xl">0</span></span>
            </span>
        </div>
        <div class="xp-container h-6 border-3">
            <div id="xpBar" class="xp-fill"></div>
            <div class="absolute inset-0 flex items-center justify-center text-xs text-white font-bold drop-shadow-lg">XP</div>
        </div>
    </div>
</div>

            <!-- Bottom Right: Skills -->
            <div class="absolute bottom-16 right-2 flex gap-2">
                <!-- Turret UI -->
                <div id="turretHud" class="hidden flex flex-col items-center bg-black bg-opacity-60 p-2 rounded border border-gray-500">
                    <div class="text-gray-300 text-xl mb-1">üî´</div>
                    <div class="text-xs text-white text-center">
                        [T] <br> x<span id="hudTurretCount" class="text-green-400 font-bold">0</span>
                    </div>
                </div>
                <!-- Bomb UI -->
                <div id="bombHud" class="hidden flex flex-col items-center bg-black bg-opacity-60 p-2 rounded border border-gray-500">
                    <div class="text-orange-500 text-xl mb-1">üí£</div>
                    <div class="text-xs text-white text-center">
                        [B] <br> x<span id="hudBombCount" class="text-orange-400 font-bold">0</span>
                    </div>
                </div>
            </div>
            

        <!-- Game Screen -->
        <div id="gameScreen" class="hidden relative flex justify-center">
            <canvas id="gameCanvas" width="800" height="600" style="width: 100%; height: auto;"></canvas>
            
            <!-- Wave Notification -->
            <div id="waveMsg" class="hidden absolute top-1/3 left-0 w-full text-center pointer-events-none z-20">
                <h2 id="waveMsgText" class="text-4xl sm:text-6xl text-red-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold">WAVE <span id="waveMsgNum">1</span></h2>
            </div>

            <!-- Level Up Notification -->
            <div id="levelUpMsg" class="hidden absolute top-1/4 left-0 w-full text-center pointer-events-none z-20">
            <!-- PAC Rank Up Notification -->
<div id="pacRankUpMsg" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-80 z-50 pointer-events-none">
    <div class="text-center animate-bounce">
        <div class="text-6xl mb-4" id="pacRankUpIcon">üèÜ</div>
        <h2 class="text-5xl font-bold mb-2 bg-gradient-to-r from-purple-400 via-pink-500 to-purple-400 bg-clip-text text-transparent">
            RANK UP!
        </h2>
        <p class="text-3xl text-white font-bold mb-4" id="pacRankUpText">FIGHTER</p>
        <p class="text-lg text-gray-300">New trail unlocked!</p>
    </div>
</div>
                <h2 class="text-2xl sm:text-4xl text-yellow-300 drop-shadow-[0_4px_0_#000] animate-bounce">LEVEL UP!</h2>
                <p id="upgradeText" class="text-white text-xs sm:text-sm mt-2 bg-black bg-opacity-70 inline-block px-4 py-2 rounded border border-yellow-500">Damage Increased!</p>
            </div>
        </div>

<!-- Upgrade Selection Screen -->
<div id="upgradeScreen" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-95 z-50">
    <div class="max-w-5xl w-full p-8">
        <div class="text-center mb-8">
            <h2 class="text-5xl text-yellow-400 font-bold mb-2 drop-shadow-[0_4px_0_rgba(0,0,0,1)] animate-pulse">‚¨ÜÔ∏è LEVEL UP! ‚¨ÜÔ∏è</h2>
            <p class="text-lg text-cyan-300 mb-2">Choose Your Power</p>
            <p class="text-sm text-gray-400">Pick wisely - upgrades last this run only</p>
        </div>
        
        <div id="upgradeChoices" class="grid grid-cols-1 sm:grid-cols-3 gap-8 mb-8">
            <!-- Upgrade cards will be generated here -->
        </div>
        
        <div class="text-center text-xs text-gray-500 bg-gray-900 p-3 rounded-lg border border-gray-700">
            <p>üí° <span class="text-yellow-400">Red</span> = Offense | <span class="text-blue-400">Blue</span> = Defense | <span class="text-purple-400">Purple</span> = Utility</p>
        </div>
    </div>
</div>

<!-- Pause Screen -->
<div id="pauseScreen" class="hidden fixed inset-0 flex flex-col items-center justify-center bg-black bg-opacity-90 z-50">
    <h2 class="text-5xl text-yellow-400 mb-8 font-bold animate-pulse">‚è∏Ô∏è PAUSED</h2>
    <div class="flex flex-col gap-4">
        <button id="btnResume" class="game-btn px-12 py-4 text-xl bg-green-500 border-green-700 text-white">
            ‚ñ∂Ô∏è RESUME
        </button>
        <button id="btnQuitToMenu" class="game-btn px-12 py-4 text-xl bg-red-500 border-red-700 text-white">
            üè† QUIT TO MENU
        </button>
    </div>
    <p class="text-gray-400 text-sm mt-8">Press [P] to resume</p>
</div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden fixed inset-0 flex flex-col items-center justify-center bg-black bg-opacity-95 z-50">
            <h2 class="text-3xl sm:text-5xl text-red-500 mb-2 drop-shadow-[4px_4px_0_#fff]">YOU DIED</h2>
            <p class="text-sm sm:text-xl text-gray-300 mb-8">Survived Wave: <span id="finalWave" class="text-yellow-400">1</span></p>
            
           <div class="grid grid-cols-3 gap-6 mb-8 text-left text-xs sm:text-sm bg-gray-900 p-6 rounded border border-gray-700">
    <div>
        <p class="text-gray-500 mb-1">Total Kills</p>
        <p id="finalKills" class="text-white text-xl">0</p>
    </div>
    <div>
        <p class="text-gray-500 mb-1">Coins Earned</p>
        <p id="finalCoins" class="text-yellow-400 text-xl">0</p>
    </div>
    <div>
        <p class="text-gray-500 mb-1">PAC Earned</p>
        <p id="finalPAC" class="text-purple-400 text-xl">0</p>
    </div>
</div>
            
            <button id="restartButton" class="game-btn px-8 py-4 text-lg bg-white border-gray-400">RETURN TO MENU</button>
        </div>
    </div>

    <script>

        // =====================================================
// GLOBAL FUNCTIONS (Must be outside DOMContentLoaded)
// =====================================================

            document.addEventListener('DOMContentLoaded', () => {
    
   
    
    // =====================================================
    //  GAME CONFIGURATION - TWEAK THESE NUMBERS TO BALANCE
            
            // =====================================================
            //  GAME CONFIGURATION - TWEAK THESE NUMBERS TO BALANCE
            // =====================================================
            const GAME_CONFIG = {
                // --- PLAYER STATS ---
                PLAYER: {
                    BASE_SIZE: 28,
                    BASE_SPEED: 3.5,
                    BASE_HP: 100,
                    BASE_MAGNET: 100,
                    MAGNET_PER_UPGRADE: 30,
                    HP_PER_UPGRADE: 15,
                    DASH: {
                        COOLDOWN: 180, // 3 seconds (60 frames = 1s)
                        DURATION: 10,  // How long dash lasts
                        SPEED: 12,     // Dash velocity
                    }
                },

                // --- CLASS SPECIFIC STATS ---
                CLASSES: {
                    knight: {
                        color: '#2563eb',
                        hp_bonus: 50,       // Starts with 150 HP
                        damage_mult: 1.0,
                        fire_rate_mult: 0.65,
                        sword_length: 105,
                        sword_width: 15
                    },
                    mage: {
                        color: '#dc2626',
                        hp_bonus: 0,
                        damage_mult: 1.15,   // 20% more damage
                        fire_rate_mult: 0.7,
                        speed_mult: 0.8
                    },
                    archer: {
                        color: '#16a34a',
                        hp_bonus: -15,
                        damage_mult: 0.88,
                        fire_rate_mult: 1.0, // Shoots 10% faster
                        speed_mult: 1.15     // Moves 15% faster
                    },
                    //class NINJA
                    ninja: {
                        color: '#000000',
                        hp_bonus: -20,      // Slightly lower HP
                        damage_mult: 0.8,
                        fire_rate_mult: 1.1, // Very fast shurikens
                        speed_mult: 1.3,     // Very fast movement
                        canDoubleDash: true
                    },
                   
//class TEMPEST
tempest: {
    color: '#d1d5db',  // Light gray
    hp_bonus: 0,
    damage_mult: 1.2,
    fire_rate_mult: 0.7,
    speed_mult: 1.1,
    furyBarMax: 8  // Kills needed to fill fury bar
},
// NEW CLASS: ZAP (LEGEND RANK ONLY) - REWORKED FOR FUN
zap: {
    color: '#fbbf24',  // Yellow
    hp_bonus: -10,     // Slightly low HP (was -30)
    damage_mult: 0.9,  // Reduced base damage (was 1.0)
    fire_rate_mult: 1.0, // Faster shooting (was 1.2)
    speed_mult: 1.25,  // Fast but not crazy (was 1.4)
    chainRange: 120,   // Slightly reduced chain range (was 150)
    chargeCounter: 0,  // Tracks charge buildup
    maxCharge: 100,    // Max charge points
}
,
unit7: {
    color: '#60a5fa',  // Chrome blue
    hp_bonus: -5,     // Low HP (glass cannon)
    damage_mult: 1.0,
    fire_rate_mult: 1.0,
    speed_mult: 0.85,
    // Weapon modes
    currentMode: 'laser',  // 'laser' or 'micro'
    laserCooldown: 0,
    microCooldown: 0,
    microAmmo: 15,
    microMaxAmmo: 15
}

,
mino: {
    color: '#0ea5e9',  // Sky blue
    hp_bonus: 0,
    damage_mult: 1.1,
    fire_rate_mult: 1.0,
    speed_mult: 1.0,
    bubbleCharge: 0
},
volt: {
    color: '#facc15',
    hp_bonus: -30,
    damage_mult: 1.2,
    fire_rate_mult: 0.5,
    speed_mult: 0.9,
    dashCharge: 0,
    dashChargeMax: 100
},
cupid: {
    color: '#ec4899',
    hp_bonus: -20,
    damage_mult: 1.0,
    fire_rate_mult: 0.9,
    speed_mult: 1.1
},
dragon: {
    color: '#f97316',
    hp_bonus: 20,
    damage_mult: 0.8,
    fire_rate_mult: 0.5,
    speed_mult: 0.9,
    breathCooldown: 0,
    rageCharge: 0,
    rageMax: 100
},
necromancer: {
    color: '#7c3aed',  // Deep purple
    hp_bonus: -10,
    damage_mult: 0.9,
    fire_rate_mult: 0.6,  // Very slow fire rate
    speed_mult: 0.95,
    soulCharge: 0,
    soulChargeMax: 10,  // 10 kills to summon skeletons
    summonCooldown: 0
}
                
                },
// --- SPECIAL DROPS ---
SPECIAL_DROPS: {
    GOLDEN_COIN: {
        value: 15,
        spawn_chance: 0.03, // 3% chance
        decay_time: 240, // 4 seconds before disappearing
        risk_radius: 150 // Enemies spawn near it
    },
    HEALTH_PACK: {
        heal_amount: 30,
        spawn_chance: 0.02, // 2% chance
        decay_time: 180
    }
},

                // --- ENEMY STATS ---
                ENEMIES: {
                    normal: {
                        hp: 5,
                        speed: 1.33,
                        xp: 1,
                        size: 24,
                        color: '#b91c1c',
                        spawn_wave: 1
                    },

                   ranger: {
    hp: 5,
    speed: 1.1,
    xp: 2,
    size: 24,
    color: '#eab308',
    spawn_wave: 1,
    spawn_chance: 0.25,
    shootRange: 250,
    shootCooldown: 150,
    projectileSpeed: 12,
    projectileSize: 12,
    projectileDamage: 4
},
                    brute: {
                        hp: 25,
                        speed: 0.9,
                        xp: 10,
                        size: 50,
                        color: '#7f1d1d',
                        spawn_wave: 3,
                        spawn_chance: 0.15
                    },
                    frosty: {
                        hp: 10,
                        speed: 1.8,
                        xp: 5,
                        size: 32,
                        color: '#06b6d4',
                        spawn_wave: 5,
                        spawn_chance: 0.30
                    },
                    boss: {
                        hp: 85,
                        speed: 1.5,
                        xp: 50,
                        size: 100,
                        color: '#581c87',
                        damage: 3
                    },
                    // NEW ELITE ENEMIES
                    elite_specter: {
                        hp: 10,
                        speed: 2.2,
                        xp: 15,
                        size: 28,
                        color: '#9333ea',
                        spawn_wave: 7,
                        spawn_chance: 0.09,
                        ability: 'phase',
                        abilityCooldown: 180
                    },
                    elite_tank: {
                        hp: 40,
                        speed: 0.8,
                        xp: 20,
                        size: 45,
                        color: '#1e40af',
                        spawn_wave: 6,
                        spawn_chance: 0.18,
                        ability: 'shield',
                        abilityCooldown: 300
                    },
                    elite_splitter: {
                        hp: 15,
                        speed: 1.6,
                        xp: 12,
                        size: 32,
                        color: '#15803d',
                        spawn_wave: 8,
                        spawn_chance: 0.18,
                        ability: 'split',
                        splitCount: 3
                    }
                },

               // --- WAVE & DIFFICULTY ---
WAVES: {
    DURATION: 30, // Seconds per wave
    HP_SCALING: 0.12, // REDUCED: Enemies get +12% HP per wave (was 20%)
    HP_SCALING_CAP: 3.0, // Caps at 3x HP (prevents infinite scaling)
    COIN_CHANCE_BASE: 0.2, // 20% drop chance
    COIN_CHANCE_SCALING: 0.02, // +2% per wave
},

           PROJECTILES: {
    fireball: { damage: 3, speed: 6, size: 16, knockback: 1, explosionRadius: 70 },
    arrow:    { damage: 1.5, speed: 10, size: 8, knockback: 6 }, 
    sword:    { damage: 6.5, knockback: 2 }, 
    turret:   { damage: 1.5, speed: 12, size: 6, knockback: 0 },
    shuriken: { damage: 0.6, speed: 15, size: 6, knockback: 1.0 },
    boomerang: { damage: 0.8, speed: 8, size: 12, knockback: 3, maxDistance: 200, curveRate: 0.08, bonusDamagePerCurve: 0.15 },
    lightning: { damage: 2.5, speed: 18, size: 10, knockback: 2, chainRange: 150, chainDamage: 0.5 }
    ,
corelaser: { damage: 15, speed: 25, size: 12, knockback: 8, pierce: true },
microburst: { damage: 0.8, speed: 14, size: 4, knockback: 0.5 },
cupidArrow: { damage: 3, speed: 12, size: 10, knockback: 3, pierce: true },
dragonBreath: { damage: 1.5, speed: 8, size: 20, knockback: 1, pierce: true },
waterGun: { damage: 0.18, speed: 12, size: 12, knockback: 0 },
whip: { damage: 2, speed: 0, size: 8, knockback: 4, range: 100 },
necroOrb: { damage: 2.5, speed: 7, size: 14, knockback: 2, slowDuration: 90 }
},

                // --- TURRET ITEM ---
                TURRET: {
                    COST: 40, // UPDATED: Lowered cost
                    LIFETIME: 1200, // 15 seconds
                    RANGE: 210,
                    FIRE_RATE: 90  // UPDATED: Slower fire rate
                },
                // --- BOMB ITEM ---
                BOMB: {
    COST: 80,
    DAMAGE: 20,
    RADIUS: 150,
},

                // --- SHOP COSTS ---
                SHOP: {
                    HEALTH_BASE: 150,
                    MAGNET_BASE: 100,
                    SKIN: 500
                },
                
                STORAGE_KEY: 'Blocky Legends'

                ,
MAPS: {
    forest: {
        name: 'Dark Forest',
        bgColor: '#0a2f0a',
        gridColor: '#1a4d1a',
        treeCount: 15,
        trees: [],
        enemyTint: '#2d5016'
    },
    desert: {
        name: 'Scorched Desert',
        bgColor: '#3d2817',
        gridColor: '#5d3d27',
        cactusCount: 12,
        cacti: [],
        enemyTint: '#8b4513'
    },
    ice: {
        name: 'Frozen Wasteland',
        bgColor: '#1a2a3a',
        gridColor: '#2a3f5f',
        crystalCount: 10,
        crystals: [],
        enemyTint: '#4a7c9e'
    },
    volcano: {
        name: 'Volcanic Crater',
        bgColor: '#2a0f0f',
        gridColor: '#4a1f1f',
        lavaPoolCount: 8,
        lavaPools: [],
        enemyTint: '#8b0000'
    },
   swamp: {
    name: 'Misty Swamp',
    bgColor: '#1a2618',
    gridColor: '#2a3628',
    fogDensity: 0.3,
    fogColor: 'rgba(200, 220, 200, 0.4)',
    treeCount: 12,
    trees: [],
    enemyTint: '#4a6e4a'
}
}

            };

            // =====================================================
// TEMPORARY UPGRADE SYSTEM
// =====================================================
const UPGRADE_POOL = [
    // ========== OFFENSE ==========
    {
        id: 'fire_ring',
        name: 'Inferno Aura',
        icon: 'üî•',
        description: 'Blazing ring burns all enemies that dare get close',
        type: 'offense',
        maxStack: 5,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.fireRing = (player.upgrades.fireRing || 0) + 1;
        }
    },
    {
        id: 'lightning_storm',
        name: 'Lightning Storm',
        icon: '‚ö°',
        description: 'Call down devastating lightning bolts on random enemies',
        type: 'offense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.lightningStorm = (player.upgrades.lightningStorm || 0) + 1;
        }
    },
    {
        id: 'attack_speed',
        name: 'Rapid Fire',
        icon: 'üèπ',
        description: '+15% attack speed',
        type: 'offense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.attackSpeed = (player.upgrades.attackSpeed || 0) + 1;
            player.fireRateMult *= 1.15;
        }
    },
    {
    id: 'stun_gun',
    name: 'Stun Gun',
    icon: '‚ö°',
    description: '4% chance to stun enemies for 2 seconds on hit',
    type: 'utility',
    maxStack: 3,
    inRotation: true,
    effect: (player, stacks) => {
        player.upgrades.stunGun = (player.upgrades.stunGun || 0) + 1;
    }
},
// ========== DEFENSE ==========
    
{
    id: 'regen_aura',
    name: 'Regeneration Aura',
    icon: 'üíö',
    description: 'Heal 2 HP every 3 seconds', // UPDATED: Was 3 HP/2s, now 2 HP/3s
    type: 'defense',
    maxStack: 5,
    inRotation: true,
    effect: (player, stacks) => {
        player.upgrades.regenAura = (player.upgrades.regenAura || 0) + 1;
        // Initialize regen timer if it doesn't exist
        if (!player.regenTimer) player.regenTimer = 0;
    }
},
{
    id: 'ice_barrier',
    name: 'Frost Aura',
    icon: '‚ùÑÔ∏è',
    description: 'Freeze and slow enemies near you by 40%', // UPDATED: Was 60%, now 40%
        type: 'defense',
        maxStack: 4,
        inRotation: false,
        effect: (player, stacks) => {
            player.upgrades.iceBarrier = (player.upgrades.iceBarrier || 0) + 1;
        }
    },
    {
        id: 'max_health',
        name: 'Vitality Boost',
        icon: '‚ù§Ô∏è',
        description: '+25 Max HP and instant heal',
        type: 'defense',
        maxStack: 5,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.maxHealth = (player.upgrades.maxHealth || 0) + 1;
            player.maxHp += 25;
            player.hp = Math.min(player.hp + 25, player.maxHp);
            player.updateUI();
        }
    },
    {
        id: 'lifesteal',
        name: 'Vampirism',
        icon: 'ü©∏',
        description: 'Heal 2 HP for every 25 damage dealt',
        type: 'defense',
        maxStack: 5,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.lifesteal = (player.upgrades.lifesteal || 0) + 1;
        }
    },
    {
        id: 'chain_reaction',
        name: 'Chain Reaction',
        icon: 'üí•',
        description: 'Enemies explode on death, damaging nearby enemies',
        type: 'offense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.chainReaction = (player.upgrades.chainReaction || 0) + 1;
        }
    },
{
    id: 'thorns',
    name: 'Thorn Armor',
    icon: 'üåµ',
    description: 'Reflect 15% damage back to attackers', // UPDATED: Was 40%, now 15%
        type: 'defense',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.thorns = (player.upgrades.thorns || 0) + 1;
        }
    },
    
    // ========== UTILITY ==========
   {
        id: 'speed_boost',
        name: 'Lightning Step',
        icon: '‚ö°',
        description: 'Gain burst of speed after killing enemies',
        type: 'utility',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.speedBoost = (player.upgrades.speedBoost || 0) + 1;
        }
    },
    {
        id: 'move_speed',
        name: 'Swift Feet',
        icon: 'üëü',
        description: '+12% movement speed',
        type: 'utility',
        maxStack: 4,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.moveSpeed = (player.upgrades.moveSpeed || 0) + 1;
            player.speed *= 1.12;
        }
    },
     {
        id: 'pocket_sandwich',
        name: 'Pocket Sandwich',
        icon: 'ü•™',
        description: 'Eat for instant speed + fire rate boost! (10s duration)',
        type: 'utility',
        maxStack: 3,
        inRotation: false,
        effect: (player, stacks) => {
    player.upgrades.pocketSandwich = (player.upgrades.pocketSandwich || 0) + 1;
    
    // Activate buff immediately
    player.sandwichTimer = 600; // 10 seconds
    
    // BIG activation animation
    effects.push(new Effect(
        player.x + player.w/2,
        player.y + player.h/2,
        80,
        'rgba(251, 191, 36, 0.9)',
        'explosion'
    ));
    
    // Floating sandwich particles
    for (let i = 0; i < 8; i++) {
        setTimeout(() => {
            effects.push({
                x: player.x + player.w/2,
                y: player.y + player.h/2,
                vx: (Math.random() - 0.5) * 8,
                vy: -Math.random() * 6 - 2,
                life: 100,
                lifeMax: 100,
                size: 20,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.3,
                type: 'sandwich_particle',
                update: function() {
                    this.life--;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.2; // Gravity
                    this.rotation += this.rotationSpeed;
                },
                draw: function() {
                    if (this.life <= 0) return;
                    const alpha = this.life / this.lifeMax;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.globalAlpha = alpha;
                    ctx.font = '20px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('ü•™', 0, 0);
                    ctx.globalAlpha = 1;
                    ctx.restore();
                }
            });
        }, i * 50);
    }
    
    floatingTexts.push(new FloatingText(
        player.x,
        player.y - 40,
        'ü•™ POWER UP!',
        '#fbbf24',
        18
    ));
}
     },
    {
        id: 'mega_turret',
        name: 'Mega Turret',
        icon: 'üî´',
        description: 'Spawn a powerful Mega Turret the next time you dash',
        type: 'utility',
        maxStack: 1,
        inRotation: true,
        effect: (player, stacks) => {
            player.upgrades.megaTurret = (player.upgrades.megaTurret || 0) + 1;
        }
    },
{
    id: 'piercing_shots',
    name: 'Armor Piercer',
    icon: 'üéØ',
    description: 'Pierce through enemies, dealing 50% less damage per hit',
    type: 'utility',
    maxStack: 3,
    inRotation: false,
    effect: (player, stacks) => {
        player.upgrades.piercingShots = (player.upgrades.piercingShots || 0) + 1;
    }
},
];
            // =====================================================

            // --- UI Elements ---
const screens = {
    menu: document.getElementById('mainMenuScreen'),
    eventPass: document.getElementById('eventPassScreen'),
    stats: document.getElementById('statsScreen'),
    shop: document.getElementById('shopScreen'),
    settings: document.getElementById('settingsScreen'),
    perks: document.getElementById('perksScreen'),
    gameMode: document.getElementById('gameModeScreen'),
    hero: document.getElementById('heroSelectScreen'),
    game: document.getElementById('gameScreen'),
    gameOver: document.getElementById('gameOverScreen'),
    more: document.getElementById('moreScreen')
};
            const gameTitle = document.getElementById('gameTitle');
            const gameUI = document.getElementById('gameUI');
            const coinDisplayMenu = document.getElementById('coinDisplayMenu');

            const ui = {
                menuCoins: document.getElementById('menuCoins'),
                gameCoins: document.getElementById('gameCoins'),
                dashInd: document.getElementById('dashIndicator'),
                doubleDashInd: document.getElementById('doubleDashIndicator'), // New UI for double dash
                turretHud: document.getElementById('turretHud'),
                hudTurretCount: document.getElementById('hudTurretCount'),
                bombHud: document.getElementById('bombHud'),
hudBombCount: document.getElementById('hudBombCount'),
                kills: document.getElementById('kills'),
                wave: document.getElementById('waveDisplay'),
                waveTimer: document.getElementById('waveTimer'),
                level: document.getElementById('levelDisplay'),
                xpBar: document.getElementById('xpBar'),
                hp: document.getElementById('hpDisplay'),
                waveMsg: document.getElementById('waveMsg'),
                waveMsgNum: document.getElementById('waveMsgNum'),
                levelUpMsg: document.getElementById('levelUpMsg'),
                upgradeText: document.getElementById('upgradeText'),
                // Shop UI
                lvlHealth: document.getElementById('lvlHealth'),
                costHealth: document.getElementById('costHealth'),
                btnHealth: document.getElementById('buyHealth'),
                lvlMagnet: document.getElementById('lvlMagnet'),
                costMagnet: document.getElementById('costMagnet'),
                btnMagnet: document.getElementById('buyMagnet'),
                invTurret: document.getElementById('invTurret'),
                btnTurret: document.getElementById('buyTurret'),
                txtTurretCost: document.getElementById('txtTurretCost'),
                invBomb: document.getElementById('invBomb'),
                btnBomb: document.getElementById('buyBomb'),
                txtBombCost: document.getElementById('txtBombCost'),
                statusSkin: document.getElementById('statusSkin'),
                btnSkin: document.getElementById('buySkin'),
                // Stats UI
                statBestWave: document.getElementById('statBestWave'),
                statTotalKills: document.getElementById('statTotalKills'),
                statTotalDeaths: document.getElementById('statTotalDeaths'),
                statBestLevel: document.getElementById('statBestLevel'),
                finalWave: document.getElementById('finalWave'),
                finalKills: document.getElementById('finalKills'),
                finalCoins: document.getElementById('finalCoins')
            };

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // --- SAVE DATA SYSTEM ---
let saveData = {
    coins: 0,
    traderTokens: 0,
    performanceMode: false,
lastTraderRefresh: Date.now(),
traderOffers: [],
purchasedUniqueItems: [],
    keys: 0,
    stats: {
        kills: 0,
        deaths: 0,
        bestWave: 1,
        bestLevel: 1,
       heroKills: {
    knight: 0,
    mage: 0,
    archer: 0,
    ninja: 0,
    tempest: 0,
    zap: 0,
    unit7: 0,
    mino: 0
}
    },
    upgrades: {
    health: 0, 
    magnet: 0,
    goldSkin: false,
    obsidianSkin: false
},
    inventory: {
        turrets: 0,
        bombs: 0,
loveBursts: 0,
burnWaves: 0
    },
    redeemedCodes: [],
    perks: {
    knightBladestorm: false,
    archerRicochet: false,
    mageMeteor: false
},
    pac: {
        coins: 0,
        rank: 'rookie',
        trailColor: '#9ca3af'
    },
    // NEW: Christmas cosmetics
    cosmetics: {
    crown: { owned: false, equipped: false },
    cupidBow: { owned: false, equipped: false },
    christmasTree: { owned: false, equipped: false },
    santaHat: { owned: false, equipped: false },
    elfHat: { owned: false, equipped: false },
    antlers: { owned: false, equipped: false },
    carrotNose: { owned: false, equipped: false },
    halo: { owned: false, equipped: false },
    astronaut: { owned: false, equipped: false },
    partyHat: { owned: false, equipped: false },
    topHat: { owned: false, equipped: false },
    sunglasses: { owned: false, equipped: false },
    monocle: { owned: false, equipped: false },
    mustache: { owned: false, equipped: false },
heartCrown: { owned: false, equipped: false },
redLantern: { owned: false, equipped: false },
loveRibbon: { owned: false, equipped: false },
luckyEnvelope: { owned: false, equipped: false },
heartEyes: { owned: false, equipped: false },
dragonMask: { owned: false, equipped: false },
giftBox: { owned: false, equipped: false },
fortuneCoin: { owned: false, equipped: false }
},
eventPass: {
    active: false,
    type: null, // 'valentine' or 'lunar'
    roses: 0,
    fireworks: 0,
    level: 0,
    rewards: [],
    claimed: [] // Track which levels have been claimed
}
};
            function loadData() {
                const saved = localStorage.getItem(GAME_CONFIG.STORAGE_KEY);
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        saveData = { ...saveData, ...parsed }; 
                        if(parsed.stats) saveData.stats = { ...saveData.stats, ...parsed.stats };
                        if(parsed.upgrades) saveData.upgrades = { ...saveData.upgrades, ...parsed.upgrades };
                        if(parsed.inventory) saveData.inventory = { ...saveData.inventory, ...parsed.inventory };
                    if(parsed.perks) saveData.perks = { ...saveData.perks, ...parsed.perks };
                        if(parsed.pac) saveData.pac = { ...saveData.pac, ...parsed.pac };
                    } catch(e) { console.error("Save corrupt"); }
                }
                updateShopUI();
            }
            
            

            function saveDataToStorage() {
    try {
        // Deep clone to ensure no reference issues
        const dataToSave = JSON.parse(JSON.stringify(saveData));
        localStorage.setItem(GAME_CONFIG.STORAGE_KEY, JSON.stringify(dataToSave));
        updateShopUI();
        console.log('‚úÖ Game saved successfully');
    } catch (e) {
        console.error('‚ùå Failed to save game:', e);
    }
}

const PAC_RANKS = {
    rookie: { name: 'ROOKIE', threshold: 0, icon: 'üéñÔ∏è', trail: '#9ca3af', next: 'fighter', reward: null },
    fighter: { threshold: 800, icon: 'ü•ä', trail: '#ef4444', next: 'challenger', reward: { coins: 350, turrets: 2, bombs: 1 } },
    challenger: { threshold: 2500, icon: '‚öîÔ∏è', trail: '#3b82f6', next: 'elite', reward: { coins: 800, turrets: 3, bombs: 2 } },
    elite: { threshold: 6000, icon: 'üëë', trail: '#a855f7', next: 'legend', reward: { coins: 1000, turrets: 5, bombs: 3 } },
    legend: { threshold: 10000, icon: 'üèÜ', trail: '#fbbf24', next: null, reward: { coins: 3000, turrets: 10, bombs: 8 } }
};

function calculatePACCoins(waves, kills, timeAlive) {
    // No PAC rewards for dying on wave 1
    if (waves <= 1) {
        return 0;
    }
    
    // Even more reduced rewards
    const waveScore = (waves - 1) * 10;  // Further reduced from 15 to 10
    const killScore = Math.floor(kills * 0.3);  // Further reduced from 0.5 to 0.3
    const timeScore = Math.floor(timeAlive / 150) * 2;  // Further reduced
    
    let multiplier = 1.0;
    if (waves >= 25) multiplier += 0.3;  // Harder to get bonuses
    if (kills >= 500) multiplier += 0.2;
    
    const total = Math.floor((waveScore + killScore + timeScore) * multiplier);
    return Math.max(total, 0);  // Can return 0 now
}

function updatePACRank(earnedPAC) {
    const oldRank = saveData.pac.rank;
    saveData.pac.coins += earnedPAC;
    
    let newRank = 'rookie';
    for (const [rank, data] of Object.entries(PAC_RANKS)) {
        if (saveData.pac.coins >= data.threshold) {
            newRank = rank;
        }
    }
   if (newRank !== oldRank) {
    // Give rank-up rewards!
        const reward = PAC_RANKS[newRank].reward;
        if (reward) {
            if (reward.coins) {
                saveData.coins += reward.coins;
                floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2 + 40, `+${reward.coins} COINS!`, '#fbbf24', 16));
            }
            if (reward.turrets) {
                saveData.inventory.turrets += reward.turrets;
                floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2 + 60, `+${reward.turrets} TURRETS!`, '#00ffff', 14));
            }
            if (reward.bombs) {
                saveData.inventory.bombs += reward.bombs;
                floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2 + 80, `+${reward.bombs} BOMBS!`, '#ff6600', 14));
            }
        }
        saveData.pac.rank = newRank;
        saveData.pac.trailColor = PAC_RANKS[newRank].trail;
        
        // Auto-unlock heroes at appropriate ranks
        if (newRank === 'elite' && !saveData.unit7Unlocked) {
            saveData.unit7Unlocked = true;
            showUnlockNotificationRank('ü§ñ UNIT-7 UNLOCKED!');
        }
        if (newRank === 'legend' && !saveData.zapUnlocked) {
            saveData.zapUnlocked = true;
            showUnlockNotificationRank('‚ö° ZAP UNLOCKED!');
        }
        
        showRankUpNotification(newRank);
        checkHeroUnlocks(); // ‚úÖ ADD THIS LINE - Immediately update hero cards
        updateHeroCards();  // ‚úÖ ADD THIS LINE - Refresh hero select screen
    }
    
    updatePACUI();
    saveDataToStorage();
}

function showRankUpNotification(newRank) {
    const rankData = PAC_RANKS[newRank];
    const msg = document.getElementById('pacRankUpMsg');
    document.getElementById('pacRankUpIcon').textContent = rankData.icon;
    document.getElementById('pacRankUpText').textContent = newRank.toUpperCase();
    
    msg.classList.remove('hidden');
    setTimeout(() => msg.classList.add('hidden'), 4000);
}

function showUnlockNotificationRank(text) {
    floatingTexts.push(new FloatingText(canvas.width/2 - 100, canvas.height/2 - 50, text, '#fbbf24', 24));
}

function updatePACUI() {
    const rank = saveData.pac.rank;
    const rankData = PAC_RANKS[rank];
    const coins = saveData.pac.coins;
    
    document.getElementById('pacRankText').textContent = rank.toUpperCase();
    
    const pacCoinsDisplay = document.getElementById('pacCoinsDisplay');
    const pacCurrentRank = document.getElementById('pacCurrentRank');
    const pacCurrentRankIcon = document.getElementById('pacCurrentRankIcon');
    
    if (pacCoinsDisplay) pacCoinsDisplay.textContent = coins;
    if (pacCurrentRank) pacCurrentRank.textContent = rank.toUpperCase();
    if (pacCurrentRankIcon) pacCurrentRankIcon.textContent = rankData.icon;
    
    if (rankData.next) {
        const nextRankData = PAC_RANKS[rankData.next];
        const progress = coins - rankData.threshold;
        const required = nextRankData.threshold - rankData.threshold;
        const percent = Math.min(100, (progress / required) * 100);
        
        const progressBar = document.getElementById('pacProgressBar');
        const progressPercent = document.getElementById('pacProgressPercent');
        const progressLabel = document.getElementById('pacProgressLabel');
        const progressText = document.getElementById('pacProgressText');
        
        if (progressBar) progressBar.style.width = `${percent}%`;
        if (progressPercent) progressPercent.textContent = `${Math.floor(percent)}%`;
        if (progressLabel) progressLabel.textContent = `Next: ${rankData.next.toUpperCase()}`;
        if (progressText) progressText.textContent = `${coins} / ${nextRankData.threshold} PAC`;
    } else {
        const progressBar = document.getElementById('pacProgressBar');
        const progressPercent = document.getElementById('pacProgressPercent');
        const progressLabel = document.getElementById('pacProgressLabel');
        const progressText = document.getElementById('pacProgressText');
        
        if (progressBar) progressBar.style.width = '100%';
        if (progressPercent) progressPercent.textContent = 'MAX';
        if (progressLabel) progressLabel.textContent = 'MAX RANK';
        if (progressText) progressText.textContent = 'LEGEND STATUS';
    }
    
    for (const [rankName, data] of Object.entries(PAC_RANKS)) {
        const card = document.getElementById(`rank-${rankName}`);
        if (card) {
            if (coins >= data.threshold) {
                card.classList.remove('opacity-50');
                card.style.borderColor = rankName === rank ? '#a855f7' : '#4b5563';
            }
        }
    }
    
    const benefits = {
        rookie: ['üå´Ô∏è Gray Mist Trail', 'üìä Performance Tracking'],
        fighter: ['üî• Red Flame Trail', 'üí™ +5% Coin Bonus (Coming Soon)'],
        challenger: ['‚ùÑÔ∏è Blue Ice Trail', '‚ö° +10% XP Bonus (Coming Soon)'],
        elite: ['üëë Purple Royal Trail', 'üíé Exclusive Cosmetics (Coming Soon)'],
        legend: ['‚ú® Golden Glory Trail', 'üèÜ Ultimate Prestige']
    };
    
    const pacBenefits = document.getElementById('pacBenefits');
    if (pacBenefits) {
        pacBenefits.innerHTML = benefits[rank].map(b => `<p>${b}</p>`).join('');
    }
    
}


            function updateShopUI() {
                ui.menuCoins.textContent = saveData.coins;
                // Update inventory counts
if (document.getElementById('invLoveBurst')) {
    document.getElementById('invLoveBurst').textContent = saveData.inventory.loveBursts || 0;
}
if (document.getElementById('invBurnWave')) {
    document.getElementById('invBurnWave').textContent = saveData.inventory.burnWaves || 0;
}
                // ‚úÖ Show/hide event items based on active event
    const loveBurstCard = document.getElementById('loveBurstCard');
    const burnWaveCard = document.getElementById('burnWaveCard');
    
    if (saveData.eventPass && saveData.eventPass.active) {
        if (saveData.eventPass.type === 'valentine' && loveBurstCard) {
            loveBurstCard.style.display = 'block';
            document.getElementById('buyLoveBurst').disabled = (saveData.eventPass.roses || 0) < 10;
        }
        if (saveData.eventPass.type === 'lunar' && burnWaveCard) {
            burnWaveCard.style.display = 'block';
            document.getElementById('buyBurnWave').disabled = (saveData.eventPass.fireworks || 0) < 10;
        }
    }
                // UPDATED: Turret cost
                ui.txtTurretCost.textContent = GAME_CONFIG.TURRET.COST;
                
                // Health Upgrade
                const healthCost = GAME_CONFIG.SHOP.HEALTH_BASE * (saveData.upgrades.health + 1);
                ui.lvlHealth.textContent = saveData.upgrades.health + "/5";
                ui.costHealth.textContent = healthCost;
                ui.btnHealth.disabled = (saveData.coins < healthCost) || (saveData.upgrades.health >= 5);
                if(saveData.upgrades.health >= 5) ui.btnHealth.textContent = "MAXED";

                // Magnet Upgrade
                const magnetCost = GAME_CONFIG.SHOP.MAGNET_BASE * (saveData.upgrades.magnet + 1);
                ui.lvlMagnet.textContent = saveData.upgrades.magnet + "/5";
                ui.costMagnet.textContent = magnetCost;
                ui.btnMagnet.disabled = (saveData.coins < magnetCost) || (saveData.upgrades.magnet >= 5);
                if(saveData.upgrades.magnet >= 5) ui.btnMagnet.textContent = "MAXED";

                // Turret
                ui.invTurret.textContent = saveData.inventory.turrets;
                ui.btnTurret.disabled = saveData.coins < GAME_CONFIG.TURRET.COST;

                // Bomb
                ui.invBomb.textContent = saveData.inventory.bombs;
                ui.txtBombCost.textContent = GAME_CONFIG.BOMB.COST;
                ui.btnBomb.disabled = saveData.coins < GAME_CONFIG.BOMB.COST;

// Golden Skin
const skinEquipped = saveData.upgrades.goldSkin && (saveData.upgrades.goldSkinEquipped !== false);

if (saveData.upgrades.goldSkin) {
    if (skinEquipped) {
        document.getElementById('statusSkin').textContent = "Equipped ‚úì";
        document.getElementById('statusSkin').className = "text-[10px] text-green-400 mb-3";
        document.getElementById('buySkin').classList.add('hidden');
        document.getElementById('unequipSkin').classList.remove('hidden');
    } else {
        document.getElementById('statusSkin').textContent = "Owned";
        document.getElementById('statusSkin').className = "text-[10px] text-blue-400 mb-3";
        document.getElementById('buySkin').textContent = "EQUIP";
        document.getElementById('buySkin').disabled = false;
        document.getElementById('buySkin').className = "game-btn px-4 py-3 text-sm w-full bg-green-500 border-green-700 text-white font-bold";
        document.getElementById('buySkin').classList.remove('hidden');
        document.getElementById('unequipSkin').classList.add('hidden');
    }
} else {
    document.getElementById('statusSkin').textContent = "Locked";
    document.getElementById('statusSkin').className = "text-[10px] text-blue-300 mb-3";
    document.getElementById('buySkin').disabled = saveData.coins < GAME_CONFIG.SHOP.SKIN;
    document.getElementById('buySkin').classList.remove('hidden');
    document.getElementById('unequipSkin').classList.add('hidden');
}

// Obsidian Skin
const obsidianEquipped = saveData.upgrades.obsidianSkin && (saveData.upgrades.obsidianSkinEquipped !== false);

if (saveData.upgrades.obsidianSkin) {
    if (obsidianEquipped) {
        document.getElementById('statusObsidianSkin').textContent = "Equipped ‚úì";
        document.getElementById('statusObsidianSkin').className = "text-[10px] text-green-400 mb-3";
        document.getElementById('buyObsidianSkin').classList.add('hidden');
        document.getElementById('unequipObsidianSkin').classList.remove('hidden');
    } else {
        document.getElementById('statusObsidianSkin').textContent = "Owned";
        document.getElementById('statusObsidianSkin').className = "text-[10px] text-blue-400 mb-3";
        document.getElementById('buyObsidianSkin').textContent = "EQUIP";
        document.getElementById('buyObsidianSkin').disabled = false;
        document.getElementById('buyObsidianSkin').className = "game-btn px-4 py-3 text-sm w-full bg-green-500 border-green-700 text-white font-bold";
        document.getElementById('buyObsidianSkin').classList.remove('hidden');
        document.getElementById('unequipObsidianSkin').classList.add('hidden');
    }
} else {
    document.getElementById('statusObsidianSkin').textContent = "Locked";
    document.getElementById('statusObsidianSkin').className = "text-[10px] text-blue-300 mb-3";
    document.getElementById('buyObsidianSkin').disabled = saveData.coins < 1500;
    document.getElementById('buyObsidianSkin').classList.remove('hidden');
    document.getElementById('unequipObsidianSkin').classList.add('hidden');
}


            }

            // --- GAME STATE ---
            let player;
            let keys = {};
            let enemies = [];
            let projectiles = [];
            let effects = []; 
            let drops = []; 
            let turrets = [];
            let bombs = [];
            let floatingTexts = []; 
            let mousePos = { x: 0, y: 0 };
            
            let kills = 0;
            let sessionCoins = 0;
            let sessionTurrets = 0;
            let sessionBombs = 0;
            let frameCount = 0;
            let isGameOver;
            isPracticeMode = false;
            let isTeamMode = false;
let teamHeroes = [];
let currentTeamIndex = 0;
let teamRespawning = false;
let invincibilityTimer = 0;
trainingDummies = [];
showScreen('menu');
            let isPaused = false;
            let gameLoopId;
            let currentMap = null;
let mapObjects = [];

            // --- MUSIC SYSTEM ---
let musicEnabled = true;
let backgroundMusic = null;
            
            let wave = 1;
            let waveTimer = GAME_CONFIG.WAVES.DURATION * 60;
            let enemySpawnTimer = 0;
            let difficultyMultiplier = 1;
            let bossActive = false;
            let currentBoss = null;
            let bossWaveCount = 0;

            // --- CLASSES ---

           class Turret {
                constructor(x, y, isMega = false) {
                    this.x = x;
                    this.y = y;
                    this.w = isMega ? 30 : 20;
                    this.h = isMega ? 30 : 20;
                    this.isMega = isMega;
                    this.life = GAME_CONFIG.TURRET.LIFETIME;
                    this.maxLife = GAME_CONFIG.TURRET.LIFETIME;
                    this.range = isMega ? 280 : GAME_CONFIG.TURRET.RANGE;
                    this.cooldown = 0;
                    this.angle = 0;
                    this.damage = isMega ? 3 : GAME_CONFIG.PROJECTILES.turret.damage;
                }
                update() {
                    this.life--;
                    this.cooldown--;

                    // Find nearest enemy
                    let nearest = null;
                    let minDis = this.range;

                    for(let e of enemies) {
                        const dist = Math.hypot((e.x+e.w/2)-this.x, (e.y+e.h/2)-this.y);
                        if(dist < minDis) {
                            minDis = dist;
                            nearest = e;
                        }
                    }

                    if(nearest) {
                        const dx = (nearest.x + nearest.w/2) - this.x;
                        const dy = (nearest.y + nearest.h/2) - this.y;
                        this.angle = Math.atan2(dy, dx);
                        
                        // Shoot
                        if(this.cooldown <= 0) {
                            projectiles.push(new Projectile(
                                this.x - GAME_CONFIG.PLAYER.BASE_SIZE/2, 
                                this.y - GAME_CONFIG.PLAYER.BASE_SIZE/2, 
                                this.angle, 
                                'turret', 
                                this.damage
                            )); 
                            this.cooldown = this.isMega ? 30 : GAME_CONFIG.TURRET.FIRE_RATE; // Mega shoots 3x faster
                        }
                    }
                }
               draw() {
                    // Base
                    if (this.isMega) {
                        // Mega Turret - Glowing cyan base
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = '#0088ff';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 18, 0, Math.PI*2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Inner glow
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
                        ctx.fill();
                    } else {
                        // Normal turret
                        ctx.fillStyle = '#555';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.stroke();
// Gun
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    if (this.isMega) {
                        ctx.fillStyle = '#00ffff';
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 10;
                        ctx.fillRect(0, -6, 24, 12);
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.fillStyle = '#999';
                        ctx.fillRect(0, -4, 16, 8);
                    }
                    ctx.restore();
                    // Bar
                    const width = 24;
                    const pct = this.life / this.maxLife;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - width/2, this.y - 20, width, 4);
                    ctx.fillStyle = '#fbbf24';
                    ctx.fillRect(this.x - width/2, this.y - 20, width * pct, 4);
                }
            }

            class FloatingText {
                constructor(x, y, text, color, size = 12) {
                    this.x = x + (Math.random() * 10 - 5);
                    this.y = y;
                    this.text = text;
                    this.color = color;
                    this.size = size;
                    this.life = 40;
                    this.velocity = 1.5;
                    this.alpha = 1;
                }
                update() {
                    this.y -= this.velocity;
                    this.velocity *= 0.9; 
                    this.life--;
                    if (this.life < 15) this.alpha -= 0.06;
                }
                draw() {
                    ctx.globalAlpha = Math.max(0, this.alpha);
                    ctx.font = `${this.size}px "Press Start 2P"`;
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.text, this.x, this.y);
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.globalAlpha = 1;
                }
            }

            class DropItem {
constructor(x, y, type, value) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.value = value;
    this.decayTimer = null;
    
    // Visual properties based on type
    if (type === 'goldcoin') {
        this.radius = 10;
        this.color = '#ffd700';
        this.glowColor = '#ffed4e';
    } else if (type === 'health') {
        this.radius = 8;
        this.color = '#ef4444';
        this.glowColor = '#fca5a5';
  } else if (type === 'rose') {
        this.radius = 8;
        this.color = '#ec4899';
        this.glowColor = '#f472b6';
    } else if (type === 'firework') {
        this.radius = 8;
        this.color = '#f59e0b';
        this.glowColor = '#fbbf24';
} else if (this.type === 'bubble') {
        this.radius = 10;
        this.color = '#0ea5e9';
        this.glowColor = '#7dd3fc';
    } else if (type === 'coin') {
        this.radius = 6;
        this.color = '#fbbf24';
    } else {
        this.radius = 5;
        this.color = value > 10 ? '#ffd700' : '#00f2fe';
    }
    
    this.magnetized = false;
    this.bounceOffset = Math.random() * Math.PI * 2;
}
                update() {
    // Decay timer for special drops
    if (this.decayTimer !== null) {
        this.decayTimer--;
        if (this.decayTimer <= 0) {
            return true; // Signal for removal
        }
    }
    
    const magnetBonus = player.upgrades.pickupMagnet * 30;
const magnetRange = GAME_CONFIG.PLAYER.BASE_MAGNET + (saveData.upgrades.magnet * GAME_CONFIG.PLAYER.MAGNET_PER_UPGRADE) + magnetBonus;
    const floatY = Math.sin((Date.now() / 200) + this.bounceOffset) * 2;
    const dx = (player.x + player.w/2) - this.x;
    const dy = (player.y + player.h/2) - (this.y + floatY);
    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < magnetRange) this.magnetized = true;
                    
                    if (this.magnetized) {
                        const speed = this.type === 'coin' ? 14 : 12;
                        this.x += (dx / dist) * speed;
                        this.y += (dy / dist) * speed;
                        
                     if (dist < 20) {
    if(this.type === 'coin' || this.type === 'goldcoin') {
        sessionCoins += this.value;
        ui.gameCoins.textContent = sessionCoins;
        if (this.type === 'goldcoin') {
            floatingTexts.push(new FloatingText(this.x, this.y, `+${this.value}G`, '#ffd700', 16));
        }
   } else if (this.type === 'rose') {
        addEventCurrency(this.value);
        floatingTexts.push(new FloatingText(this.x, this.y, '+1 üåπ', '#ec4899', 14));
    } else if (this.type === 'firework') {
        addEventCurrency(this.value);
        floatingTexts.push(new FloatingText(this.x, this.y, '+1 üéÜ', '#f59e0b', 14));
        } else if (this.type === 'bubble') {
        if (player && player.type === 'mino') {
            player.waterTank = Math.min(player.waterTank + 5, player.maxWater); // +5 water per bubble
            player.updateUI();
            floatingTexts.push(new FloatingText(this.x, this.y, '+5 üíß', '#0ea5e9', 14));
        }
    
    } else if (this.type === 'health') {
        player.hp = Math.min(player.maxHp, player.hp + this.value);
        player.updateUI();
        floatingTexts.push(new FloatingText(this.x, this.y, `+${this.value} HP`, '#22c55e', 14));
        effects.push(new Effect(this.x, this.y, 40, 'rgba(34, 197, 94, A)', 'explosion'));
    } else {
        player.gainXp(this.value);
    }
    return true;
}
                    }
                    return false;
                }
                draw() {
    const floatY = this.magnetized ? 0 : Math.sin((Date.now() / 200) + this.bounceOffset) * 2;
    
    // Glow effect for special drops
    if (this.glowColor) {
        ctx.shadowColor = this.glowColor;
        ctx.shadowBlur = 15;
    }
    
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.arc(this.x, this.y + floatY, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // Icons for different types
if(this.type === 'coin' || this.type === 'goldcoin') {
    ctx.fillStyle = '#fff';
    ctx.font = this.type === 'goldcoin' ? '10px monospace' : '8px monospace';
    ctx.fillText('$', this.x - (this.type === 'goldcoin' ? 3 : 2), this.y + floatY + 3);
} else if (this.type === 'health') {
    ctx.fillStyle = '#fff';
    ctx.font = '10px monospace';
    ctx.fillText('+', this.x - 3, this.y + floatY + 4);
} else if (this.type === 'rose') {
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.fillText('üåπ', this.x - 6, this.y + floatY + 4);
} else if (this.type === 'firework') {
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.fillText('üéÜ', this.x - 6, this.y + floatY + 4);
}
    
    // Decay warning (flashing)
    if (this.decayTimer !== null && this.decayTimer < 60) {
        if (Math.floor(this.decayTimer / 10) % 2 === 0) {
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
    }
}
            }

            class Player {
                constructor(x, y, type) {
                    this.x = x;
                    this.y = y;
                    this.w = GAME_CONFIG.PLAYER.BASE_SIZE;
                    this.h = GAME_CONFIG.PLAYER.BASE_SIZE;
                    this.type = type;
                    this.angle = 0;
                    
                    const stats = GAME_CONFIG.CLASSES[type];
                    const bonusHealth = saveData.upgrades.health * GAME_CONFIG.PLAYER.HP_PER_UPGRADE;
                    
                    this.level = 1;
                    this.xp = 0;
                    this.maxXp = 10;
                    this.maxHp = GAME_CONFIG.PLAYER.BASE_HP + (stats.hp_bonus || 0) + bonusHealth;
                    this.hp = this.maxHp;
                    this.speed = GAME_CONFIG.PLAYER.BASE_SPEED * (stats.speed_mult || 1);
                    
                    this.damageMult = stats.damage_mult;
                    this.fireRateMult = stats.fire_rate_mult;
                    this.weaponCooldown = 0;
                    this.slashTimer = 0;

                    this.dashCooldown = 0;
                    this.isDashing = false;
                    this.dashTime = 0;
                    this.canDoubleDash = stats.canDoubleDash || false; // Ninja specific
                    this.doubleDashReady = this.canDoubleDash;         // Ninja specific
                    
                   this.isGold = saveData.upgrades.goldSkin && (saveData.upgrades.goldSkinEquipped !== false);
this.isObsidian = saveData.upgrades.obsidianSkin && (saveData.upgrades.obsidianSkinEquipped !== false);

if (this.isObsidian) {
    this.color = '#3b0764'; // Deep purple-black
} else if (this.isGold) {
    this.color = '#fbbf24';
} else {
    this.color = stats.color;
}

// Temporary run upgrades

this.upgrades = {
    fireRing: 0,
    lightningStorm: 0,
    speedBoostTimer: 0,
    attackSpeed: 0,
    poisonTrail: 0,
    shadowBlades: 0,
    explosiveShots: 0,
    splitShot: 0,
    piercingShots: 0,
    damageBoost: 0,
    regenAura: 0,
    thorns: 0,
    iceBarrier: 0,
    autoHeal: 0,
    maxHealth: 0,
    dodgeChance: 0,
    orbitalDrones: 0,
    extraDashes: 0,
    pickupMagnet: 0,
    xpBoost: 0,
    coinMagnet: 0,
    moveSpeed: 0,
    lifesteal: 0,
    pocketSandwich: 0
};
this.shotCounter = 0;
this.healTimer = 0;
this.lightningStormTimer = 0;
this.shadowBladeAngle = 0;
this.regenTimer = 0;

              // Class Specifics
if (type === 'knight') {
    this.swordLength = stats.sword_length;
    this.swordWidth = stats.sword_width;
    this.isSlashing = false;
    // Blade Storm Ability
    this.bladestormCooldown = 0;
    this.bladestormActive = false;
    this.bladestormDuration = 0;
    // SHIELD SYSTEM
    this.shieldMode = false; // false = sword, true = shield
    this.shieldWaveCooldown = 0;
    this.shieldWaveActive = false; // NEW: Track if wave is active
}
// Archer specific
if (type === 'archer') {
    this.ricochetCooldown = 0;
    this.ricochetActive = false;
    this.ricochetShotReady = false; // New flag for single-shot mode
}
// Mage specific
if (type === 'mage') {
    this.meteorCooldown = 0;
    this.meteorActive = false;
    this.meteorTargetX = 0;
    this.meteorTargetY = 0;
}
// Tempest specific
if (type === 'tempest') {
    this.furyKills = 0;
    this.furyBarMax = stats.furyBarMax;
    this.furyWaveCooldown = 0;
}
// Zap specific
if (type === 'zap') {
    this.overloadCounter = 0; // Tracks shots until Overload Surge (every 3rd)
}
// Unit-7 specific
if (type === 'unit7') {
    this.currentMode = 'laser';
    this.laserCooldown = 0;
    this.microCooldown = 0;
    this.microAmmo = stats.microMaxAmmo;
    this.microMaxAmmo = stats.microMaxAmmo;
}
// Dragon specific
if (type === 'dragon') {
    this.rageCharge = 0;
    this.rageMax = stats.rageMax;
}
if (type === 'necromancer') {
    this.soulCharge = 0;
    this.soulChargeMax = 10;  // 10 kills to summon
    this.summonCooldown = 0;
}

// Mino specific
if (type === 'mino') {
    this.waterTank = 100; // Max water capacity
    this.maxWater = 100;
    this.waterRegenRate = 0.15; // Slow regen when not shooting
    this.waterRegenDelay = 0; // Counter for regen delay
    this.isSpraying = false;
    this.shootContinuously = false; // NEW: Track if actively shooting
}
if (type === 'volt') {
    this.dashCharge = 0;
    this.dashChargeMax = 100;
    this.rodCooldown = 0;
}
                }
 

               gainXp(amount) {
    const xpBonus = 1 + (this.upgrades.xpBoost * 0.1);
    this.xp += Math.floor(amount * xpBonus);
    if (this.xp >= this.maxXp) this.levelUp();
    this.updateUI();
}

levelUp() {
    this.level++;
    this.xp = this.xp - this.maxXp;
    this.maxXp = Math.floor(this.maxXp * 1.4); 
    
    // Heal 20% on level up
    this.hp = Math.min(this.hp + (this.maxHp * 0.2), this.maxHp);
    
    // LEVEL 6 CAP: Only show upgrades if level 6 or below
    if (this.level <= 6) {
        showUpgradeChoices();
    } else {
        // Just show level up message, no upgrades
        const levelUpMsg = document.getElementById('levelUpMsg');
        const upgradeText = document.getElementById('upgradeText');
        levelUpMsg.classList.remove('hidden');
        upgradeText.textContent = `Max Level! +HP Restored!`;
        setTimeout(() => levelUpMsg.classList.add('hidden'), 2000);
    }
}
                
               updateUI() {
                    const pct = Math.min(100, (this.xp / this.maxXp) * 100);
                    ui.xpBar.style.width = `${pct}%`;
                    ui.level.textContent = this.level;
                    
ui.hp.textContent = `${Math.floor(this.hp)}/${this.maxHp}`;
                    
// Hide both dash indicators first
ui.dashInd.classList.add('hidden');
ui.doubleDashInd.classList.add('hidden');

// NINJA DOUBLE DASH SYSTEM - FIXED
if (this.canDoubleDash) {
    // Initialize charges and cooldown if needed
    if (this.dashCharges === undefined) {
        this.dashCharges = 2;
        this.dashRechargeTimer = 0;
    }
    
    // Only recharge when cooldown is complete AND we have less than 2 charges
    if (this.dashCooldown === 0 && this.dashCharges < 2) {
        this.dashRechargeTimer++;
        
        // Recharge 1 dash every 3 seconds (180 frames)
        if (this.dashRechargeTimer >= 180) {
            this.dashCharges++;
            this.dashRechargeTimer = 0;
        }
    }
    
    // Show indicator based on charges
    if (this.dashCharges === 2) {
        ui.doubleDashInd.textContent = '‚ö°‚ö° DOUBLE DASH';
        ui.doubleDashInd.classList.remove('hidden');
    } else if (this.dashCharges === 1) {
        ui.dashInd.textContent = '‚ö° DASH READY';
        ui.dashInd.classList.remove('hidden');
    }
    // If 0 charges, show recharge timer
    else if (this.dashCharges === 0 && this.dashRechargeTimer > 0) {
        const secondsLeft = Math.ceil((180 - this.dashRechargeTimer) / 60);
        ui.dashInd.textContent = `‚è≥ ${secondsLeft}s`;
        ui.dashInd.classList.remove('hidden');
    }
}
// NORMAL CLASSES: Standard single dash
else {
    // Simple: If cooldown is 0 and not currently dashing, show ready
    if (this.dashCooldown === 0 && !this.isDashing) {
        ui.dashInd.textContent = '‚ö° DASH READY';
        ui.dashInd.classList.remove('hidden');
    }
}
                    // Tempest Fury Bar
    const furyContainer = document.getElementById('furyBarContainer');
    const furyFill = document.getElementById('furyBarFill');
    if (this.type === 'tempest') {
        furyContainer.classList.remove('hidden');
        const furyPct = (this.furyKills / this.furyBarMax) * 100;
        furyFill.style.width = `${furyPct}%`;
    } else {
        furyContainer.classList.add('hidden');
    }
// Necromancer Soul Bar
const soulContainer = document.getElementById('soulBarContainer');
if (this.type === 'necromancer') {
    if (!soulContainer) {
        const container = document.createElement('div');
        container.id = 'soulBarContainer';
        container.className = 'mt-2 w-32';
        container.innerHTML = `
            <div class="text-[10px] text-purple-300 text-center mb-1">SOULS</div>
            <div class="w-full h-3 bg-gray-800 border-2 border-purple-400 rounded overflow-hidden">
                <div id="soulBarFill" class="h-full bg-gradient-to-r from-purple-600 to-violet-500" style="width: 0%"></div>
            </div>
            <div id="necroSummonText" class="hidden text-[10px] text-yellow-300 text-center mt-1 font-bold animate-pulse">C TO SUMMON!</div>
        `;
        const furyContainer = document.getElementById('furyBarContainer');
        if (furyContainer && furyContainer.parentElement) {
            furyContainer.parentElement.appendChild(container);
        } else {
            document.getElementById('dashIndicator').parentElement.appendChild(container);
        }
} else {
        soulContainer.classList.remove('hidden');
        const soulPct = (this.soulCharge / this.soulChargeMax) * 100;
        document.getElementById('soulBarFill').style.width = `${soulPct}%`;
        
        // Show "C to Summon!" when full
        const summonText = document.getElementById('necroSummonText');
        if (summonText) {
            if (this.soulCharge >= this.soulChargeMax) {
                summonText.classList.remove('hidden');
            } else {
                summonText.classList.add('hidden');
            }
        }
    }
} else {
    if (soulContainer) soulContainer.classList.add('hidden');
}
    // Mino Water Tank Bar
const waterContainer = document.getElementById('waterBarContainer');
const waterFill = document.getElementById('waterBarFill');
if (this.type === 'mino') {
    if (!waterContainer) {
        const container = document.createElement('div');
        container.id = 'waterBarContainer';
        container.className = 'mt-2 w-32';
        container.innerHTML = `
            <div class="text-[10px] text-cyan-300 text-center mb-1">WATER TANK</div>
            <div class="w-full h-3 bg-gray-800 border-2 border-cyan-400 rounded overflow-hidden">
                <div id="waterBarFill" class="h-full bg-gradient-to-r from-cyan-400 to-blue-500" style="width: 100%"></div>
            </div>
        `;
        document.getElementById('dashIndicator').parentElement.appendChild(container);
    } else {
        waterContainer.classList.remove('hidden');
        const waterPct = (this.waterTank / this.maxWater) * 100;
        document.getElementById('waterBarFill').style.width = `${waterPct}%`;
    }
} else {
    if (waterContainer) waterContainer.classList.add('hidden');
}
    // Dragon Rage Bar
const rageContainer = document.getElementById('rageBarContainer');
const rageFill = document.getElementById('rageBarFill');
if (this.type === 'dragon') {
    if (!rageContainer) {
        // Create rage bar if it doesn't exist
        const container = document.createElement('div');
        container.id = 'rageBarContainer';
        container.className = 'mt-2 w-32';
        container.innerHTML = `
            <div class="text-[10px] text-orange-300 text-center mb-1">RAGE</div>
            <div class="w-full h-3 bg-gray-800 border-2 border-orange-400 rounded overflow-hidden">
                <div id="rageBarFill" class="h-full bg-gradient-to-r from-orange-400 to-red-500" style="width: 0%"></div>
            </div>
            <div id="rageReleaseText" class="hidden text-[10px] text-yellow-300 text-center mt-1 font-bold animate-pulse">C TO RELEASE!</div>
        `;
        document.getElementById('dashIndicator').parentElement.appendChild(container);
    } else {
        rageContainer.classList.remove('hidden');
        const ragePct = (this.rageCharge / this.rageMax) * 100;
        document.getElementById('rageBarFill').style.width = `${ragePct}%`;
        
        // Show "C to Release!" when full
        const releaseText = document.getElementById('rageReleaseText');
        if (releaseText) {
            if (this.rageCharge >= this.rageMax) {
                releaseText.classList.remove('hidden');
            } else {
                releaseText.classList.add('hidden');
            }
        }
    }
} else {
    if (rageContainer) rageContainer.classList.add('hidden');
}
// Volt Dash Charge Bar
const voltChargeContainer = document.getElementById('voltChargeBarContainer');
const voltChargeFill = document.getElementById('voltChargeBarFill');
if (this.type === 'volt') {
    if (!voltChargeContainer) {
        const container = document.createElement('div');
        container.id = 'voltChargeBarContainer';
        container.className = 'mt-2 w-32';
        container.innerHTML = `
            <div class="text-[10px] text-yellow-300 text-center mb-1">DASH CHARGE</div>
            <div class="w-full h-3 bg-gray-800 border-2 border-yellow-400 rounded overflow-hidden">
                <div id="voltChargeBarFill" class="h-full bg-gradient-to-r from-yellow-400 to-yellow-600" style="width: 0%"></div>
            </div>
            <div id="voltDashText" class="hidden text-[10px] text-yellow-300 text-center mt-1 font-bold animate-pulse">C TO DASH!</div>
        `;
        document.getElementById('dashIndicator').parentElement.appendChild(container);
    } else {
        voltChargeContainer.classList.remove('hidden');
        const chargePct = (this.dashCharge / this.dashChargeMax) * 100;
        document.getElementById('voltChargeBarFill').style.width = `${chargePct}%`;
        
        const dashText = document.getElementById('voltDashText');
        if (dashText) {
            if (this.dashCharge >= this.dashChargeMax) {
                dashText.classList.remove('hidden');
            } else {
                dashText.classList.add('hidden');
            }
        }
    }
} else {
    if (voltChargeContainer) voltChargeContainer.classList.add('hidden');
}
// Volt Dash Charging
if (this.type === 'volt') {
    if (this.dashCharges < this.maxDashCharges && frameCount % 60 === 0) {
        this.dashCharges++;
        floatingTexts.push(new FloatingText(this.x, this.y, '+‚ö°', '#facc15', 10));
    }
}
                }
                
                

dash() {
    if (this.isDashing) return;
    // Mega Turret - spawn when dash is used
    if (this.upgrades.megaTurret > 0 && (!this.megaTurretCooldown || this.megaTurretCooldown <= 0)) {
        turrets.push(new Turret(this.x + this.w/2, this.y + this.h/2, true));
        floatingTexts.push(new FloatingText(this.x, this.y, 'MEGA TURRET!', '#00ffff', 16));
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 60, 'rgba(0, 255, 255, 0.8)', 'explosion'));
        this.megaTurretCooldown = 1800; // 30 seconds
    }
    
    let dashActivated = false;
    let moveX = 0;
    let moveY = 0;
    
    // Calculate movement direction FIRST
    if (keys['ArrowUp'] || keys['KeyW']) moveY = -1;
    if (keys['ArrowDown'] || keys['KeyS']) moveY = 1;
    if (keys['ArrowLeft'] || keys['KeyA']) moveX = -1;
    if (keys['ArrowRight'] || keys['KeyD']) moveX = 1;
    
    // If no input, use mouse direction
    if (moveX === 0 && moveY === 0) {
        moveX = Math.cos(this.angle);
        moveY = Math.sin(this.angle);
    } else {
        const mag = Math.sqrt(moveX*moveX + moveY*moveY);
        moveX /= mag;
        moveY /= mag;
    }

// NINJA SPECIAL: Two separate dashes with individual recharge
if (this.canDoubleDash) {
    if (this.dashCharges === undefined) this.dashCharges = 2;
    
    if (this.dashCharges > 0 && this.dashCooldown === 0) { // ‚úÖ FIX: Check cooldown
        this.dashCharges--;
        dashActivated = true;
        
        // Start global cooldown ONLY when dashing (prevents spam)
        this.dashCooldown = 90; // ‚úÖ FIX: 1 second spam prevention (was 30)
        this.dashRechargeTimer = 0; // Reset recharge timer
    }
}
    // NORMAL CLASSES: Standard single dash with cooldown
    else {
        if (this.dashCooldown === 0) {
            this.dashCooldown = GAME_CONFIG.PLAYER.DASH.COOLDOWN;
            dashActivated = true;
        }
    }

    if (dashActivated) {
        this.isDashing = true;
        this.dashTime = GAME_CONFIG.PLAYER.DASH.DURATION;
        this.dashVel = { x: moveX * GAME_CONFIG.PLAYER.DASH.SPEED, y: moveY * GAME_CONFIG.PLAYER.DASH.SPEED };
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 20, 'rgba(255,255,255,0.5)', 'explosion')); 
        
        // Immediately update UI
        this.updateUI();
    }
}
                
useBladestorm() {
    if (this.type !== 'knight') return;
    if (!saveData.perks.knightBladestorm) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'PERK LOCKED!', '#ff0000', 12));
        return;
    }
    
    if (this.bladestormCooldown > 0) {
        const secondsLeft = Math.ceil(this.bladestormCooldown / 60);
        floatingTexts.push(new FloatingText(this.x, this.y, `NOT READY! ${secondsLeft}s`, '#ff6600', 12));
        return;
    }
    
    // Activate Bladestorm!
    this.bladestormActive = true;
    this.bladestormDuration = 40; // ‚úÖ NERFED: Was 90, now 45 frames (1.5 seconds)
    this.bladestormCooldown = 720;
    floatingTexts.push(new FloatingText(this.x, this.y, 'BLADE STORM!', '#3b82f6', 18));
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 120, 'rgba(59, 130, 246, A)', 'explosion'));
}

useRicochet() {
    if (this.type !== 'archer') return;
    if (!saveData.perks.archerRicochet) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'PERK LOCKED!', '#ff0000', 12));
        return;
    }
    
    // ‚úÖ FIX: Check cooldown BEFORE showing message
    if (this.ricochetCooldown > 0) {
        const secondsLeft = Math.ceil(this.ricochetCooldown / 60);
        floatingTexts.push(new FloatingText(this.x, this.y, `NOT READY! ${secondsLeft}s`, '#ff6600', 12));
        return; // ‚úÖ STOP HERE - Don't activate ability
    }
    
// Activate Ricochet - Single shot mode!
this.ricochetShotReady = true;
floatingTexts.push(new FloatingText(this.x, this.y, 'RICOCHET READY!', '#16a34a', 18));
effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 80, 'rgba(22, 163, 74, A)', 'explosion'));
}
useMeteorShower(targetX, targetY) {
    if (this.type !== 'mage') return;
    if (!saveData.perks.mageMeteor) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'PERK LOCKED!', '#ff0000', 12));
        return;
    }
    
    if (this.meteorCooldown > 0) {
        const secondsLeft = Math.ceil(this.meteorCooldown / 60);
        floatingTexts.push(new FloatingText(this.x, this.y, `NOT READY! ${secondsLeft}s`, '#ff6600', 12));
        return;
    }
    
    // Activate Meteor Shower (longer cooldown)
    this.meteorCooldown = 2400; // 40 seconds (was 25)
    this.meteorTargetX = targetX;
    this.meteorTargetY = targetY;
    
    // Spawn 8 meteors over 2 seconds
    for (let i = 0; i < 8; i++) {
        setTimeout(() => {
            const offsetX = (Math.random() - 0.5) * 120;
            const offsetY = (Math.random() - 0.5) * 120;
            const meteorX = targetX + offsetX;
            const meteorY = targetY + offsetY;
            
            // COOLER Meteor falling effect
            effects.push({
                x: meteorX,
                y: -50,
                targetY: meteorY,
                life: 30,
                lifeMax: 30,
                type: 'meteor_falling',
                update: function() {
                    this.life--;
                    this.y += (this.targetY - this.y) * 0.3;
                },
                draw: function() {
                    if (this.life <= 0) return;
                    ctx.save();
                    // Meteor trail
                    const gradient = ctx.createLinearGradient(this.x, this.y - 40, this.x, this.y);
                    gradient.addColorStop(0, 'rgba(255, 69, 0, 0)');
                    gradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 69, 0, 1)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - 10, this.y - 40, 20, 40);
                    
                    // Meteor body
                    ctx.fillStyle = '#ff4500';
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 25;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright core
                    ctx.fillStyle = '#ffed4e';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(this.x - 3, this.y - 3, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });
            
            // Meteor impact effect (delayed)
            setTimeout(() => {
                effects.push(new Effect(meteorX, meteorY, 80, 'rgba(255, 69, 0, 0.8)', 'explosion'));
            }, 500);
            
            // Damage enemies in radius
            enemies.forEach(e => {
                const dist = Math.hypot((e.x + e.w/2) - meteorX, (e.y + e.h/2) - meteorY);
                if (dist < 80) {
                    hitEnemy(e, 5);
                    // Apply burn
                    if (!e.isBurning) {
                        e.isBurning = true;
                        e.burnTimer = 180; // 3 seconds
                        e.burnDamage = 1;
                    }
                    floatingTexts.push(new FloatingText(e.x, e.y, '‚òÑÔ∏è', '#ff4500', 14));
                }
            });
        }, i * 250); // Stagger meteors
    }
    
    floatingTexts.push(new FloatingText(targetX, targetY - 50, '‚òÑÔ∏è METEOR SHOWER!', '#ff4500', 18));
}

useFuryWave() {
    if (this.type !== 'tempest') return;
    
    if (this.furyKills < this.furyBarMax) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'NOT READY!', '#ff6600', 12));
        return;
    }
    
    // Reset fury bar
    this.furyKills = 0;
    this.updateUI();
    
    // ‚úÖ Create EXPANDING wind wave that grows outward
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 600, 'rgba(100, 200, 255, A)', 'expanding_wind_wave'));
    floatingTexts.push(new FloatingText(this.x, this.y, 'FURY WAVE!', '#00d4ff', 18));
}

switchWeaponKnight() {
    if (this.type !== 'knight') return;
    
    // Toggle between sword and shield
    this.shieldMode = !this.shieldMode;
    
    // Visual feedback
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 40, 'rgba(59, 130, 246, 0.8)', 'explosion'));
    floatingTexts.push(new FloatingText(this.x, this.y, this.shieldMode ? 'SHIELD!' : 'SWORD!', '#3b82f6', 12));
}
switchWeapon() {
    if (this.type !== 'unit7') return;
    
    // Toggle mode
    this.currentMode = this.currentMode === 'laser' ? 'micro' : 'laser';
    
    // Visual feedback
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 40, 'rgba(96, 165, 250, 0.8)', 'explosion'));
    floatingTexts.push(new FloatingText(this.x, this.y, this.currentMode.toUpperCase(), '#60a5fa', 12));
}


               update() {
    if (this.dashCooldown > 0) {
        this.dashCooldown--;

// Mega Turret cooldown countdown
if (this.megaTurretCooldown > 0) {
    this.megaTurretCooldown--;
}
        
        // NINJA: Recharge both dashes when cooldown completes
        if (this.canDoubleDash && this.dashCooldown === 0) {
            this.dashCharges = 2;
        }
    }
    // Mino water regen (only when not shooting)
if (this.type === 'mino') {
    if (this.shootContinuously || this.isSpraying) {
        // Reset delay while shooting
        this.waterRegenDelay = 60; // 1 second delay after shooting stops
    } else if (this.waterRegenDelay > 0) {
        this.waterRegenDelay--;
    } else if (this.waterTank < this.maxWater) {
        this.waterTank = Math.min(this.waterTank + 0.03, this.maxWater); // Faster regen: 0.3 per frame (was 0.15)
        this.updateUI();
    }
}
// Knight Bladestorm System
if (this.bladestormCooldown > 0) this.bladestormCooldown--;
// Pocket Sandwich buff
if (this.sandwichTimer > 0) {
    this.sandwichTimer--;
    const baseSpeed = GAME_CONFIG.PLAYER.BASE_SPEED * (GAME_CONFIG.CLASSES[this.type].speed_mult || 1);
    const speedMult = 1 + (this.upgrades.pocketSandwich * 0.25);
    this.speed = baseSpeed * speedMult;
    this.fireRateMult *= (1 + (this.upgrades.pocketSandwich * 0.2));
    
    // Visual trail effect
    if (frameCount % 5 === 0) {
        effects.push(new Effect(
            this.x + this.w/2,
            this.y + this.h/2,
            12,
            'rgba(251, 191, 36, 0.4)',
            'trail'
        ));
    }
    
    // MEGA VISUAL BUFF INDICATOR - Floating sandwich above player
    if (frameCount % 30 === 0) {
        const floatHeight = Math.sin(frameCount * 0.1) * 5;
        ctx.save();
        ctx.font = '24px monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 15;
        ctx.fillText('ü•™', this.x + this.w/2, this.y - 30 + floatHeight);
        ctx.shadowBlur = 0;
        ctx.restore();
    }
    
    // Show timer above player with glowing background
    if (this.sandwichTimer % 60 === 0 || this.sandwichTimer < 180) {
        const secondsLeft = Math.ceil(this.sandwichTimer/60);
        
        // Draw glowing background box
        ctx.save();
        ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 20;
        ctx.fillRect(this.x - 15, this.y - 50, this.w + 30, 20);
        ctx.strokeRect(this.x - 15, this.y - 50, this.w + 30, 20);
        ctx.shadowBlur = 0;
        
        // Draw timer text
        ctx.fillStyle = '#000';
        ctx.font = 'bold 12px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(`‚ö°${secondsLeft}s`, this.x + this.w/2, this.y - 35);
        ctx.restore();
    }
    
    // Glowing yellow aura around player
    ctx.save();
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 25;
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 3;
    ctx.strokeRect(this.x - 3, this.y - 3, this.w + 6, this.h + 6);
    ctx.shadowBlur = 0;
    ctx.restore();
} else {
    this.sandwichTimer = 0;
}
// Speed Boost effect (MORE OBVIOUS)
if (this.speedBoostTimer > 0) {
    this.speedBoostTimer--;
    const baseSpeed = GAME_CONFIG.PLAYER.BASE_SPEED * (GAME_CONFIG.CLASSES[this.type].speed_mult || 1);
    const speedMult = 1 + (this.upgrades.speedBoost * 0.3); // 30% per stack
    this.speed = baseSpeed * speedMult;
    
    // Visual trail effect
    if (frameCount % 3 === 0) {
        effects.push(new Effect(
            this.x + this.w/2,
            this.y + this.h/2,
            15,
            'rgba(251, 191, 36, 0.5)',
            'trail'
        ));
    }
}

// Knight Shield Wave Cooldown
if (this.type === 'knight' && this.shieldWaveCooldown > 0) {
    this.shieldWaveCooldown--;
}
// Volt Rod Cooldown
if (this.type === 'volt' && this.rodCooldown > 0) {
    this.rodCooldown--;
}
// Unit-7 Weapon System
if (this.type === 'unit7') {
    if (this.laserCooldown > 0) this.laserCooldown--;
    // Micro mode has NO cooldown, just ammo tracking
    // No microCooldown decrement needed
    // Regenerate micro ammo when not on cooldown
    if (this.microCooldown <= 0 && this.microAmmo < this.microMaxAmmo) {
        this.microAmmo = this.microMaxAmmo;
    }
}
if (this.bladestormActive) {
    this.bladestormDuration--;
    if (this.bladestormDuration <= 0) this.bladestormActive = false;
    
    if (frameCount % 5 === 0) {
        enemies.forEach(e => {
            const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2), (e.y + e.h/2) - (this.y + this.h/2));
            if (dist < 120) {
                hitEnemy(e, 10);
            }
        });
    }
}

// Archer Ricochet System
if (this.ricochetCooldown > 0) this.ricochetCooldown--;
// Mage Meteor System
if (this.meteorCooldown > 0) this.meteorCooldown--;


// ‚ú® MAJESTIC PAC TRAIL EFFECT
const trailFrequency = saveData.performanceMode ? 12 : 3;
if (frameCount % trailFrequency === 0) {
    const trailColor = saveData.pac.trailColor;
    
    const r = parseInt(trailColor.slice(1, 3), 16);
    const g = parseInt(trailColor.slice(3, 5), 16);
    const b = parseInt(trailColor.slice(5, 7), 16);
    
    for (let i = 0; i < 3; i++) {
        const offsetX = (Math.random() - 0.5) * 15;
        const offsetY = (Math.random() - 0.5) * 15;
        const alpha = 0.4 - (i * 0.1);
        const radius = 18 - (i * 4);
        
        effects.push(new Effect(
            this.x + this.w/2 + offsetX,
            this.y + this.h/2 + offsetY,
            radius,
            `rgba(${r}, ${g}, ${b}, ${alpha})`,
            'trail'
        ));
    }
    
    if (saveData.pac.rank !== 'rookie' && Math.random() < 0.3) {
        effects.push(new Effect(
            this.x + this.w/2 + (Math.random() - 0.5) * 20,
            this.y + this.h/2 + (Math.random() - 0.5) * 20,
            8,
            'rgba(255, 255, 255, 0.6)',
            'trail'
        ));
    }

    
    // =====================================================
// =====================================================
// =====================================================
    // APPLY TEMPORARY UPGRADES
    // =====================================================

    // Fire Ring - Burns nearby enemies
    if (this.upgrades.fireRing > 0 && frameCount % 8 === 0) {
        const ringRadius = 70;
        enemies.forEach(e => {
            const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2), (e.y + e.h/2) - (this.y + this.h/2));
            if (dist < ringRadius) {
                hitEnemy(e, 1.2 * this.upgrades.fireRing);
            }
        });
    }

    // Lightning Storm - Call down lightning bolts
    if (this.upgrades.lightningStorm > 0) {
        this.lightningStormTimer++;
        const cooldown = Math.max(90, 270 - (this.upgrades.lightningStorm * 45));
        
        if (this.lightningStormTimer >= cooldown) {
            this.lightningStormTimer = 0;
            
            const totalStrikes = this.upgrades.lightningStorm;
            
            for (let i = 0; i < totalStrikes && enemies.length > 0; i++) {
                const target = enemies[Math.floor(Math.random() * enemies.length)];
                
                // Create lightning bolt from top of screen
                const lightningBolt = {
                    x: target.x + target.w/2,
                    y: target.y + target.h/2,
                    life: 15,
                    targetEnemy: target
                };
                
                // Draw lightning bolt in effects array
                effects.push({
                    x: lightningBolt.x,
                    y: 0,
                    targetX: lightningBolt.x,
                    targetY: lightningBolt.y,
                    life: 15,
                    lifeMax: 15,
                    type: 'lightning_bolt',
                    update: function() {
                        this.life--;
                    },
                    draw: function() {
                        if (this.life <= 0) return;
                        
                        ctx.save();
                        ctx.strokeStyle = '#60a5fa';
                        ctx.lineWidth = 4;
                        ctx.shadowColor = '#60a5fa';
                        ctx.shadowBlur = 20;
                        
                        // Jagged lightning path
                        ctx.beginPath();
                        ctx.moveTo(this.targetX, 0);
                        
                        const segments = 8;
                        const segmentHeight = this.targetY / segments;
                        let currentX = this.targetX;
                        
                        for (let i = 1; i <= segments; i++) {
                            const offsetX = (Math.random() - 0.5) * 30;
                            currentX += offsetX;
                            ctx.lineTo(currentX, i * segmentHeight);
                        }
                        
                        ctx.stroke();
                        
                        // Inner white core
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                
                // Explosion effect at impact
                effects.push(new Effect(target.x + target.w/2, target.y + target.h/2, 50, 'rgba(96, 165, 250, 0.9)', 'explosion'));
                
                // Deal damage
                hitEnemy(target, 6);
                floatingTexts.push(new FloatingText(target.x, target.y, '‚ö°', '#60a5fa', 18));
            }
        }
    }

    // Auto-Heal
    if (this.upgrades.autoHeal > 0) {
        this.healTimer++;
        if (this.healTimer >= 480) {
            const healAmount = 2 * this.upgrades.autoHeal;
            this.hp = Math.min(this.hp + healAmount, this.maxHp);
            this.healTimer = 0;
            floatingTexts.push(new FloatingText(this.x, this.y, `+${healAmount} HP`, '#22c55e', 12));
        }
    }

// Regeneration Aura
if (this.upgrades.regenAura > 0) {
    this.regenTimer++;
    // Heal every 180 frames (3 seconds at 60fps) - NERFED
    if (this.regenTimer >= 180) { // NERFED: Was 120, now 180
        const healAmount = 2 * this.upgrades.regenAura; // NERFED: Was 3, now 2
        const actualHeal = Math.min(healAmount, this.maxHp - this.hp);
        
        if (actualHeal > 0) {
            this.hp = Math.min(this.hp + healAmount, this.maxHp);
            floatingTexts.push(new FloatingText(
                this.x, 
                this.y, 
                `+${actualHeal} HP`, 
                '#22c55e', 
                14
            ));
            // Green healing pulse effect
            effects.push(new Effect(
                this.x + this.w/2, 
                this.y + this.h/2, 
                30, 
                'rgba(34, 197, 94, 0.5)', 
                'explosion'
            ));
        }
        
        this.regenTimer = 0;
        this.updateUI();
    }
}

// Ice Barrier - Freeze enemies on contact (NO DAMAGE, JUST SLOW)
if (this.upgrades.iceBarrier > 0) {
    const iceRadius = 70 + (this.upgrades.iceBarrier * 15);
    const slowPercent = 0.6 - (this.upgrades.iceBarrier * 0.05); // NERFED: Was 0.4, now 0.6 (less slow)
        
        enemies.forEach(e => {
            const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2), (e.y + e.h/2) - (this.y + this.h/2));
            if (dist < iceRadius) {
                if (!e.iceSlowed) {
                    e.iceSlowed = true;
                    e.originalSpeed = e.speed;
                }
                e.speed = e.originalSpeed * Math.max(0.2, slowPercent);
            } else if (e.iceSlowed) {
                e.speed = e.originalSpeed;
                e.iceSlowed = false;
            }
        });
    }

    // Lifesteal tracking
    if (this.upgrades.lifesteal > 0) {
        // Healing happens in hitEnemy function
    }
}
                    
                    if (this.isDashing) {
                        this.x += this.dashVel.x;
                        this.y += this.dashVel.y;
                        this.dashTime--;
                        this.x = Math.max(0, Math.min(canvas.width - this.w, this.x));
                        this.y = Math.max(0, Math.min(canvas.height - this.h, this.y));
                        if (this.dashTime <= 0) this.isDashing = false;
                        this.draw();
                        return; 
                    }

                    let speedMod = 1;
                    for (const effect of effects) {
                        if (effect.type === 'ice_field') {
                            const dist = Math.hypot((this.x+this.w/2)-effect.x, (this.y+this.h/2)-effect.y);
                            if (dist < effect.radius) speedMod = 0.6;
                        }
                    }

                   // Slow Field upgrade
if (player && player.upgrades.slowField > 0) {
    const dist = Math.hypot((this.x + this.w/2) - (player.x + player.w/2),
                           (this.y + this.h/2) - (player.y + player.h/2));
    if (dist < 120) {
        speed *= Math.max(0.5, 1 - (player.upgrades.slowField * 0.2));
    }
}

                    
                   // Calculate movement direction
let moveX = 0;
let moveY = 0;
if ((keys['ArrowUp'] || keys['KeyW']) && this.y > 0) moveY = -1;
if ((keys['ArrowDown'] || keys['KeyS']) && this.y < canvas.height - this.h) moveY = 1;
if ((keys['ArrowLeft'] || keys['KeyA']) && this.x > 0) moveX = -1;
if ((keys['ArrowRight'] || keys['KeyD']) && this.x < canvas.width - this.w) moveX = 1;

// Normalize diagonal movement (prevents 1.414x speed)
if (moveX !== 0 && moveY !== 0) {
    const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
    moveX /= magnitude;
    moveY /= magnitude;
}

// Apply movement WITH WALL COLLISION
let finalSpeed = this.speed * speedMod;

// Knight shield penalty
if (this.type === 'knight' && this.shieldMode) {
    finalSpeed *= 0.7; // 30% slower with shield
}

const moveSpeed = finalSpeed;
const newX = this.x + moveX * moveSpeed;
const newY = this.y + moveY * moveSpeed;

this.x = newX;
this.y = newY;

// Normal boundary collision
this.x = Math.max(0, Math.min(canvas.width - this.w, this.x));
this.y = Math.max(0, Math.min(canvas.height - this.h, this.y));
                    if (keys['Space']) this.dash();
                    if (keys['Space']) this.dash();

if (keys['KeyV']) {
    if (this.type === 'knight') {
        this.useBladestorm();
    } else if (this.type === 'archer') {
        this.useRicochet();
    } else if (this.type === 'mage') {
        // Store click for next mouse click
        this.waitingForMeteorTarget = true;
        floatingTexts.push(new FloatingText(this.x, this.y, 'CLICK TARGET!', '#ff4500', 14));
    }
    keys['KeyV'] = false;
}

// Volt Dash OR Tempest Fury Wave (C key)
if (keys['KeyC']) {
    if (this.type === 'volt') {
        this.useVoltDash();
    } else if (this.type === 'tempest') {
        this.useFuryWave();
    } else if (this.type === 'dragon' && this.rageCharge >= this.rageMax) {
        // Dragon rage wave code stays the same
        this.rageCharge = 0;
        this.updateUI();
        
        effects.push({
            x: this.x + this.w/2,
            y: this.y + this.h/2,
            radius: 30,
            maxRadius: 200,
            life: 90,
            lifeMax: 90,
            expandSpeed: 8,
            type: 'dragon_rage_wave',
            update: function() {
                this.life--;
                this.radius += this.expandSpeed;
                
                if (frameCount % 10 === 0) {
                    enemies.forEach(e => {
                        const dist = Math.hypot((e.x + e.w/2) - this.x, (e.y + e.h/2) - this.y);
                        const thickness = 40;
                        if (dist >= this.radius - thickness && dist <= this.radius + thickness) {
                            hitEnemy(e, 5);
                            if (!e.isBurning) {
                                e.isBurning = true;
                                e.burnTimer = 180;
                                e.burnDamage = 1;
                            }
                            floatingTexts.push(new FloatingText(e.x, e.y, 'üî•', '#f97316', 14));
                        }
                    });
                }
            },
            draw: function() {
                if (this.life <= 0) return;
                const alpha = this.life / this.lifeMax;
                ctx.save();
                ctx.strokeStyle = `rgba(251, 146, 60, ${alpha * 0.8})`;
                ctx.lineWidth = 30;
                ctx.shadowColor = '#f97316';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha * 0.6})`;
                ctx.lineWidth = 15;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius - 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        });
        
        floatingTexts.push(new FloatingText(this.x, this.y, 'üî• RAGE WAVE!', '#f97316', 20));
    }
    keys['KeyC'] = false;
}

// Dragon Rage Wave (C key)
if (keys['KeyC'] && this.type === 'dragon' && this.rageCharge >= this.rageMax) {
    this.rageCharge = 0;
    this.updateUI();
    
    // Create BIGGER, SLOWER fire rage wave
    effects.push({
        x: this.x + this.w/2,
        y: this.y + this.h/2,
        radius: 30,
        maxRadius: 200,
        life: 90,
        lifeMax: 90,
        expandSpeed: 8,
        type: 'dragon_rage_wave',
        update: function() {
            this.life--;
            this.radius += this.expandSpeed;
            
            // Damage and burn enemies in radius - CHECK EVERY FRAME
enemies.forEach(e => {
    const dist = Math.hypot((e.x + e.w/2) - this.x, (e.y + e.h/2) - this.y);
    const thickness = 50;
    
    // Check if enemy is in the wave ring
    if (dist >= this.radius - thickness && dist <= this.radius + thickness) {
        // Mark that this enemy was hit by this specific wave
        if (!this.hitEnemies) this.hitEnemies = new Set();
        
        if (!this.hitEnemies.has(e)) {
            this.hitEnemies.add(e);
            hitEnemy(e, 5);
            
            if (!e.isBurning) {
                e.isBurning = true;
                e.burnTimer = 180;
                e.burnDamage = 1;
            }
            floatingTexts.push(new FloatingText(e.x, e.y, 'üî•', '#f97316', 14));
        }
    }
});
    
        },
        draw: function() {
            if (this.life <= 0) return;
            const alpha = this.life / this.lifeMax;
            ctx.save();
            ctx.strokeStyle = `rgba(251, 146, 60, ${alpha * 0.8})`;
            ctx.lineWidth = 30;
            ctx.shadowColor = '#f97316';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner glow
            ctx.strokeStyle = `rgba(255, 200, 0, ${alpha * 0.6})`;
            ctx.lineWidth = 15;
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius - 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    });
    
    floatingTexts.push(new FloatingText(this.x, this.y, 'üî• RAGE WAVE!', '#f97316', 20));
    keys['KeyC'] = false;
}
// Unit-7 Weapon Switch
if (keys['KeyQ'] && this.type === 'unit7') {
    this.switchWeapon();
    keys['KeyQ'] = false;
}
// Knight Shield Switch
if (keys['KeyQ'] && this.type === 'knight') {
    this.switchWeaponKnight();
    keys['KeyQ'] = false;
}


                    if (keys['KeyT']) {
                        if (sessionTurrets > 0) {
                            sessionTurrets--;
                            ui.hudTurretCount.textContent = sessionTurrets;
                            turrets.push(new Turret(this.x + this.w/2, this.y + this.h/2));
                            keys['KeyT'] = false; 
                        }
                    }
                 if (keys['KeyB']) {
    if (sessionBombs > 0) {
        sessionBombs--;
        ui.hudBombCount.textContent = sessionBombs;
        
        const bombX = this.x + this.w/2;
        const bombY = this.y + this.h/2;
        
        // Create explosion effect
        effects.push(new Effect(bombX, bombY, GAME_CONFIG.BOMB.RADIUS, 'rgba(255, 100, 0, A)', 'explosion'));
        
        // Hit all enemies in radius
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dist = Math.hypot((e.x + e.w/2) - bombX, (e.y + e.h/2) - bombY);
            if (dist < GAME_CONFIG.BOMB.RADIUS) {
                hitEnemy(e, GAME_CONFIG.BOMB.DAMAGE);
            }
        }
        
        floatingTexts.push(new FloatingText(bombX, bombY, 'üí£ BOOM!', '#ff6600', 20));
        keys['KeyB'] = false;
    } else if (sessionBombs <= 0 && keys['KeyB']) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'No Bombs!', '#ff0000', 12));
        keys['KeyB'] = false;
    }
}
if (keys['KeyL']) {
    if (sessionLoveBursts > 0) {
        sessionLoveBursts--;
        document.getElementById('hudLoveBurstCount').textContent = sessionLoveBursts;
        
        // Heal player
        const healAmount = 15;
        player.hp = Math.min(player.hp + healAmount, player.maxHp);
        player.updateUI();
        
        // Pink healing burst effect
        effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 80, 'rgba(236, 72, 153, 0.8)', 'explosion'));
        floatingTexts.push(new FloatingText(player.x, player.y, `+${healAmount} HP üíó`, '#ec4899', 18));
        
        keys['KeyL'] = false;
    } else if (sessionLoveBursts <= 0 && keys['KeyL']) {
        floatingTexts.push(new FloatingText(player.x, player.y, 'No Love Bursts!', '#ff0000', 12));
        keys['KeyL'] = false;
    }
}

if (keys['KeyN']) {
    if (sessionBurnWaves > 0) {
        sessionBurnWaves--;
        document.getElementById('hudBurnWaveCount').textContent = sessionBurnWaves;
        
        const waveX = player.x + player.w/2;
        const waveY = player.y + player.h/2;
        const waveRadius = 120;
        
        // Create fire wave effect
        effects.push(new Effect(waveX, waveY, waveRadius, 'rgba(251, 146, 60, 0.8)', 'explosion'));
        
        // Hit and burn all enemies in radius
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dist = Math.hypot((e.x + e.w/2) - waveX, (e.y + e.h/2) - waveY);
            if (dist < waveRadius) {
                hitEnemy(e, 2);
                
                // Apply burn
                if (!e.isBurning) {
                    e.isBurning = true;
                    e.burnTimer = 180;
                    e.burnDamage = 1;
                }
                
                floatingTexts.push(new FloatingText(e.x, e.y, 'üî•', '#f97316', 14));
            }
        }
        
        floatingTexts.push(new FloatingText(waveX, waveY - 20, 'üî• BURN WAVE!', '#f97316', 20));
        keys['KeyN'] = false;
    } else if (sessionBurnWaves <= 0 && keys['KeyN']) {
        floatingTexts.push(new FloatingText(player.x, player.y, 'No Burn Waves!', '#ff0000', 12));
        keys['KeyN'] = false;
    }
}

                    const dx = mousePos.x - (this.x + this.w / 2);
const dy = mousePos.y - (this.y + this.h / 2);
this.angle = Math.atan2(dy, dx);
                    
                    this.weaponCooldown--;
                    if (this.type === 'dragon' && this.breathCooldown > 0) {
    this.breathCooldown--;
}
                    if (this.isSlashing) {
                        this.slashTimer--;
                        if (this.slashTimer <= 0) this.isSlashing = false;
                    }
                    
                    this.draw();
                }
                
                draw() {
                    if (this.isDashing) {
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(this.x - this.dashVel.x, this.y - this.dashVel.y, this.w, this.h);
                        ctx.globalAlpha = 1.0;
                    }

                    if (!saveData.performanceMode) {
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(this.x + 4, this.y + 8, this.w, this.h - 4);
}
ctx.fillStyle = this.color;
ctx.fillRect(this.x, this.y, this.w, this.h);

if (this.isObsidian) {
    // Obsidian Knight - Epic crystalline effect
    ctx.save();
    
    // Dark crystal shards
    ctx.strokeStyle = '#7c3aed';
    ctx.lineWidth = 2;
    ctx.strokeRect(this.x, this.y, this.w, this.h);
    
    // Inner crystalline pattern
    ctx.strokeStyle = '#a78bfa';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + this.w, this.y + this.h);
    ctx.moveTo(this.x + this.w, this.y);
    ctx.lineTo(this.x, this.y + this.h);
    ctx.stroke();
    
    // Glowing purple runes (animated)
    const runeOpacity = 0.6 + Math.sin(frameCount * 0.1) * 0.4;
    ctx.fillStyle = `rgba(167, 139, 250, ${runeOpacity})`;
    
    // Rune symbols (simple geometric shapes)
    ctx.fillRect(this.x + 2, this.y + 2, 4, 4);
    ctx.fillRect(this.x + this.w - 6, this.y + 2, 4, 4);
    ctx.fillRect(this.x + 2, this.y + this.h - 6, 4, 4);
    ctx.fillRect(this.x + this.w - 6, this.y + this.h - 6, 4, 4);
    
    // Center glowing core
    ctx.shadowColor = '#a78bfa';
    ctx.shadowBlur = 10;
    ctx.fillStyle = `rgba(196, 181, 253, ${runeOpacity})`;
    ctx.fillRect(this.x + this.w/2 - 3, this.y + this.h/2 - 3, 6, 6);
    ctx.shadowBlur = 0;
    
    // Particle trail effect (only if moving)
    if (frameCount % 3 === 0 && (Math.abs(this.x - (this.lastX || this.x)) > 1 || Math.abs(this.y - (this.lastY || this.y)) > 1)) {
        effects.push(new Effect(
            this.x + this.w/2 + (Math.random() - 0.5) * 10,
            this.y + this.h/2 + (Math.random() - 0.5) * 10,
            8,
            'rgba(167, 139, 250, 0.6)',
            'trail'
        ));
    }
    
    this.lastX = this.x;
    this.lastY = this.y;
    
    ctx.restore();
} else if (this.isGold) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(this.x, this.y, this.w, this.h);
}
                    ctx.fillStyle = 'white';
                    ctx.fillRect(this.x + 4, this.y + 6, 8, 8);
                    ctx.fillRect(this.x + 16, this.y + 6, 8, 8);
                    ctx.fillStyle = 'black';
                    const xOffset = Math.cos(this.angle) * 2;
                    const yOffset = Math.sin(this.angle) * 2;
                    ctx.fillRect(this.x + 6 + xOffset, this.y + 8 + yOffset, 4, 4);
                    ctx.fillRect(this.x + 18 + xOffset, this.y + 8 + yOffset, 4, 4);

                    
                   if (this.type === 'knight') {
    if (this.shieldMode) {
        this.drawKnightShield();
    } else {
        this.drawKnightSword();
    }
    if (this.bladestormActive) {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#3b82f6';
        ctx.shadowBlur = 20;
        const spinAngle = (frameCount * 0.3) % (Math.PI * 2);
        for (let i = 0; i < 4; i++) {
            const angle = spinAngle + (i * Math.PI / 2);
            ctx.beginPath();
            ctx.arc(0, 0, 100, angle, angle + Math.PI / 3);
            ctx.stroke();
        }
        ctx.restore();

        // =====================================================
// DRAW UPGRADE VISUAL EFFECTS
// =====================================================

// Shadow Blades
if (this.upgrades.shadowBlades > 0) {
    ctx.save();
    const bladeRadius = 55;
    for (let i = 0; i < this.upgrades.shadowBlades; i++) {
        const angle = this.shadowBladeAngle + (i * Math.PI * 2 / this.upgrades.shadowBlades);
        const bladeX = this.x + this.w/2 + Math.cos(angle) * bladeRadius;
        const bladeY = this.y + this.h/2 + Math.sin(angle) * bladeRadius;
        
        ctx.translate(bladeX, bladeY);
        ctx.rotate(angle + Math.PI/2);
        
        // Blade glow
        ctx.shadowColor = '#9333ea';
        ctx.shadowBlur = 15;
        
        // Blade shape
        ctx.fillStyle = '#6b21a8';
        ctx.fillRect(-14, -4, 28, 8);
        ctx.fillStyle = '#9333ea';
        ctx.fillRect(-10, -2, 20, 4);
        
        // Blade tip
        ctx.beginPath();
        ctx.moveTo(14, 0);
        ctx.lineTo(18, -4);
        ctx.lineTo(18, 4);
        ctx.closePath();
        ctx.fillStyle = '#a855f7';
        ctx.fill();
        
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Combat Drones - FIXED RENDERING
if (this.upgrades.orbitalDrones > 0 && this.droneSystem) {
    ctx.save();
    const droneRadius = 80;
    const droneCount = this.upgrades.orbitalDrones;
    
    for (let i = 0; i < droneCount; i++) {
        if (!this.droneSystem.angles[i]) continue;
        
        const angle = this.droneSystem.angles[i];
        const droneX = this.x + this.w/2 + Math.cos(angle) * droneRadius;
        const droneY = this.y + this.h/2 + Math.sin(angle) * droneRadius;
        
        // Drone body - metallic shell
        ctx.fillStyle = '#1e293b';
        ctx.shadowColor = '#60a5fa';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // Drone border ring
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 12, 0, Math.PI * 2);
        ctx.stroke();
        
        // Glowing core
        ctx.fillStyle = '#60a5fa';
        ctx.shadowColor = '#60a5fa';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner bright core
        ctx.fillStyle = '#93c5fd';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Spinning propeller blades
        const spinAngle = (frameCount * 0.2) + (i * Math.PI / droneCount);
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#94a3b8';
        for (let b = 0; b < 4; b++) {
            const bladeAngle = spinAngle + (b * Math.PI / 2);
            ctx.beginPath();
            ctx.moveTo(droneX, droneY);
            ctx.lineTo(
                droneX + Math.cos(bladeAngle) * 16,
                droneY + Math.sin(bladeAngle) * 16
            );
            ctx.stroke();
        }
        
        // Targeting laser when about to fire
        if (this.droneSystem.cooldowns[i] <= 5 && this.droneSystem.cooldowns[i] > 0 && enemies.length > 0) {
            let nearest = null;
            let minDist = 250;
            
            for (const e of enemies) {
                const dist = Math.hypot((e.x + e.w/2) - droneX, (e.y + e.h/2) - droneY);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = e;
                }
            }
            
            if (nearest) {
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(droneX, droneY);
                ctx.lineTo(nearest.x + nearest.w/2, nearest.y + nearest.h/2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Fire Ring indicator with particles
if (this.upgrades.fireRing > 0) {
    ctx.save();
    const fireOpacity = 0.3 + Math.sin(frameCount * 0.1) * 0.2;
    ctx.strokeStyle = `rgba(239, 68, 68, ${fireOpacity})`;
    ctx.lineWidth = 4;
    ctx.shadowColor = '#ff6400';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 70, 0, Math.PI * 2);
    ctx.stroke();
    
    // Fire particles orbiting
    const particleCount = 8 + (this.upgrades.fireRing * 2);
    for (let i = 0; i < particleCount; i++) {
        const angle = (frameCount * 0.08 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
        const particleX = this.x + this.w/2 + Math.cos(angle) * 70;
        const particleY = this.y + this.h/2 + Math.sin(angle) * 70;
        const particleSize = 4 + Math.sin(frameCount * 0.1 + i) * 2;
        
        ctx.fillStyle = `rgba(251, 146, 60, ${fireOpacity + 0.4})`;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Ice Barrier visual
if (this.upgrades.iceBarrier > 0) {
    ctx.save();
    ctx.strokeStyle = `rgba(100, 200, 255, ${0.4 + Math.sin(frameCount * 0.08) * 0.2})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = '#00d4ff';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 45, 0, Math.PI * 2);
    ctx.stroke();
    
    // Ice crystals
    if (frameCount % 15 === 0) {
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) + (frameCount * 0.02);
            const crystalX = this.x + this.w/2 + Math.cos(angle) * 45;
            const crystalY = this.y + this.h/2 + Math.sin(angle) * 45;
            ctx.fillStyle = 'rgba(200, 240, 255, 0.7)';
            ctx.fillRect(crystalX - 3, crystalY - 3, 6, 6);
        }
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Combat Drones - Simple and Visible
if (this.upgrades.orbitalDrones > 0 && this.droneAngles) {
    ctx.save();
    const droneRadius = 80;
    const droneCount = this.upgrades.orbitalDrones;
    
    for (let i = 0; i < droneCount; i++) {
        const angle = this.droneAngles[i] || 0;
        const droneX = this.x + this.w/2 + Math.cos(angle) * droneRadius;
        const droneY = this.y + this.h/2 + Math.sin(angle) * droneRadius;
        
        // Drone body - simple blue circle
        ctx.fillStyle = '#3b82f6';
        ctx.shadowColor = '#60a5fa';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 10, 0, Math.PI * 2);
        ctx.fill();
        
        // White core
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(droneX, droneY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Simple rotating line (propeller indicator)
        const spinAngle = (frameCount * 0.2) + (i * Math.PI / droneCount);
        ctx.strokeStyle = '#60a5fa';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.moveTo(droneX, droneY);
        ctx.lineTo(
            droneX + Math.cos(spinAngle) * 12,
            droneY + Math.sin(spinAngle) * 12
        );
        ctx.stroke();
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Ice Barrier - ULTRA VISIBLE with blue glow
if (this.upgrades.iceBarrier > 0) {
    ctx.save();
    const iceRadius = 70 + (this.upgrades.iceBarrier * 15);
    const iceOpacity = 0.6 + Math.sin(frameCount * 0.08) * 0.3;
    
    // Massive glowing aura
    const gradient = ctx.createRadialGradient(
        this.x + this.w/2, this.y + this.h/2, 0,
        this.x + this.w/2, this.y + this.h/2, iceRadius
    );
    gradient.addColorStop(0, 'rgba(56, 189, 248, 0.4)');
    gradient.addColorStop(0.5, `rgba(56, 189, 248, ${iceOpacity * 0.5})`);
    gradient.addColorStop(1, 'rgba(56, 189, 248, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, iceRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // THICK main ice ring
    ctx.strokeStyle = `rgba(56, 189, 248, ${iceOpacity})`;
    ctx.lineWidth = 8;
    ctx.shadowColor = '#38bdf8';
    ctx.shadowBlur = 30;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, iceRadius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Secondary bright ring
    ctx.strokeStyle = `rgba(224, 242, 254, ${iceOpacity})`;
    ctx.lineWidth = 4;
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, iceRadius - 10, 0, Math.PI * 2);
    ctx.stroke();
    
    // Massive amount of frost particles
    const particleCount = 24 + (this.upgrades.iceBarrier * 8);
    for (let i = 0; i < particleCount; i++) {
        const angle = (frameCount * 0.05 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
        const particleX = this.x + this.w/2 + Math.cos(angle) * iceRadius;
        const particleY = this.y + this.h/2 + Math.sin(angle) * iceRadius;
        const particleSize = 5 + Math.sin(frameCount * 0.1 + i) * 3;
        
        // Bright glowing particle
        ctx.fillStyle = `rgba(255, 255, 255, ${iceOpacity})`;
        ctx.shadowColor = '#bae6fd';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Regeneration Aura - Green healing particles
if (this.upgrades.regenAura > 0) {
    ctx.save();
    
    // Pulsing green aura
    const regenAlpha = 0.2 + Math.sin(frameCount * 0.08) * 0.1;
    const auraRadius = 35 + (this.upgrades.regenAura * 3);
    
    // Outer glow
    const gradient = ctx.createRadialGradient(
        this.x + this.w/2, this.y + this.h/2, 0,
        this.x + this.w/2, this.y + this.h/2, auraRadius
    );
    gradient.addColorStop(0, `rgba(34, 197, 94, ${regenAlpha * 0.6})`);
    gradient.addColorStop(0.5, `rgba(34, 197, 94, ${regenAlpha * 0.3})`);
    gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, auraRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Floating healing particles
    const particleCount = 6 + (this.upgrades.regenAura * 2);
    for (let i = 0; i < particleCount; i++) {
        const angle = (frameCount * 0.03 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
        const floatOffset = Math.sin(frameCount * 0.05 + i) * 5;
        const particleX = this.x + this.w/2 + Math.cos(angle) * (auraRadius - 10);
        const particleY = this.y + this.h/2 + Math.sin(angle) * (auraRadius - 10) + floatOffset;
        
        ctx.fillStyle = `rgba(134, 239, 172, ${regenAlpha + 0.4})`;
        ctx.shadowColor = '#22c55e';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
}
    }
}

                    if (this.type === 'archer') this.drawBow();
                    if (this.type === 'mage') this.drawStaff();
                    if (this.type === 'ninja') this.drawNinjaHeadband();
                    if (this.type === 'tempest') this.drawTempestSwirl();
                    if (this.type === 'zap') this.drawZapLightning();
                    if (this.type === 'unit7') this.drawUnit7Weapons();
                   if (this.type === 'mino') this.drawMinoVisual();
                   if (this.type === 'volt') this.drawVoltWhip();
    if (this.type === 'cupid') this.drawCupidWings();
if (this.type === 'dragon') this.drawDragonFlame();
if (this.type === 'necromancer') this.drawNecroStaff();
// Draw Crown if equipped
if (saveData.cosmetics.crown && saveData.cosmetics.crown.equipped) {
    ctx.save();
    ctx.font = '20px monospace';
    ctx.textAlign = 'center';
    const bobbing = Math.sin(Date.now() / 200) * 2;
    ctx.fillText('üëë', this.x + this.w/2, this.y - 10 + bobbing);
    ctx.restore();
}

// Draw new hats
if (saveData.cosmetics.halo && saveData.cosmetics.halo.equipped) {
    ctx.save();
    const haloY = this.y - 20;
    const centerX = this.x + this.w/2;
    
    // Golden halo with glow
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 15;
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(centerX, haloY, 14, 0, Math.PI * 2);
    ctx.stroke();
    
    // Inner bright ring
    ctx.strokeStyle = '#fde68a';
    ctx.lineWidth = 2;
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(centerX, haloY, 12, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

if (saveData.cosmetics.astronaut && saveData.cosmetics.astronaut.equipped) {
    ctx.save();
    const centerX = this.x + this.w/2;
    const centerY = this.y + this.h/2;
    
    // Glass dome
    ctx.shadowColor = '#60a5fa';
    ctx.shadowBlur = 10;
    ctx.strokeStyle = '#93c5fd';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(centerX, centerY, this.w/2 + 4, 0, Math.PI * 2);
    ctx.stroke();
    
    // Reflection shine
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.beginPath();
    ctx.arc(centerX - 5, centerY - 8, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

if (saveData.cosmetics.partyHat && saveData.cosmetics.partyHat.equipped) {
    ctx.save();
    const centerX = this.x + this.w/2;
    const hatY = this.y - 18;
    
    // Colorful cone
    const gradient = ctx.createLinearGradient(centerX, hatY - 15, centerX, hatY + 10);
    gradient.addColorStop(0, '#ec4899');
    gradient.addColorStop(0.33, '#8b5cf6');
    gradient.addColorStop(0.66, '#3b82f6');
    gradient.addColorStop(1, '#10b981');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(centerX, hatY - 15);
    ctx.lineTo(centerX - 12, hatY + 10);
    ctx.lineTo(centerX + 12, hatY + 10);
    ctx.closePath();
    ctx.fill();
    
    // Pom pom
    ctx.fillStyle = '#fbbf24';
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(centerX, hatY - 15, 4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

if (saveData.cosmetics.topHat && saveData.cosmetics.topHat.equipped) {
    ctx.save();
    const centerX = this.x + this.w/2;
    const hatY = this.y - 18;
    
    // Black top hat
    ctx.fillStyle = '#000';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    
    // Hat brim
    ctx.fillRect(centerX - 14, hatY + 8, 28, 3);
    ctx.strokeRect(centerX - 14, hatY + 8, 28, 3);
    
    // Hat top
    ctx.fillRect(centerX - 10, hatY - 15, 20, 23);
    ctx.strokeRect(centerX - 10, hatY - 15, 20, 23);
    
    // Red band
    ctx.fillStyle = '#dc2626';
    ctx.fillRect(centerX - 10, hatY + 3, 20, 3);
    
    ctx.restore();
}

// Draw new accessories
if (saveData.cosmetics.sunglasses && saveData.cosmetics.sunglasses.equipped) {
    ctx.save();
    const centerX = this.x + this.w/2;
    const centerY = this.y + this.h/2 + 1; // Moved up slightly
    
    // Cool black sunglasses (bigger and better positioned)
    ctx.fillStyle = '#000';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 5;
    
    // Left lens (bigger)
    ctx.beginPath();
    ctx.ellipse(centerX - 8, centerY, 7, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Right lens (bigger)
    ctx.beginPath();
    ctx.ellipse(centerX + 8, centerY, 7, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Bridge (thicker)
    ctx.fillRect(centerX - 1, centerY - 1, 2, 3);
    
    // Side arms
    ctx.fillRect(centerX - 15, centerY, 3, 1);
    ctx.fillRect(centerX + 12, centerY, 3, 1);
    
    // Reflection (better positioned)
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.beginPath();
    ctx.arc(centerX - 10, centerY - 2, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(centerX + 6, centerY - 2, 2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

if (saveData.cosmetics.monocle && saveData.cosmetics.monocle.equipped) {
    ctx.save();
    const centerX = this.x + this.w/2 + 8;
    const centerY = this.y + this.h/2 - 2;
    
    // Fancy monocle
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
    ctx.stroke();
    
    // Glass reflection
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.beginPath();
    ctx.arc(centerX - 2, centerY - 2, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Chain
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(centerX + 5, centerY);
    ctx.lineTo(centerX + 10, centerY + 5);
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

if (saveData.cosmetics.mustache && saveData.cosmetics.mustache.equipped) {
    ctx.save();
    const centerX = this.x + this.w/2;
    const centerY = this.y + this.h/2 + 8;
    
    // Stylish handlebar mustache
    ctx.fillStyle = '#2d1810';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 2;
    
    // Left handlebar (curved upward)
    ctx.beginPath();
    ctx.ellipse(centerX - 9, centerY - 1, 4, 3, Math.PI / 6, 0, Math.PI * 2);
    ctx.fill();
    
    // Left connector
    ctx.fillRect(centerX - 7, centerY - 1, 5, 2);
    
    // Center base
    ctx.fillRect(centerX - 3, centerY, 6, 2);
    
    // Right connector
    ctx.fillRect(centerX + 2, centerY - 1, 5, 2);
    
    // Right handlebar (curved upward)
    ctx.beginPath();
    ctx.ellipse(centerX + 9, centerY - 1, 4, 3, -Math.PI / 6, 0, Math.PI * 2);
    ctx.fill();
    
    // Add some highlight
    ctx.fillStyle = 'rgba(139, 69, 19, 0.4)';
    ctx.fillRect(centerX - 2, centerY, 4, 1);
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

// Draw Christmas Cosmetics
if (saveData.cosmetics) {
    ctx.save();
    const centerX = this.x + this.w/2;
    const centerY = this.y + this.h/2;
    
    // Santa Hat - Realistic fabric rendering
    if (saveData.cosmetics.santaHat?.equipped) {
        const hatY = this.y - 18;
        // Red hat body
        ctx.fillStyle = '#c91818';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 8);
        ctx.lineTo(centerX - 16, hatY + 10);
        ctx.lineTo(centerX + 16, hatY + 10);
        ctx.closePath();
        ctx.fill();
        
        // Darker red for depth
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 8);
        ctx.lineTo(centerX + 16, hatY + 10);
        ctx.lineTo(centerX + 12, hatY + 10);
        ctx.closePath();
        ctx.fill();
        
        // White fur trim
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(centerX - 16, hatY + 10, 32, 4);
        
        // White pom-pom with glow
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(centerX + 12, hatY - 4, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    
    // Elf Hat - Green with jingle bell
    if (saveData.cosmetics.elfHat?.equipped) {
        const hatY = this.y - 16;
        // Green hat
        ctx.fillStyle = '#228b22';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 12);
        ctx.lineTo(centerX - 14, hatY + 8);
        ctx.lineTo(centerX + 14, hatY + 8);
        ctx.closePath();
        ctx.fill();
        
        // Dark green shading
        ctx.fillStyle = '#006400';
        ctx.beginPath();
        ctx.moveTo(centerX, hatY - 12);
        ctx.lineTo(centerX + 14, hatY + 8);
        ctx.lineTo(centerX + 10, hatY + 8);
        ctx.closePath();
        ctx.fill();
        
        // Yellow trim
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(centerX - 14, hatY + 8, 28, 3);
        
        // Red jingle bell at tip with shine
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(centerX + 10, hatY - 8, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffaaaa';
        ctx.beginPath();
        ctx.arc(centerX + 11, hatY - 9, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Reindeer Antlers - Brown branching
    if (saveData.cosmetics.antlers?.equipped) {
        const antlerY = this.y - 10;
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        // Left antler
        ctx.beginPath();
        ctx.moveTo(centerX - 10, antlerY);
        ctx.lineTo(centerX - 14, antlerY - 12);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX - 13, antlerY - 6);
        ctx.lineTo(centerX - 16, antlerY - 8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX - 13, antlerY - 9);
        ctx.lineTo(centerX - 18, antlerY - 10);
        ctx.stroke();
        
        // Right antler
        ctx.beginPath();
        ctx.moveTo(centerX + 10, antlerY);
        ctx.lineTo(centerX + 14, antlerY - 12);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX + 13, antlerY - 6);
        ctx.lineTo(centerX + 16, antlerY - 8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX + 13, antlerY - 9);
        ctx.lineTo(centerX + 18, antlerY - 10);
        ctx.stroke();
        
        ctx.lineWidth = 1;
    }
    
    // Carrot Nose - 3D rendered carrot
    if (saveData.cosmetics.carrotNose?.equipped) {
        const noseX = centerX + 14;
        const noseY = centerY;
        
        // Orange carrot body gradient
        const gradient = ctx.createLinearGradient(noseX, noseY - 4, noseX + 10, noseY);
        gradient.addColorStop(0, '#ff8c00');
        gradient.addColorStop(1, '#ff4500');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.moveTo(noseX, noseY - 4);
        ctx.lineTo(noseX + 10, noseY);
        ctx.lineTo(noseX, noseY + 4);
        ctx.closePath();
        ctx.fill();
        
        // Dark orange lines for texture
        ctx.strokeStyle = '#cc6600';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(noseX + 2, noseY - 2);
        ctx.lineTo(noseX + 2, noseY + 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(noseX + 5, noseY - 1);
        ctx.lineTo(noseX + 5, noseY + 1);
        ctx.stroke();
        
        // Highlight
        ctx.fillStyle = '#ffa500';
        ctx.fillRect(noseX + 1, noseY - 2, 2, 1);
    }
    // Heart Crown (Valentine)
    if (saveData.cosmetics.heartCrown?.equipped) {
        const crownY = this.y - 18;
        // Pink crown with hearts
        ctx.fillStyle = '#ec4899';
        ctx.shadowColor = '#f472b6';
        ctx.shadowBlur = 10;
        
        // Crown base
        ctx.fillRect(centerX - 14, crownY + 8, 28, 4);
        
        // Crown spikes with hearts
        for (let i = 0; i < 3; i++) {
            const spikeX = centerX - 10 + (i * 10);
            ctx.fillStyle = '#ec4899';
            ctx.beginPath();
            ctx.moveTo(spikeX, crownY + 8);
            ctx.lineTo(spikeX - 4, crownY);
            ctx.lineTo(spikeX, crownY - 4);
            ctx.lineTo(spikeX + 4, crownY);
            ctx.closePath();
            ctx.fill();
            
            // Heart on top
            ctx.fillStyle = '#f472b6';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('üíó', spikeX, crownY - 6);
        }
        ctx.shadowBlur = 0;
        ctx.textAlign = 'left';
    }
    
    // Red Lantern (Lunar)
    if (saveData.cosmetics.redLantern?.equipped) {
        const lanternY = this.y - 20;
        const bobbing = Math.sin(Date.now() / 300) * 2;
        
        // Lantern string
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, this.y);
        ctx.lineTo(centerX, lanternY + bobbing);
        ctx.stroke();
        
        // Lantern body
        ctx.fillStyle = '#dc2626';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 15;
        ctx.fillRect(centerX - 8, lanternY + bobbing, 16, 12);
        
        // Lantern glow
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(centerX - 6, lanternY + 2 + bobbing, 12, 8);
        ctx.shadowBlur = 0;
    }
    
    // Love Ribbon (Valentine)
    if (saveData.cosmetics.loveRibbon?.equipped) {
        const ribbonY = this.y - 16;
        ctx.fillStyle = '#ec4899';
        ctx.shadowColor = '#f472b6';
        ctx.shadowBlur = 10;
        
        // Ribbon bow
        ctx.fillRect(centerX - 10, ribbonY, 8, 8);
        ctx.fillRect(centerX + 2, ribbonY, 8, 8);
        ctx.fillRect(centerX - 4, ribbonY + 2, 8, 4);
        
        // Ribbon tails
        ctx.fillRect(centerX - 3, ribbonY + 8, 2, 6);
        ctx.fillRect(centerX + 1, ribbonY + 8, 2, 6);
        ctx.shadowBlur = 0;
    }
    
    // Lucky Envelope (Lunar)
    if (saveData.cosmetics.luckyEnvelope?.equipped) {
        const envY = this.y - 20;
        const bobbing = Math.sin(Date.now() / 400) * 1.5;
        
        // Red envelope
        ctx.fillStyle = '#dc2626';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 12;
        ctx.fillRect(centerX - 10, envY + bobbing, 20, 14);
        
        // Gold symbol
        ctx.fillStyle = '#fbbf24';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Á¶è', centerX, envY + 10 + bobbing);
        ctx.shadowBlur = 0;
        ctx.textAlign = 'left';
    }
    
// Heart Eyes (Valentine Event) - BIGGER CUSTOM HEARTS
if (saveData.cosmetics.heartEyes?.equipped) {
    ctx.save();
    
    // Left heart eye
    ctx.fillStyle = '#ec4899';
    ctx.shadowColor = '#f472b6';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    // Heart shape
    ctx.moveTo(centerX - 8, centerY - 2);
    ctx.bezierCurveTo(centerX - 8, centerY - 5, centerX - 12, centerY - 5, centerX - 12, centerY - 2);
    ctx.bezierCurveTo(centerX - 12, centerY + 1, centerX - 8, centerY + 3, centerX - 8, centerY + 5);
    ctx.bezierCurveTo(centerX - 8, centerY + 3, centerX - 4, centerY + 1, centerX - 4, centerY - 2);
    ctx.bezierCurveTo(centerX - 4, centerY - 5, centerX - 8, centerY - 5, centerX - 8, centerY - 2);
    ctx.fill();
    
    // Right heart eye
    ctx.beginPath();
    ctx.moveTo(centerX + 8, centerY - 2);
    ctx.bezierCurveTo(centerX + 8, centerY - 5, centerX + 4, centerY - 5, centerX + 4, centerY - 2);
    ctx.bezierCurveTo(centerX + 4, centerY + 1, centerX + 8, centerY + 3, centerX + 8, centerY + 5);
    ctx.bezierCurveTo(centerX + 8, centerY + 3, centerX + 12, centerY + 1, centerX + 12, centerY - 2);
    ctx.bezierCurveTo(centerX + 12, centerY - 5, centerX + 8, centerY - 5, centerX + 8, centerY - 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}
    
    // Dragon Mask (Lunar)
    if (saveData.cosmetics.dragonMask?.equipped) {
        ctx.save();
        ctx.fillStyle = '#f97316';
        ctx.shadowColor = '#ff4500';
        ctx.shadowBlur = 10;
        
        // Dragon face outline
        ctx.fillRect(centerX - 12, centerY - 8, 24, 16);
        
        // Dragon horns
        ctx.fillStyle = '#dc2626';
        ctx.beginPath();
        ctx.moveTo(centerX - 12, centerY - 8);
        ctx.lineTo(centerX - 16, centerY - 14);
        ctx.lineTo(centerX - 10, centerY - 8);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX + 12, centerY - 8);
        ctx.lineTo(centerX + 16, centerY - 14);
        ctx.lineTo(centerX + 10, centerY - 8);
        ctx.fill();
        
        // Dragon eyes
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(centerX - 8, centerY - 4, 4, 4);
        ctx.fillRect(centerX + 4, centerY - 4, 4, 4);
        
        ctx.shadowBlur = 0;
        ctx.restore();
    }
    
    // Gift Box (Valentine)
    if (saveData.cosmetics.giftBox?.equipped) {
        const giftY = centerY + 4;
        ctx.fillStyle = '#ec4899';
        ctx.shadowColor = '#f472b6';
        ctx.shadowBlur = 8;
        
        // Gift box
        ctx.fillRect(centerX - 8, giftY, 16, 12);
        
        // Ribbon
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(centerX - 2, giftY, 4, 12);
        ctx.fillRect(centerX - 8, giftY + 4, 16, 4);
        
        // Bow on top
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(centerX - 6, giftY - 3, 4, 4);
        ctx.fillRect(centerX + 2, giftY - 3, 4, 4);
        ctx.shadowBlur = 0;
    }
    
    // Fortune Coin (Lunar)
    if (saveData.cosmetics.fortuneCoin?.equipped) {
        const coinY = centerY + 6;
        const spin = (Date.now() / 100) % 360;
        
        ctx.save();
        ctx.translate(centerX, coinY);
        ctx.rotate(spin * Math.PI / 180);
        
        // Gold coin
        ctx.fillStyle = '#fbbf24';
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Coin symbol
        ctx.fillStyle = '#dc2626';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('¬•', 0, 3);
        
        ctx.shadowBlur = 0;
        ctx.restore();
        ctx.textAlign = 'left';
    }
    
    ctx.restore();

}

// =====================================================
// DRAW UPGRADE EFFECTS
// =====================================================

// Orbiting Blades
if (this.upgrades.orbitingBlades > 0) {
    ctx.save();
    const bladeRadius = 50;
    for (let i = 0; i < this.upgrades.orbitingBlades; i++) {
        const angle = this.orbitAngle + (i * Math.PI * 2 / this.upgrades.orbitingBlades);
        const bladeX = this.x + this.w/2 + Math.cos(angle) * bladeRadius;
        const bladeY = this.y + this.h/2 + Math.sin(angle) * bladeRadius;
        
        ctx.translate(bladeX, bladeY);
        ctx.rotate(angle);
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(-12, -3, 24, 6);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(-8, -1, 16, 2);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    ctx.restore();
}

// Shield Bubbles
if (this.upgrades.shieldBubbles > 0) {
    ctx.save();
    const shieldRadius = 40;
    for (let i = 0; i < this.upgrades.shieldBubbles; i++) {
        const angle = this.shieldAngle + (i * Math.PI * 2 / this.upgrades.shieldBubbles);
        const shieldX = this.x + this.w/2 + Math.cos(angle) * shieldRadius;
        const shieldY = this.y + this.h/2 + Math.sin(angle) * shieldRadius;
        
        ctx.fillStyle = '#60a5fa';
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(shieldX, shieldY, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
    ctx.restore();
}

// Fire Ring indicator with particles
if (this.upgrades.fireRing > 0) {
    ctx.save();
    const fireOpacity = 0.3 + Math.sin(frameCount * 0.1) * 0.2;
    ctx.strokeStyle = `rgba(255, 100, 0, ${fireOpacity})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = '#ff6400';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 60, 0, Math.PI * 2);
    ctx.stroke();
    
    // Fire particles
    if (frameCount % 5 === 0) {
        for (let i = 0; i < this.upgrades.fireRing; i++) {
            const angle = (frameCount * 0.05 + i * Math.PI * 2 / this.upgrades.fireRing) % (Math.PI * 2);
            const particleX = this.x + this.w/2 + Math.cos(angle) * 60;
            const particleY = this.y + this.h/2 + Math.sin(angle) * 60;
            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${fireOpacity + 0.3})`;
            ctx.beginPath();
            ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    ctx.restore();
}

// Slow Field visual indicator
if (this.upgrades.slowField > 0) {
    ctx.save();
    ctx.strokeStyle = `rgba(0, 150, 255, ${0.2 + Math.sin(frameCount * 0.08) * 0.15})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 120, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
}
                }
                
                drawBow() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Check if Cupid's Bow is equipped
    const hasCupidBow = saveData.cosmetics.cupidBow && saveData.cosmetics.cupidBow.equipped;
    
    if (hasCupidBow) {
        // CUPID'S BOW - Pink and glowing
        ctx.strokeStyle = '#ec4899';
        ctx.lineWidth = 5;
        ctx.shadowColor = '#f472b6';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(12, 0, 16, -Math.PI/2, Math.PI/2);
        ctx.stroke();
        
        // Heart-shaped tip
        ctx.fillStyle = '#ec4899';
        ctx.beginPath();
        ctx.moveTo(12, -18);
        ctx.lineTo(8, -22);
        ctx.lineTo(12, -26);
        ctx.lineTo(16, -22);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(12, 18);
        ctx.lineTo(8, 22);
        ctx.lineTo(12, 26);
        ctx.lineTo(16, 22);
        ctx.closePath();
        ctx.fill();
        
        // Glowing string
        ctx.strokeStyle = '#f9a8d4';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 20;
        ctx.fillRect(12, -16, 2, 32);
        
        // Sparkles
        if (frameCount % 10 < 5) {
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(12, -10, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(12, 10, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.shadowBlur = 0;
    } else {
        // Normal brown bow
        ctx.strokeStyle = '#854d0e';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(12, 0, 16, -Math.PI/2, Math.PI/2);
        ctx.stroke();
        ctx.fillStyle = '#fff'; 
        ctx.fillRect(12, -16, 2, 32);
    }
    
    ctx.restore();
}

                drawStaff() {
                    ctx.save();
                    ctx.translate(this.x + this.w/2, this.y + this.h/2);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = '#854d0e';
                    ctx.fillRect(12, -3, 24, 6);
                    ctx.fillStyle = '#ef4444';
                    ctx.shadowColor = '#ef4444';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(36, 0, 8, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                drawKnightSword() {
                    ctx.save();
                    ctx.translate(this.x + this.w/2, this.y + this.h/2);
                    ctx.rotate(this.angle);
                    
                    // Check if Christmas Tree sword is equipped
                    const hasChristmasTree = saveData.cosmetics.christmasTree && saveData.cosmetics.christmasTree.equipped;
                    
                    if (hasChristmasTree) {
                        // ‚úÖ CHRISTMAS TREE SWORD
                        // Brown trunk/handle
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(0, -6, 20, 12);
                        
                        // Green tree sections (3 tiers getting smaller)
                        ctx.fillStyle = '#228b22';
                        // Bottom tier
                        ctx.beginPath();
                        ctx.moveTo(20, -15);
                        ctx.lineTo(50, 0);
                        ctx.lineTo(20, 15);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Middle tier
                        ctx.beginPath();
                        ctx.moveTo(35, -12);
                        ctx.lineTo(60, 0);
                        ctx.lineTo(35, 12);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Top tier
                        ctx.beginPath();
                        ctx.moveTo(50, -9);
                        ctx.lineTo(70, 0);
                        ctx.lineTo(50, 9);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Star on top
                        ctx.fillStyle = '#ffd700';
                        ctx.shadowColor = '#ffd700';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(70, 0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Christmas lights (animated)
                        const lightColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
                        const lightPositions = [
                            {x: 30, y: -8}, {x: 30, y: 8},
                            {x: 45, y: -6}, {x: 45, y: 6},
                            {x: 60, y: -4}, {x: 60, y: 4}
                        ];
                        
                        lightPositions.forEach((pos, i) => {
                            const blinkPhase = (frameCount + i * 10) % 60;
                            if (blinkPhase < 30) {
                                ctx.fillStyle = lightColors[i % lightColors.length];
                                ctx.shadowColor = lightColors[i % lightColors.length];
                                ctx.shadowBlur = 8;
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.shadowBlur = 0;
                            }
                        });
                    } else {
                        // Normal sword
                        ctx.fillStyle = '#555';
                        ctx.fillRect(0, -4, 12, 8);
                        ctx.fillStyle = this.isGold ? '#fbbf24' : '#d4af37';
                        ctx.fillRect(12, -10, 6, 20);
                        ctx.fillStyle = '#e2e8f0';
                        ctx.fillRect(18, -this.swordWidth/2, this.swordLength, this.swordWidth);
                    }
                    if (this.isSlashing) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, this.swordLength + 20, -Math.PI/3, Math.PI/3);
                        ctx.fill();
                    }
                    ctx.restore();
                }

                drawKnightShield() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Shield body (blue metallic)
    ctx.fillStyle = '#3b82f6';
    ctx.strokeStyle = '#1e40af';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(20, 0, 20, -Math.PI/2, Math.PI/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Shield rim (darker blue)
    ctx.strokeStyle = '#1e3a8a';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Shield emblem (cross)
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(20, -10);
    ctx.lineTo(20, 10);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(12, 0);
    ctx.lineTo(28, 0);
    ctx.stroke();
    
    ctx.restore();
}

                drawNinjaHeadband() {
                    ctx.fillStyle = '#dc2626'; // Red
                    ctx.fillRect(this.x, this.y + 5, this.w, 4);
                }
                drawTempestSwirl() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.w/2);
    const swirl = (frameCount * 0.1) % (Math.PI * 2);
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(0, 0, 15 + (i * 3), swirl + (i * 0.5), swirl + Math.PI + (i * 0.5));
        ctx.stroke();
    }
    ctx.restore();
}

drawZapLightning() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    
    // Electric sparks around body (intensity based on charge)
    const chargePercent = (this.chargeCounter || 0) / 100;
    const sparkCount = 4 + Math.floor(chargePercent * 4);
    const time = frameCount * 0.2;
    
    for (let i = 0; i < sparkCount; i++) {
        const angle = (time + (i * Math.PI * 2 / sparkCount)) % (Math.PI * 2);
        const dist = 12 + Math.sin(time * 2 + i) * 3 + (chargePercent * 5);
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        
        const sparkColor = chargePercent >= 1 ? '#fff' : (Math.random() > 0.5 ? '#60a5fa' : '#fbbf24');
        ctx.fillStyle = sparkColor;
        ctx.beginPath();
        ctx.arc(x, y, 2 + (chargePercent * 2), 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Charge indicator ring
    if (chargePercent > 0) {
        const ringColor = chargePercent >= 1 ? '#fff' : '#fbbf24';
        ctx.shadowColor = ringColor;
        ctx.shadowBlur = chargePercent >= 1 ? 30 : 20;
        ctx.strokeStyle = ringColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, 18, 0, Math.PI * 2 * chargePercent);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Pulse when fully charged
        if (chargePercent >= 1 && Math.floor(time) % 2 === 0) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, 22, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
    
    ctx.restore();
    
    // Charge bar above player
    if (chargePercent > 0) {
        const barWidth = 40;
        const barX = this.x + this.w/2 - barWidth/2;
        const barY = this.y - 8;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(barX - 1, barY - 1, barWidth + 2, 5);
        
        const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
        gradient.addColorStop(0, '#fbbf24');
        gradient.addColorStop(1, chargePercent >= 1 ? '#fff' : '#60a5fa');
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY, barWidth * chargePercent, 3);
        
        ctx.strokeStyle = chargePercent >= 1 ? '#fff' : '#fbbf24';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, 3);
    }
}

drawUnit7Weapons() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Glowing core
    ctx.shadowColor = '#60a5fa';
    ctx.shadowBlur = 15;
    ctx.fillStyle = '#3b82f6';
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Draw active weapon
    if (this.currentMode === 'laser') {
        // Laser Cannon (large)
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(8, -6, 20, 12);
        ctx.fillStyle = '#60a5fa';
        ctx.fillRect(28, -4, 8, 8);
        
        // Charge indicator
        if (this.laserCooldown > 0) {
            const chargePercent = 1 - (this.laserCooldown / 220);
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(28, -4, 8 * chargePercent, 8);
        }
    } else {
        // Micro Blaster (small multi-barrel)
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(8, -4, 16, 8);
        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(24, -3 + (i * 3), 4, 2);
        }
    }
    
    ctx.restore();
    
    // Mode indicator above player
    ctx.fillStyle = this.currentMode === 'laser' ? '#3b82f6' : '#fbbf24';
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(this.currentMode === 'laser' ? 'LASER' : 'MICRO', this.x + this.w/2, this.y - 10);
    ctx.textAlign = 'left';
    
    // Ammo bar for micro mode
    if (this.currentMode === 'micro') {
        const barWidth = 30;
        const barX = this.x + this.w/2 - barWidth/2;
        const barY = this.y - 4;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(barX - 1, barY - 1, barWidth + 2, 4);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(barX, barY, barWidth * (this.microAmmo / this.microMaxAmmo), 2);
    }
}

drawHunterSpear() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Spear handle (brown)
    ctx.fillStyle = '#92400e';
    ctx.fillRect(8, -2, 30, 4);
    
    // Spear tip (green crystal)
    ctx.fillStyle = '#16a34a';
    ctx.shadowColor = '#22c55e';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.moveTo(38, 0);
    ctx.lineTo(50, 0);
    ctx.lineTo(44, -6);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(38, 0);
    ctx.lineTo(50, 0);
    ctx.lineTo(44, 6);
    ctx.closePath();
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}
drawCupidWings() {
}

drawDragonFlame() {
    // Dragon scales
    ctx.save();
    ctx.fillStyle = '#fb923c';
    for (let i = 0; i < 3; i++) {
        ctx.fillRect(this.x + (i * 8), this.y + 2, 6, 6);
    }
    ctx.restore();
}
drawNecroStaff() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Wooden staff handle
    ctx.fillStyle = '#4a2511';
    ctx.fillRect(8, -3, 35, 6);
    
    // Ornate skull top
    ctx.shadowColor = '#a855f7';
    ctx.shadowBlur = 15;
    ctx.fillStyle = '#d8b4fe';
    ctx.beginPath();
    ctx.arc(43, 0, 9, 0, Math.PI * 2);
    ctx.fill();
    
    // Skull eyes (glowing purple)
    ctx.fillStyle = '#7c3aed';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(41, -3, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(45, -3, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Floating purple particles around staff
    if (frameCount % 10 < 5) {
        for (let i = 0; i < 3; i++) {
            const angle = (frameCount * 0.1) + (i * Math.PI * 2 / 3);
            const particleX = 43 + Math.cos(angle) * 12;
            const particleY = Math.sin(angle) * 12;
            ctx.fillStyle = `rgba(168, 85, 247, ${0.3 + Math.random() * 0.4})`;
            ctx.beginPath();
            ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
}
drawMinoVisual() {
    // Normal water gun only - no shark form
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Water gun body
    ctx.fillStyle = '#0ea5e9';
    ctx.fillRect(8, -4, 20, 8);
    
    // Water gun nozzle with glow
    ctx.shadowColor = '#7dd3fc';
    ctx.shadowBlur = this.isSpraying ? 15 : 5;
    ctx.fillStyle = '#7dd3fc';
    ctx.fillRect(28, -3, 6, 6);
    ctx.shadowBlur = 0;
    
    // Water level indicator (glowing)
    if (this.waterTank > 0) {
        const waterPercent = this.waterTank / this.maxWater;
        ctx.fillStyle = `rgba(125, 211, 252, ${0.3 + waterPercent * 0.5})`;
        ctx.fillRect(10, -2, 16 * waterPercent, 4);
    }
    
    // Spraying effect
    if (this.isSpraying && frameCount % 2 === 0) {
        ctx.fillStyle = 'rgba(125, 211, 252, 0.6)';
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(34 + i * 8, (Math.random() - 0.5) * 6, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.restore();
}
drawVoltWhip() {
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    
    // Lightning rod
    ctx.fillStyle = '#facc15';
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 10;
    ctx.fillRect(8, -3, 40, 6);
    
    // Rod tip
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(48, 0, 5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

useTempestDash() {
    if (this.type !== 'volt') return;
    if (this.dashCharges < this.maxDashCharges) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'NOT READY!', '#ff6600', 12));
        return;
    }
    
    // Activate dash
    this.dashCharges = 0;
    this.isDashing = true;
    this.dashTime = 40;
    this.isInvincible = true;
    
    // Calculate direction
    let moveX = Math.cos(this.angle);
    let moveY = Math.sin(this.angle);
    
    this.dashVel = { x: moveX * 18, y: moveY * 18 };
    
    // Visual effects
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 80, 'rgba(250, 204, 21, 0.8)', 'explosion'));
    floatingTexts.push(new FloatingText(this.x, this.y, '‚ö° TEMPEST DASH!', '#facc15', 18));
}
useVoltDash() {
    if (this.type !== 'volt') return;
    if (this.dashCharge < this.dashChargeMax) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'NOT READY!', '#ff6600', 12));
        return;
    }
    
    this.dashCharge = 0;
    this.voltDashKills = 0; // Track kills during dash
    this.isDashing = true;
    this.dashTime = 50; // Shorter dash (was 30)
this.isInvincible = true;

// Dash in facing direction (slightly slower speed)
this.dashVel = {
    x: Math.cos(this.angle) * 5, // Reduced speed (was 18)
    y: Math.sin(this.angle) * 5
};
    
    // Visual trail
    effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 80, 'rgba(250, 204, 21, 0.8)', 'explosion'));
    floatingTexts.push(new FloatingText(this.x, this.y, '‚ö° VOLT DASH!', '#facc15', 18));
    
    // Damage and stun enemies in path
const checkInterval = setInterval(() => {
    if (!this.isDashing) {
        clearInterval(checkInterval);
        return;
    }
    
    // Add blue lightning trail
    effects.push({
        x: this.x + this.w/2,
        y: this.y + this.h/2,
        radius: 25,
        life: 20,
        lifeMax: 20,
        type: 'volt_trail',
        update: function() { this.life--; },
        draw: function() {
            if (this.life <= 0) return;
            const alpha = this.life / this.lifeMax;
            
            ctx.save();
            ctx.fillStyle = `rgba(96, 165, 250, ${alpha * 0.6})`;
            ctx.shadowColor = '#60a5fa';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Electric sparks
            for (let i = 0; i < 4; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * this.radius;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(
                    this.x + Math.cos(angle) * dist,
                    this.y + Math.sin(angle) * dist,
                    2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    });
    
    enemies.forEach(e => {
        const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2), (e.y + e.h/2) - (this.y + this.h/2));
        if (dist < 50 && !e.voltDashHit) {
    e.voltDashHit = true;
    const enemyHP = e.hp;
    hitEnemy(e, 8);
    
    // If enemy died from dash, count it
    if (enemyHP > 0 && e.hp <= 0) {
        this.voltDashKills++;
    }
    
    // Guaranteed stun during dash
    e.isStunned = true;
    e.stunTimer = 90;
    e.originalSpeed = e.speed;
    e.speed = 0;
    floatingTexts.push(new FloatingText(e.x, e.y, '‚ö° ZAP!', '#fbbf24', 14));
}
    });
}, 50);
    
    setTimeout(() => {
        clearInterval(checkInterval);
        
        // Cleanup and check dash kill count
        if (player && player.voltDashKills >= 3) {
            player.dashCharge = player.dashChargeMax;
            player.updateUI();
            floatingTexts.push(new FloatingText(player.x, player.y, `‚ö° ${player.voltDashKills} KILLS! RECHARGED!`, '#00ff00', 20));
            effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 80, 'rgba(0, 255, 0, 0.8)', 'explosion'));
        }
        
        // Reset dash kill counter
        player.voltDashKills = 0;
        
        // Cleanup enemy flags
        enemies.forEach(e => delete e.voltDashHit);
    }, 500);
}
                
                shoot() {
                    if (this.weaponCooldown > 0) return;
                    
                    let weaponType = null;
                    let cooldownFrames = 0;

                    if (this.type === 'mage') {
                        weaponType = 'fireball';
                        cooldownFrames = 60;
}else if (this.type === 'archer') {
    weaponType = 'arrow';
    cooldownFrames = 20;
    
    // Check if ricochet is active - shoot 6 arrows instead of 3
    const arrowCount = this.ricochetShotReady ? 6 : 3;
    const damage = GAME_CONFIG.PROJECTILES.arrow.damage * this.damageMult * 0.45;
    const spreadAngle = Math.PI / 16;
    
    // Create arrows based on count
    const arrows = [];
    
    if (arrowCount === 3) {
        // Normal tri-shot
        arrows.push(new Projectile(this.x, this.y, this.angle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - spreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle + spreadAngle, weaponType, damage));
    } else {
        // Ricochet hexa-shot (6 arrows in a fan)
        const wideSpreadAngle = Math.PI / 12; // Wider spread for 6 arrows
        arrows.push(new Projectile(this.x, this.y, this.angle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - spreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle + spreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - wideSpreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle + wideSpreadAngle, weaponType, damage));
        arrows.push(new Projectile(this.x, this.y, this.angle - (wideSpreadAngle + spreadAngle), weaponType, damage));
    }
    
    // Apply ricochet properties if ready
    if (this.ricochetShotReady) {
        arrows.forEach(arrow => {
            arrow.ricochet = true;
            arrow.pierce = true;
            arrow.lifetime = 300; // 5 seconds
        });
        
        // Used the shot - start cooldown
        this.ricochetShotReady = false;
        this.ricochetCooldown = 1320; // 22 seconds
        floatingTexts.push(new FloatingText(this.x, this.y, 'RICOCHET!', '#16a34a', 14));
    }
    
    // Push all arrows to projectiles
    arrows.forEach(arrow => projectiles.push(arrow));
}
                    else if (this.type === 'ninja') {
    // NINJA SHURIKEN SLANT: Leon-style parallel spread
    weaponType = 'shuriken';
    cooldownFrames = 20;
    
    const damage = GAME_CONFIG.PROJECTILES.shuriken.damage * this.damageMult;
    const offsetDistance = 20; // Distance between parallel shurikens
    
    // Calculate perpendicular offset (90 degrees to aim direction)
    const perpAngle = this.angle + Math.PI / 2;
    const offsetX = Math.cos(perpAngle) * offsetDistance;
    const offsetY = Math.sin(perpAngle) * offsetDistance;
    
    // Shoot 3 parallel shurikens
    projectiles.push(new Projectile(this.x, this.y, this.angle, weaponType, damage)); // Center
    projectiles.push(new Projectile(this.x - offsetX, this.y - offsetY, this.angle, weaponType, damage)); // Top/Left
    projectiles.push(new Projectile(this.x + offsetX, this.y + offsetY, this.angle, weaponType, damage)); // Bottom/Right
}
else if (this.type === 'tempest') {
    // TEMPEST TRIPLE SHOT: Two curved boomerangs + 1 straight center shot
    weaponType = 'boomerang';
    cooldownFrames = 50;
    
    const damage = GAME_CONFIG.PROJECTILES.boomerang.damage * this.damageMult;
    const offsetDistance = 15;
    
    // Calculate perpendicular offset
    const perpAngle = this.angle + Math.PI / 2;
    const offsetX = Math.cos(perpAngle) * offsetDistance;
    const offsetY = Math.sin(perpAngle) * offsetDistance;
    
    // Shoot 2 curved boomerangs on the sides
    const boom1 = new Projectile(this.x + offsetX, this.y + offsetY, this.angle, 'boomerang', damage, 'top');
    const boom2 = new Projectile(this.x - offsetX, this.y - offsetY, this.angle, 'boomerang', damage, 'bottom');
    projectiles.push(boom1);
    projectiles.push(boom2);
    
    // Shoot 1 straight boomerang in the center (no curve)
    const boomCenter = new Projectile(this.x, this.y, this.angle, 'boomerang', damage, 'straight');
    projectiles.push(boomCenter);
    
    // Set weaponType to null so it doesn't create another projectile
    weaponType = null;
}

else if (this.type === 'zap') {
    weaponType = 'lightning';
    cooldownFrames = 20;
    
    // Build charge with each shot (1-5 charge per shot based on accuracy)
    if (!this.chargeCounter) this.chargeCounter = 0;
    this.chargeCounter += 4.09;
    
    const baseDamage = GAME_CONFIG.PROJECTILES.lightning.damage * this.damageMult;
    
    // Check if CHARGED (at 100 charge)
    const isCharged = this.chargeCounter >= 100;
    
    if (isCharged) {
        // CHARGED SHOT: Triple lightning bolts in spread pattern
        const spreadAngles = [this.angle - 0.15, this.angle, this.angle + 0.15];
        spreadAngles.forEach(angle => {
            const bolt = new Projectile(this.x, this.y, angle, 'lightning', baseDamage * 1.5);
            bolt.isCharged = true;
            bolt.color = '#fff'; // White lightning for charged
            projectiles.push(bolt);
        });
        
        floatingTexts.push(new FloatingText(this.x, this.y, 'CHARGED!', '#fbbf24', 18));
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 60, 'rgba(251, 191, 36, 0.8)', 'explosion'));
        
        this.chargeCounter = 0; // Reset charge
    } else {
        // NORMAL SHOT: Single lightning bolt
        const bolt = new Projectile(this.x, this.y, this.angle, 'lightning', baseDamage);
        projectiles.push(bolt);
    }
    
    weaponType = null;
}

else if (this.type === 'unit7') {
    if (this.currentMode === 'laser') {
        // LASER MODE: Powerful piercing shot with cooldown
        if (this.laserCooldown <= 0) {
            weaponType = 'corelaser';
            this.laserCooldown = 680; //  second cooldown ONLY for laser
            
            const laser = new Projectile(this.x, this.y, this.angle, 'corelaser', 
                GAME_CONFIG.PROJECTILES.corelaser.damage * this.damageMult);
            laser.pierce = true;
            laser.color = '#60a5fa';
            laser.w = 16;
            laser.h = 6;
            projectiles.push(laser);
            
            effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 80, 'rgba(96, 165, 250, 0.8)', 'explosion'));
            floatingTexts.push(new FloatingText(this.x, this.y, 'CORE BEAM!', '#60a5fa', 16));
            
            weaponType = null;
        }
    } else {
        // MICRO MODE: Rapid fire burst (NO COOLDOWN, only ammo)
        if (this.microAmmo > 0) {
            weaponType = 'microburst';
            this.microAmmo--;
            
            const micro = new Projectile(this.x, this.y, this.angle, 'microburst',
                GAME_CONFIG.PROJECTILES.microburst.damage * this.damageMult);
            micro.color = '#fbbf24';
            projectiles.push(micro);
            
            // Check if out of ammo
            if (this.microAmmo <= 0) {
                this.microCooldown = 180; // 3 second reload
                floatingTexts.push(new FloatingText(this.x, this.y, 'RELOADING!', '#ff6600', 10));
            }
            
            weaponType = null;
        } else {
            // Still reloading
            this.microCooldown--;
            if (this.microCooldown <= 0) {
                this.microAmmo = this.microMaxAmmo; // Refill ammo
            }
        }
    }
}


else if (this.type === 'cupid') {
    weaponType = 'cupidArrow';
    cooldownFrames = 45;
    
    const arrow = new Projectile(this.x, this.y, this.angle, 'cupidArrow', 
        GAME_CONFIG.PROJECTILES.cupidArrow.damage * this.damageMult * 0.6); // ‚úÖ 40% less damage
    arrow.pierce = true;
    arrow.isCupidArrow = true;
    arrow.color = '#ec4899';
    projectiles.push(arrow);
    
    weaponType = null;
}
else if (this.type === 'dragon') {
    if (!this.breathCooldown) this.breathCooldown = 0;
    
    if (this.breathCooldown <= 0) {
        weaponType = null;
        cooldownFrames = 0;
        this.breathCooldown = 240; // 4 seconds (REDUCED from 5)
        
        // Create 5 piercing flame projectiles in a cone
        for (let i = 0; i < 5; i++) {
            const spreadAngle = (i - 2) * 0.15;
            const flame = new Projectile(this.x, this.y, this.angle + spreadAngle, 'dragonBreath',
                GAME_CONFIG.PROJECTILES.dragonBreath.damage * this.damageMult);
            flame.color = '#fb923c';
            flame.isDragonFlame = true;
            flame.pierce = true; // ADD PIERCE
            flame.lifetime = 25;
            projectiles.push(flame);
        }
        
        floatingTexts.push(new FloatingText(this.x, this.y, 'üî• BREATH!', '#f97316', 14));
    }
}
else if (this.type === 'necromancer') {
    weaponType = 'necroOrb';
    cooldownFrames = 90;  // Very slow (1.5 seconds)
    
    const orb = new Projectile(this.x, this.y, this.angle, 'necroOrb',
        GAME_CONFIG.PROJECTILES.necroOrb.damage * this.damageMult);
    orb.color = '#a855f7';
    orb.w = 14;
    orb.h = 14;
    orb.isNecroOrb = true;
    projectiles.push(orb);
    
    weaponType = null;
}
else if (this.type === 'mino') {
    // Mino only shoots when holding mouse/E and has water
    if (this.shootContinuously && this.waterTank > 0) {
        weaponType = 'waterGun';
        cooldownFrames = 4;
        
        // Deplete water tank
        this.waterTank = Math.max(0, this.waterTank - 0.15);
        this.waterRegenDelay = 120; // 1 second delay before regen starts
        this.updateUI();
        
        // Create water spray projectile
        const waterProj = new Projectile(
            this.x,
            this.y,
            this.angle,
            'waterGun',
            GAME_CONFIG.PROJECTILES.waterGun.damage * this.damageMult
        );
        waterProj.color = '#0ea5e9';
        waterProj.w = 12;
        waterProj.h = 12;
        waterProj.speed = GAME_CONFIG.PROJECTILES.waterGun.speed;
        projectiles.push(waterProj);
        
        // Visual spray effect
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 20, 'rgba(14, 165, 233, 0.6)', 'explosion'));
    } else {
        weaponType = null; // Don't shoot if no water or not holding button
    }
    weaponType = null; // Prevent default projectile creation
}
else if (this.type === 'volt') {
    if (this.rodCooldown > 0) return;
    
    weaponType = null;
    cooldownFrames = 45; // Slower fire rate
this.rodCooldown = 45;

// Create lightning area in front of player
const areaX = this.x + Math.cos(this.angle) * 60;
const areaY = this.y + Math.sin(this.angle) * 60;
const areaRadius = 55; // Wider radius (was 40)
    
    // Visual lightning effect
    effects.push({
        x: areaX,
        y: areaY,
        radius: areaRadius,
        life: 25,
        lifeMax: 25,
        type: 'volt_lightning',
        update: function() { this.life--; },
        draw: function() {
    if (this.life <= 0) return;
    const alpha = this.life / this.lifeMax;
    
    ctx.save();
    
    // Outer blue glow
    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
    gradient.addColorStop(0, `rgba(96, 165, 250, ${alpha * 0.8})`);
    gradient.addColorStop(0.5, `rgba(59, 130, 246, ${alpha * 0.6})`);
    gradient.addColorStop(1, `rgba(37, 99, 235, ${alpha * 0.2})`);
    ctx.fillStyle = gradient;
    ctx.shadowColor = '#60a5fa';
    ctx.shadowBlur = 30;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Electric ring
    ctx.strokeStyle = `rgba(147, 197, 253, ${alpha})`;
    ctx.lineWidth = 4;
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Jagged lightning bolts
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 + (frameCount * 0.1);
        const startX = this.x + Math.cos(angle) * (this.radius * 0.3);
        const startY = this.y + Math.sin(angle) * (this.radius * 0.3);
        
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = '#60a5fa';
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        
        // Create jagged lightning path
        let currX = startX;
        let currY = startY;
        const endX = this.x + Math.cos(angle) * this.radius;
        const endY = this.y + Math.sin(angle) * this.radius;
        const segments = 4;
        
        for (let s = 1; s <= segments; s++) {
            const t = s / segments;
            const targetX = startX + (endX - startX) * t;
            const targetY = startY + (endY - startY) * t;
            const offsetX = (Math.random() - 0.5) * 15;
            const offsetY = (Math.random() - 0.5) * 15;
            
            ctx.lineTo(targetX + offsetX, targetY + offsetY);
        }
        ctx.stroke();
    }
    
    // Center spark
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.shadowBlur = 25;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
}
    });
    
// GUARANTEED HIT - Check every enemy (including bosses)
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e) continue;
        
        const enemyCenterX = e.x + e.w/2;
        const enemyCenterY = e.y + e.h/2;
        const dist = Math.hypot(enemyCenterX - areaX, enemyCenterY - areaY);
        
        // ‚úÖ FIX: Include edge detection for large enemies like bosses
        const enemyRadius = Math.max(e.w, e.h) / 2;
        const effectiveDistance = dist - enemyRadius;
        
        if (effectiveDistance <= areaRadius) {
            hitEnemy(e, 4);
            
            if (Math.random() < 0.10 && !e.isStunned) {
                e.isStunned = true;
                e.stunTimer = 60;
                e.originalSpeed = e.speed;
                e.speed = 0;
                floatingTexts.push(new FloatingText(e.x, e.y, '‚ö° STUNNED!', '#fbbf24', 14));
            }
            
            if (!player.dashCharge) player.dashCharge = 0;
            player.dashCharge = Math.min(player.dashCharge + 15, player.dashChargeMax);
        }
    }

    // PRACTICE MODE: Hit training dummies with Volt lightning
    if (isPracticeMode && trainingDummies.length > 0) {
        trainingDummies.forEach(dummy => {
            if (dummy.isDead) return;
            
            const dummyCenterX = dummy.x + dummy.w/2;
            const dummyCenterY = dummy.y + dummy.h/2;
            const dist = Math.hypot(dummyCenterX - areaX, dummyCenterY - areaY);
            
            if (dist <= areaRadius) {
                dummy.takeDamage(4);
                
                if (Math.random() < 0.10) {
                    floatingTexts.push(new FloatingText(dummy.x, dummy.y, '‚ö° STUNNED!', '#fbbf24', 14));
                }
            }
        });
    }
}

// Single projectile weapons (Mage only now, since Archer, Ninja, and Tempest handle their own)
if (weaponType && weaponType !== 'shuriken' && weaponType !== 'boomerang' && weaponType !== 'arrow') {
    projectiles.push(new Projectile(this.x, this.y, this.angle, weaponType, 
        GAME_CONFIG.PROJECTILES[weaponType].damage * this.damageMult));
}

// KNIGHT SHIELD WAVE ATTACK
if (this.type === 'knight' && this.shieldMode) {
    if (this.shieldWaveCooldown > 0) {
        floatingTexts.push(new FloatingText(this.x, this.y, 'COOLDOWN!', '#ff6600', 12));
        return; // Don't shoot
    }
    
    // Activate shield wave
    this.shieldWaveCooldown = 600; // 10 seconds cooldown
    this.shieldWaveActive = true;
    
    // Create cone effect
    const waveRange = 150;
    const coneAngle = Math.PI / 4; // 45 degrees on each side
    
    // Find and slow enemies in cone
    let hitCount = 0;
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = (e.x + e.w/2) - (this.x + this.w/2);
        const dy = (e.y + e.h/2) - (this.y + this.h/2);
        const dist = Math.hypot(dx, dy);
        
        if (dist < waveRange) {
            const angleToEnemy = Math.atan2(dy, dx);
            let angleDiff = Math.abs(angleToEnemy - this.angle);
            if (angleDiff > Math.PI) angleDiff = 2*Math.PI - angleDiff;
            
            // If enemy is within cone
            if (angleDiff < coneAngle) {
                // Apply slow
                if (!e.shieldSlowed) {
                    e.shieldSlowed = true;
                    e.originalSpeed = e.speed;
                    e.slowTimer = 120; // 2 seconds
                }
                e.speed = e.originalSpeed * 0.65; // 35% slow
                hitCount++;
            }
        }
    }
    
    // Visual effect
    effects.push({
        x: this.x + this.w/2,
        y: this.y + this.h/2,
        angle: this.angle,
        radius: 20,
        maxRadius: waveRange,
        life: 30,
        lifeMax: 30,
        type: 'shield_wave_cone',
        update: function() {
            this.life--;
            this.radius += 5;
        },
        draw: function() {
            if (this.life <= 0) return;
            const alpha = this.life / this.lifeMax;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // Draw cone
            ctx.fillStyle = `rgba(59, 130, 246, ${alpha * 0.4})`;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.radius, -Math.PI/4, Math.PI/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = `rgba(59, 130, 246, ${alpha * 0.8})`;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.restore();
        }
    });
    
    floatingTexts.push(new FloatingText(this.x, this.y, 'SHIELD WAVE!', '#3b82f6', 14));
    if (hitCount > 0) {
        floatingTexts.push(new FloatingText(this.x, this.y - 20, `HIT ${hitCount}!`, '#fbbf24', 12));
    }
    
    cooldownFrames = 0; // Don't apply normal cooldown
    return; // Exit shoot function
}
// ‚úÖ FIX: Knight sword hitting practice dummies
                if (this.type === 'knight' && !this.shieldMode && isPracticeMode && trainingDummies.length > 0) {
                    trainingDummies.forEach(dummy => {
                        if (dummy.isDead) return;
                        
                        const damage = GAME_CONFIG.PROJECTILES.sword.damage * this.damageMult;
                        
                        // Check blade collision with dummy
                        let hitDetected = false;
                        for (let t = 0; t <= 1; t += 0.1) {
                            const bladeX = this.x + this.w/2 + Math.cos(this.angle) * (this.swordLength * t);
                            const bladeY = this.y + this.h/2 + Math.sin(this.angle) * (this.swordLength * t);
                            
                            if (bladeX > dummy.x && bladeX < dummy.x + dummy.w && 
                                bladeY > dummy.y && bladeY < dummy.y + dummy.h) {
                                hitDetected = true;
                                break;
                            }
                        }
                        
                        // Also check if dummy is in front arc
                        const dx = (dummy.x + dummy.w/2) - (this.x + this.w/2);
                        const dy = (dummy.y + dummy.h/2) - (this.y + this.h/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < this.swordLength + 30) {
                            const angleToEnemy = Math.atan2(dy, dx);
                            let diff = Math.abs(angleToEnemy - this.angle);
                            if (diff > Math.PI) diff = 2*Math.PI - diff;
                            if (diff < Math.PI/2) {
                                hitDetected = true;
                            }
                        }
                        
                        if (hitDetected) {
                            dummy.takeDamage(damage);
                        }
                    });
                }

                 // Knight melee attack
if (this.type === 'knight') {
    // ‚úÖ FIX: Only attack if NOT in shield mode
    if (!this.shieldMode) {
        cooldownFrames = 70;
        this.isSlashing = true;
        this.slashTimer = 15; 
        
        const damage = GAME_CONFIG.PROJECTILES.sword.damage * this.damageMult;
        
        // Check collision along entire sword blade
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            
            // Check multiple points along the sword blade
            let hitDetected = false;
            for (let t = 0; t <= 1; t += 0.1) {
                const bladeX = this.x + this.w/2 + Math.cos(this.angle) * (this.swordLength * t);
                const bladeY = this.y + this.h/2 + Math.sin(this.angle) * (this.swordLength * t);
                
                // Check if this point on the blade overlaps enemy
                if (bladeX > e.x && bladeX < e.x + e.w && 
                    bladeY > e.y && bladeY < e.y + e.h) {
                    hitDetected = true;
                    break;
                }
            }
            
            // Also check if enemy is in front arc (backup check)
            const dx = (e.x + e.w/2) - (this.x + this.w/2);
            const dy = (e.y + e.h/2) - (this.y + this.h/2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < this.swordLength + 30) {
                const angleToEnemy = Math.atan2(dy, dx);
                let diff = Math.abs(angleToEnemy - this.angle);
                if (diff > Math.PI) diff = 2*Math.PI - diff;
                if (diff < Math.PI/2) {
                    hitDetected = true;
                }
            }
            
            if (hitDetected) {
                hitEnemy(e, damage);
            }
        }
    }
}
                    
                    // Apply cooldown for all weapons EXCEPT Unit-7 (handles its own)
if (cooldownFrames > 0 && this.type !== 'unit7') {
    this.weaponCooldown = cooldownFrames / this.fireRateMult;
}
                }
            }

            class TrainingDummy {
    constructor(x, y, maxHp = 300, size = 80) {
        this.x = x;
        this.y = y;
        this.w = size;
        this.h = size;
        this.maxHp = maxHp;
        this.hp = this.maxHp;
        this.respawnTimer = 0;
        this.isDead = false;
    }
    
    takeDamage(amt) {
        if (this.isDead) return;
        this.hp -= amt;
        floatingTexts.push(new FloatingText(this.x, this.y, Math.round(amt), '#fff', 14));
        
        if (this.hp <= 0) {
            this.isDead = true;
            this.respawnTimer = 480; // 8 seconds
            floatingTexts.push(new FloatingText(this.x, this.y, 'DESTROYED!', '#ff0000', 20));
            effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 100, 'rgba(255, 0, 0, 0.8)', 'explosion'));
        }
    }
    
    update() {
        if (this.isDead) {
            this.respawnTimer--;
            if (this.respawnTimer <= 0) {
                this.hp = this.maxHp;
                this.isDead = false;
                floatingTexts.push(new FloatingText(this.x, this.y, 'RESPAWNED!', '#00ff00', 18));
                effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 80, 'rgba(0, 255, 0, 0.6)', 'explosion'));
            }
        }
    }
    
    draw() {
        if (this.isDead) {
            // Show respawn timer
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '20px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.ceil(this.respawnTimer/60)}`, this.x + this.w/2, this.y + this.h/2);
            ctx.textAlign = 'left';
            return;
        }
        
        // Detailed robot dummy design
        ctx.save();
        
        // Main body (metallic gray)
        const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.w, this.y + this.h);
        gradient.addColorStop(0, '#4a5568');
        gradient.addColorStop(0.5, '#718096');
        gradient.addColorStop(1, '#2d3748');
        ctx.fillStyle = gradient;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        // Armor plates
        ctx.fillStyle = '#1a202c';
        ctx.fillRect(this.x + 10, this.y + 10, this.w - 20, 8);
        ctx.fillRect(this.x + 10, this.y + 30, this.w - 20, 8);
        ctx.fillRect(this.x + 10, this.y + 50, this.w - 20, 8);
        
        // Only draw decorations for large dummies (size >= 60)
if (this.w >= 60) {
    // Glowing core (pulsing)
    const pulseAlpha = 0.6 + Math.sin(frameCount * 0.1) * 0.4;
    ctx.fillStyle = `rgba(0, 255, 255, ${pulseAlpha})`;
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Inner bright core
    ctx.fillStyle = '#93c5fd';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(this.x + this.w/2, this.y + this.h/2, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Eyes (red glowing)
    ctx.fillStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(this.x + 25, this.y + 20, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(this.x + 55, this.y + 20, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
}
        
        // Border
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        
        ctx.restore();
        
        // HP Bar
        const barWidth = this.w;
        const barY = this.y - 15;
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x - 2, barY - 2, barWidth + 4, 12);
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(this.x, barY, barWidth * (this.hp / this.maxHp), 8);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - 2, barY - 2, barWidth + 4, 12);
        
        // HP Text
        ctx.fillStyle = '#fff';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.floor(this.hp)}/${this.maxHp}`, this.x + this.w/2, this.y - 20);
        ctx.textAlign = 'left';
    }
}
            
            class Enemy {
                constructor(x, y, type, difficultyMult) {
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.pushbackX = 0;
                    this.pushbackY = 0;
                    
                    const stats = GAME_CONFIG.ENEMIES[type];
                    
                    this.w = stats.size;
                    this.h = stats.size;
                    this.color = stats.color;
                    this.xpValue = stats.xp;
                    this.speed = stats.speed;
                    this.hp = stats.hp;
                    this.maxHp = this.hp;

                    // Ranger enemy properties
if (type === 'ranger') {
    this.shootCooldown = 0;
    this.shootRange = stats.shootRange;
    this.shootCooldownMax = stats.shootCooldown;
}
                    
                    // Elite enemy properties
                    this.isElite = type.startsWith('elite_');
                    if (this.isElite) {
                        this.ability = stats.ability;
                        this.abilityCooldown = stats.abilityCooldown || 0;
                        this.abilityTimer = this.abilityCooldown;
                        this.isPhasing = false;
                        this.phaseTimer = 0;
                        this.isShielded = false;
                        this.shieldTimer = 0;
                        this.splitCount = stats.splitCount || 0;
                        this.glowPhase = 0;
                    }
 }
                
                draw() {
                    this.x += this.pushbackX;
                    this.y += this.pushbackY;
                    this.pushbackX *= 0.8;
                    this.pushbackY *= 0.8;

// ELITE ENEMY RENDERING
if (this.isElite) {
    this.glowPhase += 0.1;
    const glowIntensity = Math.sin(this.glowPhase) * 0.3 + 0.7;
    
    // Elite glow aura
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 15 * glowIntensity;
    
    // Phasing Specter
    if (this.type === 'elite_specter') {
        if (this.isPhasing) {
            ctx.globalAlpha = 0.3;
            ctx.shadowBlur = 25;
        }
        
        // Specter body with trail effect
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y + this.h/2, this.w/2, 0, Math.PI * 2);
        ctx.fill();
        
        // Ghost eyes
        ctx.fillStyle = '#ffffff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x + this.w/2 - 6, this.y + this.h/2 - 4, 4, 0, Math.PI * 2);
        ctx.arc(this.x + this.w/2 + 6, this.y + this.h/2 - 4, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Purple energy wisps
        for (let i = 0; i < 3; i++) {
            const angle = this.glowPhase + (i * Math.PI * 2 / 3);
            const wispX = this.x + this.w/2 + Math.cos(angle) * 20;
            const wispY = this.y + this.h/2 + Math.sin(angle) * 20;
            ctx.fillStyle = `rgba(147, 51, 234, ${0.4 * glowIntensity})`;
            ctx.beginPath();
            ctx.arc(wispX, wispY, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
    }
    
    // Tank with Shield
    else if (this.type === 'elite_tank') {
        // Tank body
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        // Armor plates
        ctx.fillStyle = '#1e3a8a';
        const plateSize = 8;
        for (let py = 0; py < this.h; py += plateSize + 2) {
            for (let px = 0; px < this.w; px += plateSize + 2) {
                ctx.fillRect(this.x + px, this.y + py, plateSize, plateSize);
            }
        }
        
        // Shield effect when active
        if (this.isShielded) {
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#60a5fa';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y + this.h/2, this.w/2 + 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Hexagonal shield pattern
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI / 3) + this.glowPhase;
                const x = this.x + this.w/2 + Math.cos(angle) * (this.w/2 + 6);
                const y = this.y + this.h/2 + Math.sin(angle) * (this.w/2 + 6);
                ctx.fillStyle = `rgba(96, 165, 250, ${0.6 * glowIntensity})`;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.lineWidth = 1;
    }
    
    // Splitter
    else if (this.type === 'elite_splitter') {
        // Main body with segmented appearance
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        // Segmentation lines
        ctx.strokeStyle = '#052e16';
        ctx.lineWidth = 2;
        const segments = 3;
        for (let i = 1; i < segments; i++) {
            const segY = this.y + (this.h / segments) * i;
            ctx.beginPath();
            ctx.moveTo(this.x, segY);
            ctx.lineTo(this.x + this.w, segY);
            ctx.stroke();
        }
        
        // Pulsing core
        const coreSize = 6 + Math.sin(this.glowPhase * 2) * 2;
        ctx.fillStyle = '#22c55e';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#22c55e';
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y + this.h/2, coreSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    
    // Health bar for elites
    if (this.hp < this.maxHp) {
        const barY = this.y - 12;
        ctx.fillStyle = '#000';
        ctx.fillRect(this.x - 2, barY, this.w + 4, 8);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, barY + 1, (this.w * (this.hp/this.maxHp)), 6);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 1;
        ctx.strokeRect(this.x - 2, barY, this.w + 4, 8);
    }
    
    return;
}

// BOSS RENDERING
if (this.isBoss) {
    // Expanded hitbox (easier to hit)

     {
        // Wave 15+ = Dark red menacing boss
        if (wave >= 5) {
            ctx.fillStyle = '#000';
            ctx.shadowColor = '#dc2626';
            ctx.shadowBlur = 40;
            ctx.fillRect(this.x - 6, this.y - 6, this.w + 12, this.h + 12);
            
            // Dark red body with glowing veins
            ctx.fillStyle = '#7f1d1d';
            ctx.shadowBlur = 25;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            // Glowing red veins
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#dc2626';
            for(let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + (i * 16));
                ctx.lineTo(this.x + this.w, this.y + (i * 16) + 8);
                ctx.stroke();
            }
            
            // Red glowing eyes
            ctx.fillStyle = '#ff0000';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(this.x + 30, this.y + 30, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.x + 70, this.y + 30, 8, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Normal purple boss (waves 5-10)
            ctx.fillStyle = '#000';
            ctx.shadowColor = '#a855f7';
            ctx.shadowBlur = 30;
            ctx.fillRect(this.x - 4, this.y - 4, this.w + 8, this.h + 8);
            
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 20;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 0;
            for(let i = 0; i < 5; i++) {
                ctx.fillRect(this.x, this.y + (i * 20), this.w, 8);
            }
        }
    }
    
    // Boss health bar at top of screen
    const barWidth = canvas.width * 0.6;
    const barX = canvas.width * 0.2;
    const barY = 20;
    
    ctx.fillStyle = '#000';
    ctx.fillRect(barX - 2, barY - 2, barWidth + 4, 24);
    
    ctx.fillStyle = saveData.christmasMode ? '#dc2626' : '#581c87';
    ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), 20);
    
    ctx.strokeStyle = saveData.christmasMode ? '#ff0000' : '#a855f7';
    ctx.lineWidth = 3;
    ctx.strokeRect(barX, barY, barWidth, 20);
    
    ctx.fillStyle = '#fff';
    ctx.font = '12px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(saveData.christmasMode ? 'EVIL SANTA' : 'BOSS', canvas.width / 2, barY - 8);
    ctx.textAlign = 'left';
    
    ctx.shadowBlur = 0;
    return;
}
// Apply map tint to enemies
let enemyColor = this.color;
if (currentMap && GAME_CONFIG.MAPS[currentMap].enemyTint) {
    const tint = GAME_CONFIG.MAPS[currentMap].enemyTint;
    // Blend enemy color with map tint
    enemyColor = this.color;
}
ctx.fillStyle = enemyColor;
ctx.shadowColor = 'black';
ctx.shadowBlur = 5;
if (this.type === 'frosty') {
    ctx.beginPath();
    ctx.moveTo(this.x + this.w/2, this.y);
    ctx.lineTo(this.x + this.w, this.y + this.h/2);
    ctx.lineTo(this.x + this.w/2, this.y + this.h);
    ctx.lineTo(this.x, this.y + this.h/2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(this.x + this.w/2, this.y+8);
    ctx.lineTo(this.x + this.w-8, this.y + this.h/2);
    ctx.lineTo(this.x + this.w/2, this.y + this.h-8);
    ctx.lineTo(this.x+8, this.y + this.h/2);
    ctx.fill();
} else {
    ctx.fillRect(this.x, this.y, this.w, this.h);
    if(this.type === 'brute') {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(this.x+5, this.y+5, this.w-10, this.h-10);
    }
}

// Ranger indicator
if (this.type === 'ranger') {
    ctx.fillStyle = '#eab308';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#eab308';
    ctx.fillRect(this.x, this.y, this.w, this.h);
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x + 8, this.y + 8, 8, 8);
    ctx.shadowBlur = 0;
}

// FIXED: Health bar for ALL enemy types (including frosty)
if (this.hp < this.maxHp) {
    ctx.fillStyle = 'black';
    ctx.fillRect(this.x, this.y - 10, this.w, 6);
    ctx.fillStyle = this.type === 'frosty' ? '#06b6d4' : '#0f0'; // Cyan for frosty
    ctx.fillRect(this.x + 1, this.y - 9, (this.w - 2) * (this.hp/this.maxHp), 4);
}
                    ctx.shadowBlur = 0;
}
                
update() {

    // Handle stun
    if (this.isStunned && this.stunTimer !== undefined) {
        this.stunTimer--;
        if (this.stunTimer <= 0) {
            this.isStunned = false;
            this.speed = this.originalSpeed;
        }
        // Draw stars around stunned enemy
        if (frameCount % 10 === 0) {
            for (let i = 0; i < 3; i++) {
                const angle = (frameCount * 0.1) + (i * Math.PI * 2 / 3);
                const starX = this.x + this.w/2 + Math.cos(angle) * 30;
                const starY = this.y + this.h/2 + Math.sin(angle) * 30;
                floatingTexts.push(new FloatingText(starX, starY, '‚≠ê', '#fbbf24', 12));
            }
        }
    }

// Handle shield slow timer
    if (this.slowTimer !== undefined && this.slowTimer > 0) {
        this.slowTimer--;
        if (this.slowTimer <= 0 && this.shieldSlowed) {
            this.speed = this.originalSpeed;
            this.shieldSlowed = false;
            delete this.slowTimer; // Clean up
        }
    }
    // Handle necro slow timer
if (this.necroSlowed && this.slowTimer !== undefined) {
    this.slowTimer--;
    if (this.slowTimer <= 0) {
        this.speed = this.originalSpeed;
        this.necroSlowed = false;
    }
}
   
    
    // Elite ability logic
    if (this.isElite) {
                        this.abilityTimer--;
                        
                        // Specter Phase ability
                        if (this.type === 'elite_specter') {
                            if (this.isPhasing) {
                                this.phaseTimer--;
                                if (this.phaseTimer <= 0) {
                                    this.isPhasing = false;
                                }
                            } else if (this.abilityTimer <= 0) {
                                this.isPhasing = true;
                                this.phaseTimer = 60; // 1 second of phasing
                                this.abilityTimer = this.abilityCooldown;
                                effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 40, 'rgba(147, 51, 234, A)', 'explosion'));
                            }
                        }
                        
                        // Tank Shield ability
                        if (this.type === 'elite_tank') {
                            if (this.isShielded) {
                                this.shieldTimer--;
                                if (this.shieldTimer <= 0) {
                                    this.isShielded = false;
                                }
                            } else if (this.abilityTimer <= 0 && this.hp < this.maxHp * 0.7) {
                                this.isShielded = true;
                                this.shieldTimer = 120; // 2 seconds of shield
                                this.abilityTimer = this.abilityCooldown;
                                effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 50, 'rgba(96, 165, 250, A)', 'explosion'));
                            }
                        }
                    }

                    // Ranger shooting logic (BUFFED)
if (this.type === 'ranger' && player) {
    const dist = Math.hypot((player.x + player.w/2) - (this.x + this.w/2), 
                            (player.y + player.h/2) - (this.y + this.h/2));
    
    if (dist < this.shootRange) {
        this.shootCooldown--;
        if (this.shootCooldown <= 0) {
            const angle = Math.atan2((player.y + player.h/2) - (this.y + this.h/2), 
                                    (player.x + player.w/2) - (this.x + this.w/2));
            const stats = GAME_CONFIG.ENEMIES.ranger;
            const enemyProj = new Projectile(this.x + this.w/2, this.y + this.h/2, angle, 'turret', stats.projectileDamage);
            enemyProj.color = '#eab308';
            enemyProj.w = stats.projectileSize;
            enemyProj.h = stats.projectileSize;
            enemyProj.speed = stats.projectileSpeed;
            enemyProj.isEnemyProjectile = true;
            projectiles.push(enemyProj);
            effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 20, 'rgba(234, 179, 8, 0.6)', 'explosion'));
            this.shootCooldown = this.shootCooldownMax;
        }
    }
}
                    
                
                    let speed = this.speed;
                    for (const effect of effects) {
                        if (effect.type === 'ice_field') {
                            const dist = Math.hypot((this.x+this.w/2)-effect.x, (this.y+this.h/2)-effect.y);
                            if (dist < effect.radius) speed *= 0.4;
                        }
                    }
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                   const dist = Math.sqrt(dx*dx + dy*dy);

// BOSS ENRAGE: Speed increases at 50% HP
if (this.isBoss && this.hp < this.maxHp * 0.5) {
    speed *= 1.5; // 50% faster when below half HP
    
    // Visual warning effect (only once)
    if (!this.hasEnraged) {
        this.hasEnraged = true;
        floatingTexts.push(new FloatingText(this.x, this.y, 'ENRAGED!', '#ff0000', 24));
        effects.push(new Effect(this.x + this.w/2, this.y + this.h/2, 150, 'rgba(255, 0, 0, 0.8)', 'explosion'));
    }
}
// BOSS ENRAGE: Create expanding fire ring that burns players (ONCE ONLY)
if (this.isBoss && this.hp < this.maxHp * 0.5 && !this.hasSpawnedFireRing) {
    this.hasSpawnedFireRing = true; // Mark as spawned
    
    // Create expanding fire ring effect (DECAYS AFTER 15 SECONDS)
    effects.push({
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 0,
        maxRadius: Math.min(canvas.width, canvas.height) / 2 - 20,
        life: 900, // 15 seconds at 60fps
        lifeMax: 900,
        damage: 2,
        type: 'boss_fire_ring',
        update: function() {
            this.life--;
            if (this.radius < this.maxRadius) {
                this.radius += 8;
            }
            
            // Only burn if fire ring exists
            if (this.life <= 0) return;
            
            // Burn player if outside safe zone
            if (player && player.hp > 0) {
                const distFromCenter = Math.hypot(
                    (player.x + player.w/2) - this.x,
                    (player.y + player.h/2) - this.y
                );
                
                if (distFromCenter > this.radius && frameCount % 15 === 0) {
                    player.hp -= this.damage;
                    floatingTexts.push(new FloatingText(player.x, player.y, 'üî• BURN!', '#ff6600', 14));
                    effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 30, 'rgba(255, 100, 0, 0.6)', 'explosion'));
                    player.updateUI();
                    
                    if (player.hp <= 0) {
                        endGame();
                    }
                }
            }
        },
        draw: function() {
            if (this.life <= 0) return;
            
            const alpha = Math.min(0.8, this.life / this.lifeMax);
            
            // FIXED: Prevent negative radius
            const drawRadius = Math.max(0, this.radius);
            
            // Draw fire ring at edge
            ctx.save();
            ctx.strokeStyle = `rgba(255, 100, 0, ${alpha})`;
            ctx.lineWidth = 30;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 40;
            ctx.beginPath();
            ctx.arc(this.x, this.y, drawRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner glow
            if (drawRadius >= 10) {
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha * 0.6})`;
                ctx.lineWidth = 15;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.x, this.y, drawRadius - 10, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Flame particles
            if (frameCount % 3 === 0 && drawRadius > 0) {
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const flameX = this.x + Math.cos(angle) * drawRadius;
                    const flameY = this.y + Math.sin(angle) * drawRadius;
                    const flicker = Math.random() * 10 - 5;
                    
                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(flameX + flicker, flameY + flicker, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    });
    
    floatingTexts.push(new FloatingText(canvas.width/2 - 80, 100, 'üî• FIRE RING!', '#ff6600', 24));
}

if (dist > 0) {
    this.x += (dx/dist) * speed;
    this.y += (dy/dist) * speed;
}
                    this.draw();
                }
                takeDamage(amt) {
                    this.hp -= amt;
                    this.pushbackX = (Math.random() - 0.5) * 6;
                    this.pushbackY = (Math.random() - 0.5) * 6;
                    floatingTexts.push(new FloatingText(this.x, this.y, Math.round(amt), '#fff'));
                    if (this.hp <= 0) return true;
                    return false;
                }
            }
            
            class Projectile {
    constructor(x, y, angle, type, damage, curveDirection = null) {
        this.x = x + GAME_CONFIG.PLAYER.BASE_SIZE/2;
        this.y = y + GAME_CONFIG.PLAYER.BASE_SIZE/2;
        this.type = type;
        this.angle = angle;
        this.damage = damage;
        this.curveDirection = curveDirection; // 'top' or 'bottom' for boomerangs
        this.distanceTraveled = 0;
                    
                    const stats = GAME_CONFIG.PROJECTILES[type];
                    this.w = stats.size;
                    this.h = stats.size;
                    this.speed = stats.speed;
                    this.knockback = stats.knockback || 0;
                    this.knockback = stats.knockback || 0;
                    
                    // Ricochet properties
                    this.ricochet = false;
                    this.pierce = false;
                    this.lifetime = null;
                    this.bounceCount = 0;
                    this.maxBounces = 8;
                    
                    if (type === 'fireball') { this.color = '#f97316'; }
                    
                    if (type === 'fireball') { this.color = '#f97316'; }
                    else if (type === 'turret') { this.color = '#fbbf24'; }
                    else if (type === 'arrow') { this.color = '#a3e635'; this.w = 8; this.h = 20; }
                    else if (type === 'shuriken') { this.color = '#fff'; this.w = 12; this.h = 12; } // White for shuriken
            
else if (type === 'boomerang') { 
    this.color = '#6dd5ed'; 
    this.w = 16; 
    this.h = 16; 
    this.curveCount = 0; // Track how much it's curved for bonus damage
    this.lifetimeFrames = 0; // Track how long it's been alive (renamed to avoid conflict)
    this.curveDirection = curveDirection; // Store the curve direction
}

else if (type === 'lightning') {
    this.color = '#fbbf24';
    this.w = 10;
    this.h = 10;
}

                }
              draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    
    // PIERCING GLOW - Show when piercing is active
    if (player && player.upgrades.piercingShots > 0) {
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 15;
    }
    
    if (this.type === 'shuriken') {
        ctx.rotate(this.angle + (frameCount * 0.3));
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(0, -this.h/2);
        ctx.lineTo(this.w/2, 0);
        ctx.lineTo(0, this.h/2);
        ctx.lineTo(-this.w/2, 0);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(0,0,2,0,Math.PI*2);
        ctx.fill();
    } 
    else if (this.type === 'turret') {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0,0,4,0,Math.PI*2);
        ctx.fill();
    } 
    else if (this.type === 'boomerang') {
        ctx.rotate(this.angle + (frameCount * 0.2));
        ctx.strokeStyle = '#6dd5ed';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#6dd5ed';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, 0, 8, Math.PI, Math.PI * 2);
        ctx.stroke();
    } 
    else if (this.type === 'lightning') {
        ctx.rotate(this.angle);
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = this.isOverload ? 25 : 15;
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = this.isOverload ? 6 : 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'miter';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(12, -4);
        ctx.lineTo(8, 0);
        ctx.lineTo(20, -2);
        ctx.lineTo(14, 2);
        ctx.lineTo(24, 0);
        ctx.lineTo(16, 4);
        ctx.lineTo(28, 3);
        ctx.stroke();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = this.isOverload ? 3 : 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(12, -4);
        ctx.lineTo(8, 0);
        ctx.lineTo(20, -2);
        ctx.lineTo(14, 2);
        ctx.lineTo(24, 0);
        ctx.lineTo(16, 4);
        ctx.lineTo(28, 3);
        ctx.stroke();
        if (Math.random() < 0.3) {
            for (let i = 0; i < 3; i++) {
                const sparkX = Math.random() * 28;
                const sparkY = (Math.random() - 0.5) * 8;
                ctx.fillStyle = this.isOverload ? '#fff' : '#fbbf24';
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, Math.random() * 2 + 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    } 
    else {
        ctx.rotate(this.angle + Math.PI/2);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
    }
    
    ctx.restore();
}
             update() {
// Boomerang curving logic
if (this.type === 'boomerang') {
    this.lifetimeFrames++;
    this.distanceTraveled += this.speed;
    
    // SHORTER LIFESPAN: Disappear after 180 frames (3 seconds)
    if (this.lifetimeFrames > 180) {
        return true; // Signal for removal
    }
    
    // Start curving after traveling 80 pixels (EXCEPT for straight shots)
    if (this.distanceTraveled > 80 && this.curveDirection !== 'straight') {
        const curveRate = GAME_CONFIG.PROJECTILES.boomerang.curveRate;
        if (this.curveDirection === 'top') {
            this.angle -= curveRate; // Curve outward (up)
            this.curveCount += curveRate; // Track curving
        } else if (this.curveDirection === 'bottom') {
            this.angle += curveRate; // Curve outward (down)
            this.curveCount += curveRate; // Track curving
        }
            // BONUS DAMAGE: More curve = more damage
            const bonusDamage = this.curveCount * GAME_CONFIG.PROJECTILES.boomerang.bonusDamagePerCurve;
            this.currentDamage = this.damage + bonusDamage;
        } else {
            this.currentDamage = this.damage;
        }
    }
    
    // Handle ricochet lifetime
    if (this.lifetime !== null) {
        this.lifetime--;
        if (this.lifetime <= 0) {
            return true; // Remove arrow
        }
    }
    
    // Move projectile
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
    
    // RICOCHET OFF WALLS
    if (this.ricochet && this.bounceCount < this.maxBounces) {
        let bounced = false;
        
        // Check canvas boundaries
        if (this.x < 0 || this.x > canvas.width) {
            this.angle = Math.PI - this.angle; // Reflect horizontally
            this.x = Math.max(0, Math.min(canvas.width, this.x));
            bounced = true;
        }
        if (this.y < 0 || this.y > canvas.height) {
            this.angle = -this.angle; // Reflect vertically
            this.y = Math.max(0, Math.min(canvas.height, this.y));
            bounced = true;
        }
        
        if (bounced) {
            this.bounceCount++;
            effects.push(new Effect(this.x, this.y, 15, 'rgba(22, 163, 74, A)', 'explosion'));
        }
    }
    
    this.draw();
}
            }
            
           class Effect {
    constructor(x, y, radius, color, type) {
        this.x = x; this.y = y; this.type = type;
        this.maxRadius = radius; this.color = color;
        if (type === 'explosion') {
            this.radius = 10; this.life = 15; this.lifeMax = 15;
        } else if (type === 'expanding_wind_wave') {
            this.radius = 30;
            this.life = 60;
            this.lifeMax = 60;
            this.expandSpeed = 15;
        } else if (type === 'trail') {
            this.radius = radius;
            this.life = 20; // Short-lived trail
            this.lifeMax = 20;
        } else {
            this.radius = radius; this.life = 180; this.lifeMax = 180;
        }
    }
              update() {
    if (this.type === 'explosion') {
        this.radius += (this.maxRadius - this.radius) * 0.2;
    } else if (this.type === 'expanding_wind_wave') {
        this.radius += this.expandSpeed;
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dist = Math.hypot((e.x + e.w/2) - this.x, (e.y + e.h/2) - this.y);
            
            const waveThickness = 40;
            if (dist >= this.radius - waveThickness && dist <= this.radius + waveThickness) {
                if (!e.hitByWave || e.hitByWave !== this) {
                    hitEnemy(e, 5);
                    e.hitByWave = this;
                    
                    const angle = Math.atan2((e.y + e.h/2) - this.y, (e.x + e.w/2) - this.x);
                    e.pushbackX = Math.cos(angle) * 25;
                    e.pushbackY = Math.sin(angle) * 25;
                }
            }
        }
} else if (this.type === 'poison') {
    // Poison clouds damage enemies inside - FIXED (moved from enemy update)
    if (frameCount % 30 === 0 && player && player.upgrades.poisonTrail > 0) {
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if (!e) continue; // Safety check
            const dist = Math.hypot((e.x + e.w/2) - this.x, (e.y + e.h/2) - this.y);
            if (dist < this.radius) {
                hitEnemy(e, 0.8 * player.upgrades.poisonTrail);
                floatingTexts.push(new FloatingText(e.x, e.y, '‚ò†Ô∏è', '#22c55e', 10));
            }
        }
    }
}

else if (this.type === 'shield_wave') {
    // Shield wave slows enemies in cone
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e) continue;
        
        // Check if enemy is in cone range
        const dx = (e.x + e.w/2) - this.x;
        const dy = (e.y + e.h/2) - this.y;
        const dist = Math.hypot(dx, dy);
        const angleToEnemy = Math.atan2(dy, dx);
        
        let angleDiff = Math.abs(angleToEnemy - this.angle);
        if (angleDiff > Math.PI) angleDiff = 2*Math.PI - angleDiff;
        
       // If within cone and range, apply slow
if (dist < this.radius && angleDiff < Math.PI/4) {
    if (!e.shieldSlowed) {
        e.shieldSlowed = true;
        e.originalSpeed = e.speed;
    }
    e.speed = e.originalSpeed * 0.2; // 80% slow (even stronger)
e.slowDuration = 240; // 4 seconds instead of 2
} else if (e.shieldSlowed) {
    e.speed = e.originalSpeed;
    e.shieldSlowed = false;
}
    }
}


    this.life--;
}


                                draw() {
                    const alpha = (this.life / this.lifeMax) * (this.type === 'explosion' ? 0.8 : 0.3);
                    ctx.save();
                    ctx.fillStyle = this.color.replace('A', alpha);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                    ctx.fill();
                    if (this.type === 'ice_field') {
                        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        if (Math.random() < 0.2) {
                            ctx.fillStyle = 'white';
                            const rx = (Math.random() - 0.5) * this.radius * 1.5;
                            const ry = (Math.random() - 0.5) * this.radius * 1.5;
                            ctx.fillRect(this.x + rx, this.y + ry, 2, 2);
                        }
                    }
                    if (this.type === 'wind_wave') {
        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
        ctx.lineWidth = 4;
        ctx.stroke();
        // Add swirl lines
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius - (i * 15), 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.5})`;
            ctx.stroke();
        }
    }

   if (this.type === 'poison') {
        // Green toxic cloud with animated bubbles
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
        gradient.addColorStop(0, `rgba(34, 197, 94, ${alpha * 0.7})`);
        gradient.addColorStop(0.5, `rgba(22, 163, 74, ${alpha * 0.5})`);
        gradient.addColorStop(1, `rgba(21, 128, 61, ${alpha * 0.2})`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Animated poison bubbles
        if (Math.random() < 0.4) {
            for (let i = 0; i < 3; i++) {
                const angle = (frameCount * 0.05 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                const bubbleX = this.x + Math.cos(angle) * (this.radius * 0.6);
                const bubbleY = this.y + Math.sin(angle) * (this.radius * 0.6);
                const bubbleSize = 3 + Math.sin(frameCount * 0.1 + i) * 2;
                
                ctx.fillStyle = `rgba(134, 239, 172, ${alpha * 0.9})`;
                ctx.shadowColor = '#22c55e';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        }
    }

    ctx.restore();
                }
            }

            
        

            // --- CORE FUNCTIONS ---
            // --- CORE FUNCTIONS ---

            function generateMapObjects(mapType) {
    mapObjects = [];
    const mapData = GAME_CONFIG.MAPS[mapType];
    
    if (mapType === 'forest') {
        // Generate trees
        for (let i = 0; i < mapData.treeCount; i++) {
            mapObjects.push({
                type: 'tree',
                x: Math.random() * (canvas.width - 60) + 30,
                y: Math.random() * (canvas.height - 60) + 30,
                size: 20 + Math.random() * 20,
                sway: Math.random() * Math.PI * 2,
                draw: function() {
                    this.sway += 0.02;
                    const swayOffset = Math.sin(this.sway) * 3;
                    
                    // Tree trunk
                    ctx.fillStyle = '#3d2817';
                    ctx.fillRect(this.x - 5 + swayOffset, this.y, 10, this.size);
                    
                    // Tree crown
                    ctx.fillStyle = '#1a5c1a';
                    ctx.shadowColor = '#0a3d0a';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x + swayOffset, this.y - 10, this.size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Highlights
                    ctx.fillStyle = '#2d7c2d';
                    ctx.beginPath();
                    ctx.arc(this.x - 8 + swayOffset, this.y - 15, this.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    
    if (mapType === 'desert') {
        // Generate cacti
        for (let i = 0; i < mapData.cactusCount; i++) {
            mapObjects.push({
                type: 'cactus',
                x: Math.random() * (canvas.width - 40) + 20,
                y: Math.random() * (canvas.height - 40) + 20,
                height: 30 + Math.random() * 20,
                draw: function() {
                    // Cactus body
                    ctx.fillStyle = '#2d6b2d';
                    ctx.fillRect(this.x - 8, this.y, 16, this.height);
                    
                    // Arms
                    ctx.fillRect(this.x - 20, this.y + 15, 12, 3);
                    ctx.fillRect(this.x - 20, this.y + 15, 3, 15);
                    ctx.fillRect(this.x + 8, this.y + 20, 12, 3);
                    ctx.fillRect(this.x + 17, this.y + 20, 3, 12);
                    
                    // Spines
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    for (let s = 0; s < 5; s++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x - 8, this.y + s * 8);
                        ctx.lineTo(this.x - 12, this.y + s * 8);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(this.x + 8, this.y + s * 8);
                        ctx.lineTo(this.x + 12, this.y + s * 8);
                        ctx.stroke();
                    }
                }
            });
        }
        
        // Add sand dunes
        for (let i = 0; i < 5; i++) {
            mapObjects.push({
                type: 'dune',
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: 50 + Math.random() * 50,
                draw: function() {
                    ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y, this.radius, this.radius * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    
    if (mapType === 'ice') {
        // Generate ice crystals
        for (let i = 0; i < mapData.crystalCount; i++) {
            mapObjects.push({
                type: 'crystal',
                x: Math.random() * (canvas.width - 40) + 20,
                y: Math.random() * (canvas.height - 40) + 20,
                height: 25 + Math.random() * 25,
                sparkle: Math.random() * Math.PI * 2,
                draw: function() {
                    this.sparkle += 0.05;
                    const glowAlpha = 0.3 + Math.sin(this.sparkle) * 0.2;
                    
                    // Crystal glow
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 15;
                    
                    // Crystal shape
                    ctx.fillStyle = `rgba(150, 220, 255, ${glowAlpha + 0.5})`;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.height);
                    ctx.lineTo(this.x - 10, this.y);
                    ctx.lineTo(this.x + 10, this.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.height + 5);
                    ctx.lineTo(this.x - 5, this.y - 5);
                    ctx.lineTo(this.x + 5, this.y - 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Add snowflakes
        for (let i = 0; i < 20; i++) {
            mapObjects.push({
                type: 'snowflake',
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                speed: 0.5 + Math.random() * 1,
                rotation: Math.random() * Math.PI * 2,
                draw: function() {
                    this.y += this.speed;
                    this.rotation += 0.02;
                    if (this.y > canvas.height) this.y = -10;
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ùÑ', 0, 0);
                    ctx.restore();
                }
            });
        }
    }
    
    if (mapType === 'volcano') {
        // Generate lava pools
        for (let i = 0; i < mapData.lavaPoolCount; i++) {
            mapObjects.push({
                type: 'lava',
                x: Math.random() * (canvas.width - 80) + 40,
                y: Math.random() * (canvas.height - 80) + 40,
                radius: 30 + Math.random() * 20,
                bubble: 0,
                draw: function() {
                    this.bubble += 0.1;
                    
                    // Outer glow
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                    gradient.addColorStop(0, '#ff4500');
                    gradient.addColorStop(0.5, '#ff6600');
                    gradient.addColorStop(1, 'rgba(139, 0, 0, 0.3)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bubbles
                    for (let b = 0; b < 3; b++) {
                        const bubblePhase = this.bubble + (b * Math.PI * 2 / 3);
                        const bubbleY = this.y + Math.sin(bubblePhase) * 5;
                        ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x + Math.cos(b) * 10, bubbleY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }
        
        // Add smoke particles
        for (let i = 0; i < 15; i++) {
            mapObjects.push({
                type: 'smoke',
                x: Math.random() * canvas.width,
                y: canvas.height + Math.random() * 50,
                speed: 0.3 + Math.random() * 0.5,
                size: 10 + Math.random() * 15,
                alpha: 0.1 + Math.random() * 0.2,
                draw: function() {
                    this.y -= this.speed;
                    this.alpha -= 0.001;
                    if (this.y < -20 || this.alpha <= 0) {
                        this.y = canvas.height + 10;
                        this.alpha = 0.1 + Math.random() * 0.2;
                    }
                    
                    ctx.fillStyle = `rgba(100, 100, 100, ${this.alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
    }
    
if (mapType === 'swamp') {
    // Generate dead trees
    for (let i = 0; i < mapData.treeCount; i++) {
        mapObjects.push({
            type: 'dead_tree',
            x: Math.random() * (canvas.width - 40) + 20,
            y: Math.random() * (canvas.height - 60) + 30,
            height: 30 + Math.random() * 20,
            draw: function() {
                // Dead tree trunk (dark gray)
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(this.x - 4, this.y, 8, this.height);
                
                // Twisted branches
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 10);
                ctx.lineTo(this.x - 12, this.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 15);
                ctx.lineTo(this.x + 10, this.y + 5);
                ctx.stroke();
            }
        });
    }
    
    // Add fog particles
    for (let i = 0; i < 25; i++) {
        mapObjects.push({
            type: 'fog',
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: 40 + Math.random() * 40,
            speed: 0.2 + Math.random() * 0.3,
            alpha: 0.1 + Math.random() * 0.15,
            draw: function() {
                this.x += this.speed;
                if (this.x > canvas.width + 50) this.x = -50;
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                gradient.addColorStop(0, `rgba(200, 220, 200, ${this.alpha})`);
                gradient.addColorStop(1, 'rgba(200, 220, 200, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }
    
    // Add murky water puddles
    for (let i = 0; i < 8; i++) {
        mapObjects.push({
            type: 'puddle',
            x: Math.random() * (canvas.width - 60) + 30,
            y: Math.random() * (canvas.height - 60) + 30,
            radius: 25 + Math.random() * 20,
            ripple: 0,
            draw: function() {
                this.ripple += 0.05;
                
                // Dark water
                ctx.fillStyle = '#1a3a2a';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ripple effect
                const rippleRadius = this.radius * (0.8 + Math.sin(this.ripple) * 0.2);
                ctx.strokeStyle = 'rgba(100, 150, 120, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, rippleRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        });
    }
}
}

function initMusic() {
    backgroundMusic = new Audio();
    backgroundMusic.src = 'game-music.mp3';
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.15;
    
    if (musicEnabled) {
        backgroundMusic.play().catch(e => console.log('Click to start music'));
    }
}

function toggleMusic() {
    musicEnabled = !musicEnabled;
    const btn = document.getElementById('musicToggle');
    
    if (musicEnabled) {
        btn.textContent = 'ON';
        btn.className = 'game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white';
        if (backgroundMusic) backgroundMusic.play().catch(e => {});
    } else {
        btn.textContent = 'OFF';
        btn.className = 'game-btn px-4 py-2 text-xs bg-red-500 border-red-700 text-white';
        if (backgroundMusic) backgroundMusic.pause();
    }
}
function togglePerformance() {
    saveData.performanceMode = !saveData.performanceMode;
    const btn = document.getElementById('performanceToggle');
    
    if (saveData.performanceMode) {
        btn.textContent = 'ON';
        btn.className = 'game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white';
        
        // Apply performance boost
        canvas.width = 730;
        canvas.height = 540;
        
        alert('‚ö° Performance Mode Enabled!\n\n- Lower resolution\n- Reduced effects\n- Better FPS\n\nRestart game for full effect.');
    } else {
        btn.textContent = 'OFF';
        btn.className = 'game-btn px-4 py-2 text-xs bg-gray-600 border-gray-800 text-white';
        
        // Restore normal settings
        canvas.width = 800;
        canvas.height = 600;
        
        alert('‚ö° Performance Mode Disabled\n\nNormal graphics restored.');
    }
    
    saveDataToStorage();
}


// =====================================================
// HEARTS & FIREWORKS EVENT FUNCTIONS
// =====================================================
function showEventSelection() {
    if (saveData.eventPass.active) {
        // Already chose - go straight to pass screen
        showEventPass();
    } else {
        // First time - show selection
        document.getElementById('eventSelectScreen').classList.remove('hidden');
    }
}

function selectEventType(type) {
    saveData.eventPass.active = true;
    saveData.eventPass.type = type;
    // Hide the small event button forever
    document.getElementById('btnEventPass').classList.add('hidden');
    saveData.eventPass.level = 0;
    saveData.eventPass.roses = 0;
    saveData.eventPass.fireworks = 0;
    saveData.eventPass.rewards = [];
    saveDataToStorage();
    applyEventTheme();
    
    document.getElementById('eventSelectScreen').classList.add('hidden');
    showEventPass();
    updateEventPassUI();
}

function showEventPass() {
    showScreen('eventPass');
    document.getElementById('eventPassScreen').classList.remove('hidden');
    screens.menu.classList.add('hidden');
    updateEventPassUI();
}

function applyEventTheme() {
    const body = document.body;
    const title = document.getElementById('gameTitle');
    
    if (!saveData.eventPass || !saveData.eventPass.active) {
        // Reset to default
        body.style.background = '#111';
        title.textContent = 'BLOCKY LEGENDS';
        title.style.background = '';
        title.style.webkitBackgroundClip = '';
        title.style.backgroundClip = '';
        title.style.color = '#fbbf24';
        title.style.textShadow = '4px 4px 0 rgba(0,0,0,1)';
        return;
    }
    
    if (saveData.eventPass.type === 'valentine') {
        // Valentine's Theme
        body.style.background = 'linear-gradient(180deg, #1a0a14 0%, #2d1726 50%, #4a2742 100%)';
        title.innerHTML = 'üíù BLOCKY LEGENDS üíò';
        title.style.background = 'linear-gradient(90deg, #ec4899, #f472b6, #ec4899)';
        title.style.webkitBackgroundClip = 'text';
        title.style.backgroundClip = 'text';
        title.style.webkitTextFillColor = 'transparent';
        title.style.textShadow = '4px 4px 0 rgba(236,72,153,0.3)';
        
        // Add floating hearts
        if (!document.getElementById('floatingHearts')) {
            const heartsContainer = document.createElement('div');
            heartsContainer.id = 'floatingHearts';
            heartsContainer.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;';
            body.appendChild(heartsContainer);
            
            for (let i = 0; i < 20; i++) {
                const heart = document.createElement('div');
                heart.innerHTML = 'üíó';
                heart.style.cssText = `
                    position: absolute;
                    top: -20px;
                    left: ${Math.random() * 100}%;
                    font-size: ${Math.random() * 10 + 15}px;
                    opacity: ${Math.random() * 0.5 + 0.3};
                    animation: float ${Math.random() * 3 + 5}s linear infinite;
                    animation-delay: ${Math.random() * 5}s;
                `;
                heartsContainer.appendChild(heart);
            }
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes float {
                    to {
                        transform: translateY(100vh) rotate(360deg);
                    }
                }
            `;
            document.head.appendChild(style);
        }
   } else if (saveData.eventPass.type === 'lunar') {
        // Lunar New Year Theme - ENHANCED
        body.style.background = 'linear-gradient(180deg, #1a0500 0%, #3d1a0a 30%, #5d2a14 60%, #2d0a0a 100%)';
        title.innerHTML = 'üéÜ BLOCKY LEGENDS üêâ';
        title.style.background = 'linear-gradient(90deg, #f59e0b, #ef4444, #dc2626, #f59e0b)';
        title.style.backgroundSize = '200% 100%';
        title.style.animation = 'gradientShift 3s ease infinite';
        title.style.webkitBackgroundClip = 'text';
        title.style.backgroundClip = 'text';
        title.style.webkitTextFillColor = 'transparent';
        title.style.textShadow = '4px 4px 0 rgba(245,158,11,0.3)';
        
        // Add gradient animation
        if (!document.getElementById('gradientAnimation')) {
            const style = document.createElement('style');
            style.id = 'gradientAnimation';
            style.textContent = `
                @keyframes gradientShift {
                    0% { background-position: 0% 50%; }
                    50% { background-position: 100% 50%; }
                    100% { background-position: 0% 50%; }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Add floating lanterns AND fireworks
        if (!document.getElementById('floatingLanterns')) {
            const lanternsContainer = document.createElement('div');
            lanternsContainer.id = 'floatingLanterns';
            lanternsContainer.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;';
            body.appendChild(lanternsContainer);
            
            // Red Lanterns
            for (let i = 0; i < 12; i++) {
                const lantern = document.createElement('div');
                lantern.innerHTML = 'üèÆ';
                lantern.style.cssText = `
                    position: absolute;
                    top: -20px;
                    left: ${Math.random() * 100}%;
                    font-size: ${Math.random() * 10 + 18}px;
                    opacity: ${Math.random() * 0.6 + 0.5};
                    animation: float ${Math.random() * 4 + 6}s linear infinite;
                    animation-delay: ${Math.random() * 5}s;
                `;
                lanternsContainer.appendChild(lantern);
            }
            
            // Fireworks
            for (let i = 0; i < 8; i++) {
                const firework = document.createElement('div');
                firework.innerHTML = 'üéÜ';
                firework.style.cssText = `
                    position: absolute;
                    top: -20px;
                    left: ${Math.random() * 100}%;
                    font-size: ${Math.random() * 15 + 20}px;
                    opacity: ${Math.random() * 0.8 + 0.3};
                    animation: float ${Math.random() * 3 + 5}s linear infinite;
                    animation-delay: ${Math.random() * 4}s;
                `;
                lanternsContainer.appendChild(firework);
            }
            
            // Gold coins
            for (let i = 0; i < 6; i++) {
                const coin = document.createElement('div');
                coin.innerHTML = 'ü™ô';
                coin.style.cssText = `
                    position: absolute;
                    top: -20px;
                    left: ${Math.random() * 100}%;
                    font-size: ${Math.random() * 8 + 15}px;
                    opacity: ${Math.random() * 0.7 + 0.4};
                    animation: float ${Math.random() * 5 + 7}s linear infinite;
                    animation-delay: ${Math.random() * 6}s;
                `;
                lanternsContainer.appendChild(coin);
            }
        }
    }
}

function removeEventTheme() {
    const hearts = document.getElementById('floatingHearts');
    if (hearts) hearts.remove();
    const lanterns = document.getElementById('floatingLanterns');
    if (lanterns) lanterns.remove();
    
    const body = document.body;
    const title = document.getElementById('gameTitle');
    body.style.background = '#111';
    title.textContent = 'BLOCKY LEGENDS';
    title.style.background = '';
    title.style.webkitBackgroundClip = '';
    title.style.backgroundClip = '';
    title.style.color = '#fbbf24';
    title.style.textShadow = '4px 4px 0 rgba(0,0,0,1)';
}

function claimReward(level) {
    if (!saveData.eventPass || !saveData.eventPass.active) return;
    if (saveData.eventPass.claimed.includes(level)) return;
    
    // Mark as claimed
    saveData.eventPass.claimed.push(level);
    
    const isValentine = saveData.eventPass.type === 'valentine';
    
    switch(level) {
        case 1:
            saveData.coins += 100;
            alert('‚úÖ +100 Coins!');
            break;
        case 2:
    if (isValentine) {
        if (!saveData.cosmetics.heartCrown) saveData.cosmetics.heartCrown = { owned: false, equipped: false };
        saveData.cosmetics.heartCrown.owned = true;
        alert('üéâ Heart Crown Unlocked!');
    } else {
        if (!saveData.cosmetics.redLantern) saveData.cosmetics.redLantern = { owned: false, equipped: false };
        saveData.cosmetics.redLantern.owned = true;
        alert('üéâ Red Lantern Unlocked!');
    }
    break;
        case 3:
            saveData.coins += 250;
            alert('‚úÖ +250 Coins!');
            break;
        case 4:
    if (isValentine) {
        if (!saveData.cosmetics.loveRibbon) saveData.cosmetics.loveRibbon = { owned: false, equipped: false };
        saveData.cosmetics.loveRibbon.owned = true;
        alert('üéâ Love Ribbon Unlocked!');
    } else {
        if (!saveData.cosmetics.luckyEnvelope) saveData.cosmetics.luckyEnvelope = { owned: false, equipped: false };
        saveData.cosmetics.luckyEnvelope.owned = true;
        alert('üéâ Lucky Envelope Unlocked!');
    }
    break;
        case 5:
            saveData.coins += 500;
            alert('‚úÖ +500 Coins!');
            break;
        case 6:
    if (isValentine) {
        if (!saveData.cosmetics.heartEyes) saveData.cosmetics.heartEyes = { owned: false, equipped: false };
        saveData.cosmetics.heartEyes.owned = true;
        alert('üéâ Heart Eyes Unlocked!');
    } else {
        if (!saveData.cosmetics.dragonMask) saveData.cosmetics.dragonMask = { owned: false, equipped: false };
        saveData.cosmetics.dragonMask.owned = true;
        alert('üéâ Dragon Mask Unlocked!');
    }
    break;
        case 7:
            saveData.coins += 750;
            alert('‚úÖ +750 Coins!');
            break;
        case 8:
    if (isValentine) {
        if (!saveData.cosmetics.giftBox) saveData.cosmetics.giftBox = { owned: false, equipped: false };
        saveData.cosmetics.giftBox.owned = true;
        alert('üéâ Gift Box Unlocked!');
    } else {
        if (!saveData.cosmetics.fortuneCoin) saveData.cosmetics.fortuneCoin = { owned: false, equipped: false };
        saveData.cosmetics.fortuneCoin.owned = true;
        alert('üéâ Fortune Coin Unlocked!');
    }
    break;
        case 9:
            saveData.coins += 1000;
            alert('‚úÖ +1000 Coins!');
            break;
        case 10:
            if (isValentine) {
                saveData.cupidUnlocked = true;
                alert('üéâ CUPID HERO UNLOCKED! üíò');
            } else {
                saveData.dragonUnlocked = true;
                alert('üéâ DRAGON HERO UNLOCKED! üê≤');
            }
            checkHeroUnlocks();
            updateHeroCards();
            break;
    }
    
    saveDataToStorage();
    updateEventPassUI();
    updateShopUI();
    updateChristmasUI();
}

function updateEventPassUI() {
    if (!saveData.eventPass.active) {
        document.getElementById('eventPassDisplay').classList.add('hidden');
        return;
    }
    
    const isValentine = saveData.eventPass.type === 'valentine';
    const currency = isValentine ? saveData.eventPass.roses : saveData.eventPass.fireworks;
    const icon = isValentine ? 'üåπ' : 'üéÜ';
    const thresholds = [0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200]; // ‚úÖ DOUBLED costs
    
    // Show event pass display
    document.getElementById('eventPassDisplay').classList.remove('hidden');
    document.getElementById('eventPassIcon').textContent = icon;
    document.getElementById('eventPassCount').textContent = currency;
    
    // Calculate level
    let level = 0;
    for (let i = 0; i < thresholds.length - 1; i++) {
        if (currency >= thresholds[i + 1]) {
            level = i + 1;
        }
    }
    saveData.eventPass.level = level;
    
    // Update progress bar
    const currentThreshold = thresholds[level];
    const nextThreshold = thresholds[level + 1] || 100;
    const progress = ((currency - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
    document.getElementById('eventPassBar').style.width = Math.min(100, progress) + '%';
    
    // Update pass screen if visible
    if (!document.getElementById('eventPassScreen').classList.contains('hidden')) {
        document.getElementById('eventPassTitle').textContent = isValentine ? "Valentine's Day" : "Lunar New Year";
        document.getElementById('eventPassLevel').textContent = level;
        document.getElementById('eventCurrencyIcon').textContent = icon;
        document.getElementById('eventCurrencyCount').textContent = currency;
        document.getElementById('eventDropName').textContent = isValentine ? 'Roses' : 'Fireworks';
        document.getElementById('eventProgressBar').style.width = Math.min(100, progress) + '%';
        
        // Update all currency icons
        document.querySelectorAll('.event-currency-text').forEach(el => {
            el.textContent = icon;
        });
        
        // Update cosmetic names for lunar
        if (!isValentine) {
            document.getElementById('cosmetic-2').textContent = 'üèÆ';
            document.getElementById('cosmetic-2-name').textContent = 'Red Lantern';
            document.getElementById('cosmetic-4').textContent = 'üßß';
            document.getElementById('cosmetic-4-name').textContent = 'Lucky Envelope';
            document.getElementById('cosmetic-6').textContent = 'üêâ';
            document.getElementById('cosmetic-6-name').textContent = 'Dragon Mask';
            document.getElementById('cosmetic-8').textContent = 'ü™ô';
            document.getElementById('cosmetic-8-name').textContent = 'Fortune Coin';
            document.getElementById('cosmetic-10').textContent = 'üê≤';
            document.getElementById('cosmetic-10-name').textContent = 'DRAGON HERO';
        }
        
// Highlight unlocked rewards and add claim buttons
for (let i = 1; i <= 10; i++) {
    const card = document.getElementById(`reward-${i}`);
    if (!card) continue;
    
    const isClaimed = saveData.eventPass.claimed.includes(i);
    
    if (level >= i) {
        if (isClaimed) {
            // Already claimed
            card.classList.remove('border-gray-600', 'border-yellow-500', 'bg-yellow-900');
            card.classList.add('border-gray-500', 'bg-gray-700');
            card.style.opacity = '0.6';
            
            // Remove claim button if exists
            const oldBtn = card.querySelector('.claim-btn');
            if (oldBtn) oldBtn.remove();
            
            // Show "CLAIMED" text
            if (!card.querySelector('.claimed-text')) {
                const claimedText = document.createElement('div');
                claimedText.className = 'claimed-text text-[10px] text-green-400 mt-2 font-bold';
                claimedText.textContent = '‚úì CLAIMED';
                card.appendChild(claimedText);
            }
        } else {
            // Can claim now - AUTO CLAIM IT
            claimReward(i);
        }
    } else {
        // Not unlocked yet - reset styling
        card.classList.remove('border-yellow-500', 'bg-yellow-900', 'border-gray-500', 'bg-gray-700');
        card.classList.add('border-gray-600');
        card.style.opacity = '1';
        
        const oldBtn = card.querySelector('.claim-btn');
        if (oldBtn) oldBtn.remove();
        
        const oldText = card.querySelector('.claimed-text');
        if (oldText) oldText.remove();
    }
}
    }
}

function addEventCurrency(amount) {
    if (!saveData.eventPass.active) return;
    
    if (saveData.eventPass.type === 'valentine') {
        saveData.eventPass.roses += amount;
    } else {
        saveData.eventPass.fireworks += amount;
    }
    
    saveDataToStorage();
    // DON'T update UI during gameplay - only update the counter
    if (document.getElementById('eventPassDisplay')) {
        const icon = saveData.eventPass.type === 'valentine' ? 'üåπ' : 'üéÜ';
        const count = saveData.eventPass.type === 'valentine' ? saveData.eventPass.roses : saveData.eventPass.fireworks;
        document.getElementById('eventPassIcon').textContent = icon;
        document.getElementById('eventPassCount').textContent = count;
    }
}

function updateChristmasUI() {
    document.getElementById('snowflakeCount').textContent = saveData.snowflakes || 0;
    
    // Update present buttons
    document.getElementById('buyBasicPresent').disabled = (saveData.snowflakes || 0) < 10;
    document.getElementById('buyPremiumPresent').disabled = (saveData.snowflakes || 0) < 25;
    document.getElementById('buyLegendaryPresent').disabled = (saveData.snowflakes || 0) < 50;
    
    // Update preview status (read-only, shows ownership)
    updatePreviewStatus('santaHat', 'santaHatPreview');
    updatePreviewStatus('elfHat', 'elfHatPreview');
    updatePreviewStatus('antlers', 'antlersPreview');
    updatePreviewStatus('carrotNose', 'carrotPreview');
    
    // Update outfit tab equip buttons
    updateCosmeticUI('santaHat', 'toggleSantaHat', 'santaHatStatus', 'üéÖ Santa Hat');
    updateCosmeticUI('elfHat', 'toggleElfHat', 'elfHatStatus', 'üßù Elf Hat');
    updateCosmeticUI('antlers', 'toggleAntlers', 'antlersStatus', 'ü¶å Antlers');
    updateCosmeticUI('carrotNose', 'toggleCarrot', 'carrotStatus', '‚õÑ Carrot Nose');
    updateCosmeticUI('crown', 'toggleCrown', 'crownStatus', 'üëë Royal Crown');
    updateCosmeticUI('halo', 'toggleHalo', 'haloStatus', 'üòá Halo');
updateCosmeticUI('astronaut', 'toggleAstronaut', 'astronautStatus', 'üë®‚ÄçüöÄ Astronaut');
updateCosmeticUI('partyHat', 'togglePartyHat', 'partyHatStatus', 'üéâ Party Hat');
updateCosmeticUI('topHat', 'toggleTopHat', 'topHatStatus', 'üé© Top Hat');
updateCosmeticUI('sunglasses', 'toggleSunglasses', 'sunglassesStatus', 'üòé Sunglasses');
updateCosmeticUI('monocle', 'toggleMonocle', 'monocleStatus', 'üßê Monocle');
updateCosmeticUI('mustache', 'toggleMustache', 'mustacheStatus', 'ü•∏ Mustache');
updateCosmeticUI('heartCrown', 'toggleHeartCrown', 'heartCrownStatus', 'üíò Heart Crown');
updateCosmeticUI('redLantern', 'toggleRedLantern', 'redLanternStatus', 'üèÆ Red Lantern');
updateCosmeticUI('loveRibbon', 'toggleLoveRibbon', 'loveRibbonStatus', 'üéÄ Love Ribbon');
updateCosmeticUI('luckyEnvelope', 'toggleLuckyEnvelope', 'luckyEnvelopeStatus', 'üßß Lucky Envelope');
updateCosmeticUI('heartEyes', 'toggleHeartEyes', 'heartEyesStatus', 'üòç Heart Eyes');
updateCosmeticUI('dragonMask', 'toggleDragonMask', 'dragonMaskStatus', 'üêâ Dragon Mask');
updateCosmeticUI('giftBox', 'toggleGiftBox', 'giftBoxStatus', 'üíù Gift Box');
updateCosmeticUI('fortuneCoin', 'toggleFortuneCoin', 'fortuneCoinStatus', 'ü™ô Fortune Coin');
updateCosmeticUI('cupidBow', 'toggleCupidBow', 'cupidBowStatus', 'üíò Cupid\'s Bow');
updateCosmeticUI('christmasTree', 'toggleChristmasTree', 'christmasTreeStatus', 'üéÑ Christmas Tree');

// Update crown buy button
const crownBuyBtn = document.getElementById('buyCrown');
if (crownBuyBtn) {
    if (saveData.cosmetics.crown.owned) {
        crownBuyBtn.style.display = 'none';
    } else {
        crownBuyBtn.style.display = 'block';
        crownBuyBtn.disabled = saveData.coins < 1000;
    }
}
}

function updatePreviewStatus(cosmeticKey, elementId) {
    const elem = document.getElementById(elementId);
    if (!elem) return;
    
    const cosmetic = saveData.cosmetics[cosmeticKey];
    if (cosmetic.owned) {
        elem.textContent = 'Owned ‚úì';
        elem.className = 'text-[8px] text-green-400 mt-1';
    } else {
        elem.textContent = 'Locked';
        elem.className = 'text-[8px] text-gray-400 mt-1';
    }
}
function updateCosmeticUI(cosmeticKey, buttonId, statusId, name) {
    // ‚úÖ FIX: Check if cosmetic exists first
    if (!saveData.cosmetics[cosmeticKey]) {
        saveData.cosmetics[cosmeticKey] = { owned: false, equipped: false };
    }
    
    const cosmetic = saveData.cosmetics[cosmeticKey];
    const button = document.getElementById(buttonId);
    const status = document.getElementById(statusId);
    
    // Safety check - if elements don't exist, return
    if (!button || !status) return;
    
    if (!cosmetic.owned) {
        status.textContent = 'Locked';
        status.className = 'text-[8px] text-red-400';
        button.textContent = 'LOCKED';
        button.disabled = true;
        button.className = 'game-btn px-3 py-1 text-[10px]';
    } else if (cosmetic.equipped) {
        status.textContent = 'Equipped ‚úì';
        status.className = 'text-[8px] text-green-400 font-bold';
        button.textContent = 'UNEQUIP';
        button.disabled = false;
        button.className = 'game-btn px-3 py-1 text-[10px] bg-red-500 border-red-700 text-white';
    } else {
        status.textContent = 'Owned';
        status.className = 'text-[8px] text-blue-400';
        button.textContent = 'EQUIP';
        button.disabled = false;
        button.className = 'game-btn px-3 py-1 text-[10px] bg-green-500 border-green-700 text-white';
    }
}

function toggleCosmetic(cosmeticKey) {
    // Safety check
    if (!saveData.cosmetics[cosmeticKey]) {
        saveData.cosmetics[cosmeticKey] = { owned: false, equipped: false };
    }
    if (!saveData.cosmetics[cosmeticKey].owned) return;
    
    // Define categories
    const hats = ['crown', 'santaHat', 'elfHat', 'antlers', 'halo', 'astronaut', 'partyHat', 'topHat', 'heartCrown', 'redLantern', 'loveRibbon', 'luckyEnvelope', 'wizardHat', 'vikingHelm', 'ninjaHeadband', 'pirateHat', 'witchHat'];
    const accessories = ['carrotNose', 'sunglasses', 'monocle', 'mustache', 'heartEyes', 'dragonMask', 'giftBox', 'fortuneCoin', 'cupidBow'];
    
    // If equipping, unequip others in same category
    if (!saveData.cosmetics[cosmeticKey].equipped) {
        if (hats.includes(cosmeticKey)) {
            // Unequip all other hats
            hats.forEach(hat => {
                if (hat !== cosmeticKey && saveData.cosmetics[hat]) {
                    saveData.cosmetics[hat].equipped = false;
                }
            });
        }
        if (accessories.includes(cosmeticKey)) {
            // Unequip all other accessories
            accessories.forEach(acc => {
                if (acc !== cosmeticKey && saveData.cosmetics[acc]) {
                    saveData.cosmetics[acc].equipped = false;
                }
            });
        }
    }
    
    // Toggle the clicked cosmetic
    saveData.cosmetics[cosmeticKey].equipped = !saveData.cosmetics[cosmeticKey].equipped;
    saveDataToStorage();
    
    // ‚úÖ IMMEDIATELY UPDATE ALL COSMETIC UI
    updateChristmasUI();
}



function processNextPresent() {
    if (presentQueue.length === 0) {
        isProcessingPresent = false;
        return;
    }
    
    isProcessingPresent = true;
    const present = presentQueue.shift();
    
    // Deduct cost
    saveData.snowflakes -= present.cost;
    
    // Roll for reward
    const roll = Math.random() * 100;
    let cumulative = 0;
    let selectedReward = null;
    
    for (const reward of present.rewards) {
        cumulative += reward.chance;
        if (roll < cumulative) {
            selectedReward = reward;
            break;
        }
    }
    
    if (!selectedReward) selectedReward = present.rewards[0];
    
    // Apply reward
    if (selectedReward.type === 'coins') {
        saveData.coins += selectedReward.amount;
    } else if (selectedReward.type === 'cosmetic') {
        if (!saveData.cosmetics[selectedReward.item].owned) {
            saveData.cosmetics[selectedReward.item].owned = true;
        } else {
            // Already owned - give coins instead
            saveData.coins += 100;
            selectedReward.text = '100 Bonus Coins! (Duplicate)';
        }
    }
    
    saveDataToStorage();
    
    // Show reward with animation
    const rewardEl = document.getElementById('presentReward');
    const rewardText = document.getElementById('rewardText');
    rewardText.textContent = 'üéÅ ' + selectedReward.text;
    rewardEl.classList.remove('hidden');
    rewardEl.style.animation = 'none';
    setTimeout(() => {
        rewardEl.style.animation = 'bounce 0.5s';
    }, 10);
    
    // Process next present after delay
    setTimeout(() => {
        rewardEl.classList.add('hidden');
        processNextPresent();
    }, 2000);
}

function updatePerksUI() {
    const knightBtn = document.getElementById('btnKnightPerk');
    const knightStatus = document.getElementById('knightPerkStatus');
    
    if (saveData.perks.knightBladestorm) {
        knightBtn.textContent = 'OWNED';
        knightBtn.disabled = true;
        knightStatus.textContent = 'Status: Unlocked ‚úì';
        knightStatus.className = 'text-[10px] text-green-400 mt-2';
    } else {
        knightBtn.disabled = saveData.coins < 3000;
    }
    
    const archerBtn = document.getElementById('btnArcherPerk');
    const archerStatus = document.getElementById('archerPerkStatus');
    
    if (saveData.perks.archerRicochet) {
        archerBtn.textContent = 'OWNED';
        archerBtn.disabled = true;
        archerStatus.textContent = 'Status: Unlocked ‚úì';
        archerStatus.className = 'text-[10px] text-green-400 mt-2';
    } else {
        archerBtn.disabled = saveData.coins < 3000;
    }
    const mageBtn = document.getElementById('btnMagePerk');
    const mageStatus = document.getElementById('magePerkStatus');
    
    if (saveData.perks.mageMeteor) {
        mageBtn.textContent = 'OWNED';
        mageBtn.disabled = true;
        mageStatus.textContent = 'Status: Unlocked ‚úì';
        mageStatus.className = 'text-[10px] text-green-400 mt-2';
    } else {
        mageBtn.disabled = saveData.coins < 3000;
    }
}

function buyPerk(perkName) {
    if (perkName === 'knightBladestorm') {
        if (saveData.coins >= 3000 && !saveData.perks.knightBladestorm) {
            saveData.coins -= 3000;
            saveData.perks.knightBladestorm = true;
            saveDataToStorage();
            updatePerksUI();
        }
    }
    if (perkName === 'archerRicochet') {
        if (saveData.coins >= 3000 && !saveData.perks.archerRicochet) {
            saveData.coins -= 3000;
            saveData.perks.archerRicochet = true;
            saveDataToStorage();
            updatePerksUI();
        }
    }
    if (perkName === 'mageMeteor') {
        if (saveData.coins >= 3000 && !saveData.perks.mageMeteor) {
            saveData.coins -= 3000;
            saveData.perks.mageMeteor = true;
            saveDataToStorage();
            updatePerksUI();
        }
    }
}

// =====================================================
// UPGRADE SYSTEM FUNCTIONS
// =====================================================
function showUpgradeChoices() {
    isGameOver = true; // Pause game
    
    // Get 3 UNIQUE random upgrades
    const choices = [];
    const usedIds = new Set();
    // Filter only in-rotation upgrades
const availablePool = UPGRADE_POOL.filter(up => up.inRotation !== false);
    
    for (let i = 0; i < 3; i++) {
        const available = availablePool.filter(up => {
            const propName = up.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
            const currentStacks = player.upgrades[propName] || 0;
            return currentStacks < up.maxStack && !usedIds.has(up.id);
        });
        
        if (available.length > 0) {
            const selected = available[Math.floor(Math.random() * available.length)];
            choices.push(selected);
            usedIds.add(selected.id);
        } else {
            // If not enough unique upgrades, allow duplicates but still try to avoid
const fallback = availablePool.filter(up => !usedIds.has(up.id));
            if (fallback.length > 0) {
                const selected = fallback[Math.floor(Math.random() * fallback.length)];
                choices.push(selected);
                usedIds.add(selected.id);
            }
        }
    }
    
    // Generate upgraded UI cards
    const container = document.getElementById('upgradeChoices');
    container.innerHTML = '';
    
    choices.forEach((upgrade, index) => {
        const propName = upgrade.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
        const currentStacks = player.upgrades[propName] || 0;
        
        // Color coding by type
        let borderColor = 'border-gray-600';
        let glowColor = 'hover:border-yellow-400';
        if (upgrade.type === 'offense') {
            borderColor = 'border-red-600';
            glowColor = 'hover:border-red-400 hover:shadow-red-500/50';
        } else if (upgrade.type === 'defense') {
            borderColor = 'border-blue-600';
            glowColor = 'hover:border-blue-400 hover:shadow-blue-500/50';
        } else if (upgrade.type === 'utility') {
            borderColor = 'border-purple-600';
            glowColor = 'hover:border-purple-400 hover:shadow-purple-500/50';
        }
        
        const card = document.createElement('div');
        card.className = `bg-gradient-to-br from-gray-800 to-gray-900 p-6 rounded-lg border-4 ${borderColor} ${glowColor} cursor-pointer transform hover:scale-105 transition-all shadow-lg hover:shadow-2xl`;
        card.innerHTML = `
            <div class="text-6xl text-center mb-4 animate-bounce">${upgrade.icon}</div>
            <h3 class="text-xl text-yellow-300 text-center mb-2 font-bold tracking-wider">${upgrade.name}</h3>
            <p class="text-xs text-gray-300 text-center mb-4 leading-relaxed">${upgrade.description}</p>
            <div class="text-center mb-2">
                <span class="text-xs text-cyan-400 bg-cyan-900/30 px-3 py-1 rounded-full">Level ${currentStacks} ‚Üí ${currentStacks + 1}</span>
            </div>
            <div class="text-center">
                <span class="text-[10px] text-gray-500 uppercase">${upgrade.type}</span>
            </div>
        `;
        
        card.addEventListener('click', () => selectUpgrade(upgrade));
        container.appendChild(card);
    });
    
    document.getElementById('upgradeScreen').classList.remove('hidden');
}

function selectUpgrade(upgrade) {
    console.log('Upgrade selected:', upgrade.name);
    
    // Apply upgrade effect
    try {
        upgrade.effect(player);
    } catch (e) {
        console.error('Upgrade effect error:', e);
    }
    
    // Hide upgrade screen
    const upgradeScreen = document.getElementById('upgradeScreen');
    upgradeScreen.classList.add('hidden');
    
    // Get stack count
    const propName = upgrade.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
    const stacks = player.upgrades[propName] || 1;
    
    // Visual feedback
    floatingTexts.push(new FloatingText(
        canvas.width / 2, 
        canvas.height / 2, 
        `+${upgrade.name}! (Lvl ${stacks})`, 
        '#fbbf24', 
        20
    ));
    
    // Show level up message temporarily
    const levelUpMsg = document.getElementById('levelUpMsg');
    const upgradeText = document.getElementById('upgradeText');
    levelUpMsg.classList.remove('hidden');
    upgradeText.textContent = `${upgrade.icon} ${upgrade.name} upgraded!`;
    setTimeout(() => levelUpMsg.classList.add('hidden'), 2000);
    
    // CRITICAL: Resume game state
    isGameOver = false;
    
    // Force update UI
    if (player) {
        player.updateUI();
    }
    updateAbilitySidebar();
    
    console.log('Game resumed, isGameOver:', isGameOver);

}

          function hitEnemy(enemy, dmg) {
    // CRITICAL HIT SYSTEM (Ninja cannot crit)
    let finalDamage = dmg;

    // Stun Gun logic
    if (player && player.upgrades.stunGun > 0) {
        const stunChance = player.upgrades.stunGun * 0.04; // 4% per stack
        if (Math.random() < stunChance && !enemy.isStunned) {
            enemy.isStunned = true;
            enemy.stunTimer = 120; // 2 seconds
            enemy.originalSpeed = enemy.speed;
            enemy.speed = 0; // Can't move
            floatingTexts.push(new FloatingText(enemy.x, enemy.y, '‚ö° STUNNED!', '#fbbf24', 14));
            effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 40, 'rgba(251, 191, 36, 0.8)', 'explosion'));
        }
    }
    let canCrit = !player || player.type !== 'ninja'; // Ninja has 0% crit chance
    let isCrit = canCrit && Math.random() < 0.04; // 4% crit chance for others
    
    if (isCrit) {
        finalDamage *= 2;
        floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'CRIT!', '#ff0', 16));
        effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 30, 'rgba(255,215,0,A)', 'explosion'));
    }

    // Elite enemy special mechanics
    if (enemy.isElite) {
        // Specter phases through attacks
        if (enemy.type === 'elite_specter' && enemy.isPhasing) {
            floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'PHASED!', '#9333ea', 12));
            return; // No damage during phase
        }
        
        // Tank shield blocks 75% damage
        if (enemy.type === 'elite_tank' && enemy.isShielded) {
            finalDamage *= 0.25;
            floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'BLOCKED!', '#60a5fa', 12));
            effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 25, 'rgba(96, 165, 250, A)', 'explosion'));
        }
    }
    
    const dead = enemy.takeDamage(finalDamage);

// Lifesteal healing - MEGA BUFFED & VISUAL
if (player && player.upgrades.lifesteal > 0) {
    if (!player.damageDealt) player.damageDealt = 0;
    player.damageDealt += finalDamage;
    const threshold = 25; // BUFFED: Heal every 15 damage (was 25)
    
    if (player.damageDealt >= threshold) {
        const healAmount = Math.floor(player.damageDealt / threshold) * (player.upgrades.lifesteal * 2); // BUFFED: 2 HP per stack (was 1)
        player.hp = Math.min(player.hp + healAmount, player.maxHp);
        player.damageDealt = player.damageDealt % threshold;
        
        // MEGA VISUAL FEEDBACK
        floatingTexts.push(new FloatingText(player.x, player.y - 20, `+${healAmount} HP ‚ù§Ô∏è`, '#ec4899', 18));
        
        // Big pink healing explosion
        effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 50, 'rgba(236, 72, 153, 0.8)', 'explosion'));
        
        // Healing particles rising up
        for (let i = 0; i < 5; i++) {
            effects.push({
                x: player.x + player.w/2 + (Math.random() - 0.5) * 30,
                y: player.y + player.h/2,
                vy: -2 - Math.random() * 2,
                life: 30,
                lifeMax: 30,
                size: 3 + Math.random() * 3,
                type: 'heal_particle',
                update: function() {
                    this.life--;
                    this.y += this.vy;
                    this.vy *= 0.95;
                },
                draw: function() {
                    if (this.life <= 0) return;
                    const alpha = this.life / this.lifeMax;
                    ctx.fillStyle = `rgba(236, 72, 153, ${alpha})`;
                    ctx.shadowColor = '#ec4899';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Pulsing red outline on player
        effects.push({
            x: player.x + player.w/2,
            y: player.y + player.h/2,
            radius: player.w / 2 + 5,
            life: 15,
            lifeMax: 15,
            type: 'heal_pulse',
            update: function() {
                this.life--;
                this.radius += 2;
            },
            draw: function() {
                if (this.life <= 0) return;
                const alpha = this.life / this.lifeMax;
                ctx.strokeStyle = `rgba(236, 72, 153, ${alpha * 0.8})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ec4899';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        });
        
        player.updateUI();
    }
}

    // Gold Leech upgrade
if (player && player.upgrades.goldLeech > 0) {
    const leechChance = player.upgrades.goldLeech * 0.1;
    if (Math.random() < leechChance) {
        saveData.pac.coins += 1;
        floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+1 PAC', '#a855f7', 10));
    }
}
                if (dead) {
                   const idx = enemies.indexOf(enemy);
                    if (idx > -1) {
// Chain Reaction upgrade - NO RECURSIVE CALLS
if (player && player.upgrades.chainReaction > 0) {
    const explosionRadius = 60;
    const explosionDamage = 3;
    
    effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, explosionRadius, 'rgba(255, 100, 0, 0.7)', 'explosion'));
    
    // Directly damage enemies without calling hitEnemy (prevents infinite loop)
    enemies.forEach(e => {
        if (e === enemy) return;
        const dist = Math.hypot((e.x + e.w/2) - (enemy.x + enemy.w/2),
                               (e.y + e.h/2) - (enemy.y + enemy.h/2));
        if (dist <= explosionRadius) {
            e.hp -= explosionDamage; // Direct damage, no hitEnemy call
            floatingTexts.push(new FloatingText(e.x, e.y, 'üí• -3', '#ff6600', 12));
            if (e.hp <= 0) {
                const idx = enemies.indexOf(e);
                if (idx > -1) {
                    drops.push(new DropItem(e.x + e.w/2, e.y + e.h/2, 'xp', e.xpValue));
                    enemies.splice(idx, 1);
                    kills++;
                }
            }
        }
    });
}
                        // Mino: Drop bubble on kill
if (player && player.type === 'mino' && !player.isShark) {
    drops.push(new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'bubble', 1));
}
                        
                    // ELITE SPLITTER - Splits into smaller enemies on death
                    if (enemy.type === 'elite_splitter' && enemy.splitCount > 0) {
                        floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'SPLIT!', '#22c55e', 14));
                        effects.push(new Effect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 60, 'rgba(34, 197, 94, A)', 'explosion'));
                        
                        for (let i = 0; i < enemy.splitCount; i++) {
                            const angle = (Math.PI * 2 / enemy.splitCount) * i;
                            const spawnDist = 40;
                            const spawnX = enemy.x + enemy.w/2 + Math.cos(angle) * spawnDist;
                            const spawnY = enemy.y + enemy.h/2 + Math.sin(angle) * spawnDist;
                            
                            const mini = new Enemy(spawnX, spawnY, 'normal', difficultyMultiplier * 0.6);
                            mini.w = 18;
                            mini.h = 18;
                            mini.color = '#22c55e';
                            enemies.push(mini);
                        }
                    }
                    
                    // BOSS DEATH
if (enemy.isBoss) {
    currentBoss = null;
    floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2, 'BOSS DEFEATED!', '#ffd700', 30));
    
    // INCREASED: 10 coins worth 3 each (1.2x increase from 8)
    for(let i = 0; i < 10; i++) {
        const spreadX = enemy.x + enemy.w/2 + (Math.random() - 0.5) * 100;
        const spreadY = enemy.y + enemy.h/2 + (Math.random() - 0.5) * 100;
        drops.push(new DropItem(spreadX, spreadY, 'coin', 3));
    }
}
                       drops.push(new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'xp', enemy.xpValue));

// SPECIAL DROPS - Roll once for everything
const dropRoll = Math.random() * 100;

if (dropRoll < 3) {
    // 3% chance = Golden Coin
    const goldCoin = new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'goldcoin', 8);
    goldCoin.decayTimer = 240;
    drops.push(goldCoin);
    floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'üí∞ GOLD!', '#ffd700', 14));
}
else if (dropRoll < 6 && player.hp < player.maxHp * 0.8) {
    // 3% chance = Health Pack
    const healthPack = new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'health', 30);
    healthPack.decayTimer = 240;
    drops.push(healthPack);
    floatingTexts.push(new FloatingText(enemy.x, enemy.y, '‚ù§Ô∏è HEAL!', '#ef4444', 14));
}
else {
    // EVENT PASS DROPS
if (saveData.eventPass && saveData.eventPass.active && Math.random() < 0.05) {
    const dropType = saveData.eventPass.type === 'valentine' ? 'rose' : 'firework';
    drops.push(new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, dropType, 1));
}
// Normal coins with luck bonus
let coinChance = 0.2 + (wave * 0.02);
if (player && player.upgrades.luck > 0) {
    coinChance += player.upgrades.luck * 0.05;
}
if (Math.random() < coinChance) {
    let coinValue = Math.ceil(wave / 2);
    // Luck can increase coin value
    if (player && player.upgrades.luck > 0 && Math.random() < 0.2) {
        coinValue += player.upgrades.luck;
        floatingTexts.push(new FloatingText(enemy.x, enemy.y, 'LUCKY!', '#4ade80', 12));
    }
    drops.push(new DropItem(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 'coin', coinValue));
}
}

                        if (enemy.type === 'frosty') {
                            effects.push(new Effect(enemy.x+enemy.w/2, enemy.y+enemy.h/2, 80, 'rgba(0,255,255,A)', 'ice_field'));
                        }
                        enemies.splice(idx, 1);
                        kills++;

                        // ‚úÖ Tempest fury bar charging
                        if (player && player.type === 'tempest') {
                            player.furyKills = Math.min(player.furyKills + 1, player.furyBarMax);
                            player.updateUI();
                        }
                        
                        // ‚úÖ Necromancer soul charging - GUARANTEED TO WORK
                        if (player && player.type === 'necromancer') {
                            console.log('NECRO KILL DETECTED'); // Debug line
                            if (player.soulCharge === undefined) player.soulCharge = 0;
                            player.soulCharge = Math.min(player.soulCharge + 1, player.soulChargeMax);
                            console.log('Soul charge now:', player.soulCharge, '/', player.soulChargeMax); // Debug line
                            player.updateUI();
                            floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+1 üëª', '#a855f7', 12));
                        }
                    
                        
                        // Earn trader token every 10 kills
if (kills % 25 === 0) {
    if (!saveData.traderTokens) saveData.traderTokens = 0;
    saveData.traderTokens++;
    floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+1 ‚ú®', '#fbbf24', 14));
}

                        // Lightning Step - Speed boost after kill
if (player && player.upgrades.speedBoost > 0) {
    player.speedBoostTimer = 120; // 1 second of speed boost
    floatingTexts.push(new FloatingText(player.x, player.y, '‚ö° SPEED!', '#fbbf24', 12));
}
                    }
                }
          }
function showScreen(screenName) {
    Object.values(screens).forEach(s => s.classList.add('hidden'));
    document.getElementById('gameModeScreen').classList.add('hidden');
    document.getElementById('practiceUI').classList.add('hidden');
    gameUI.classList.add('hidden');
    
    gameTitle.classList.remove('hidden');
    coinDisplayMenu.classList.remove('hidden');
    document.getElementById('pacDisplayMenu').classList.remove('hidden');
   // Hide both event buttons by default
    document.getElementById('eventPassDisplay').classList.add('hidden');
    document.getElementById('btnEventPass').classList.add('hidden');
    
    
       if (screenName === 'game') {
    gameTitle.classList.add('hidden');
    coinDisplayMenu.classList.add('hidden');
    document.getElementById('eventPassDisplay').classList.add('hidden');
    document.getElementById('pacDisplayMenu').classList.add('hidden');
    document.getElementById('codeRedemptionBox').classList.add('hidden');
    gameUI.classList.remove('hidden');
    screens.game.classList.remove('hidden');
    } else if (screenName === 'pac') {
        gameTitle.classList.add('hidden');
        coinDisplayMenu.classList.add('hidden');
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        document.getElementById('pacRankScreen').classList.remove('hidden');
   } else if (screenName === 'menu') {
    // Show trader icon in menu
document.getElementById('traderIcon').classList.remove('hidden');
    // Hide all back buttons when returning to menu
    document.getElementById('btnBackFromSettings').classList.add('hidden');
    document.getElementById('btnBackFromShop').classList.add('hidden');
    if (screens.shop && !screens.shop.classList.contains('hidden')) {
        screens.shop.classList.add('hidden');
    }
    // Show event buttons in menu based on status
    if (saveData.eventPass && saveData.eventPass.active) {
        document.getElementById('eventPassDisplay').classList.remove('hidden');
    } else {
        document.getElementById('btnEventPass').classList.remove('hidden');
    }
    document.getElementById('codeRedemptionBox').classList.remove('hidden');
    updateHeroCards(); // ‚úÖ ADD THIS LINE - Updates hero cards every time you return to menu
    screens.menu.classList.remove('hidden');
    // Restore theme when returning to menu
const hearts = document.getElementById('floatingHearts');
if (hearts) hearts.style.display = 'block';
const lanterns = document.getElementById('floatingLanterns');
if (lanterns) lanterns.style.display = 'block';
    document.getElementById('codeRedemptionBox').classList.remove('hidden');
    screens.menu.classList.remove('hidden');
    // Show event pass in menu if active
    if (saveData.eventPass && saveData.eventPass.active) {
        document.getElementById('eventPassDisplay').classList.remove('hidden');
    }
} else if (screenName === 'shop') {
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        document.getElementById('btnBackFromShop').classList.remove('hidden');
        screens.shop.classList.remove('hidden');
    } else if (screenName === 'stats') {
        document.getElementById('pacDisplayMenu').classList.add('hidden'); // ‚úÖ HIDE PAC
        screens.stats.classList.remove('hidden');
  } else if (screenName === 'settings') {
    document.getElementById('pacDisplayMenu').classList.add('hidden');
    document.getElementById('btnBackFromSettings').classList.remove('hidden');
    screens.settings.classList.remove('hidden');
} else if (screenName === 'menu') {
    // Ensure settings is hidden when returning to menu
    if (screens.settings && !screens.settings.classList.contains('hidden')) {
        screens.settings.classList.add('hidden');
    }
    screens.menu.classList.remove('hidden');
} else if (screenName === 'perks') {
        document.getElementById('pacDisplayMenu').classList.add('hidden'); // ‚úÖ HIDE PAC
        screens.perks.classList.remove('hidden');
    } else if (screenName === 'gameMode') {
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        document.getElementById('gameModeScreen').classList.remove('hidden');
    } else if (screenName === 'hero') {
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        screens.hero.classList.remove('hidden');
   } else if (screenName === 'gameOver') {
    gameTitle.classList.add('hidden');
    coinDisplayMenu.classList.add('hidden');
    document.getElementById('pacDisplayMenu').classList.add('hidden');
    screens.gameOver.classList.remove('hidden');
} else if (screenName === 'more') {
        document.getElementById('pacDisplayMenu').classList.add('hidden');
        screens.more.classList.remove('hidden');
}
}

function updateAbilitySidebar() {
    if (!player) return;
    
    const sidebar = document.getElementById('abilitySidebar');
    if (!sidebar) return;
    
    sidebar.innerHTML = '';
    
    // Get all active upgrades
    const activeUpgrades = [];
    for (const [key, value] of Object.entries(player.upgrades)) {
        if (value > 0) {
            // Find the upgrade data
            const upgradeData = UPGRADE_POOL.find(up => {
                const propName = up.id.replace(/_([a-z])/g, (m, c) => c.toUpperCase());
                return propName === key;
            });
            
            if (upgradeData) {
                activeUpgrades.push({
                    ...upgradeData,
                    stacks: value
                });
            }
        }
    }
    
    // Sort by type (offense, defense, utility)
    activeUpgrades.sort((a, b) => {
        const order = { offense: 0, defense: 1, utility: 2 };
        return order[a.type] - order[b.type];
    });
    
    // Create cards for each upgrade
    activeUpgrades.forEach(upgrade => {
        const card = document.createElement('div');
        card.className = `ability-card ability-card-${upgrade.type}`;
        card.innerHTML = `
            <span class="ability-icon">${upgrade.icon}</span>
            <span class="ability-stack">√ó${upgrade.stacks}</span>
        `;
        card.title = `${upgrade.name} (Level ${upgrade.stacks})`;
        sidebar.appendChild(card);
    });
}

        

function updateStats() {
    // Display kills from save data (which now tracks correctly)
ui.statTotalKills.textContent = saveData.stats.kills || 0;
    ui.statTotalDeaths.textContent = saveData.stats.deaths;
    ui.statBestLevel.textContent = saveData.stats.bestLevel;
    ui.statBestWave.textContent = saveData.stats.bestWave;
    
    // Hero colors mapping
    const heroColors = {
        knight: '#2563eb',
        mage: '#dc2626',
        archer: '#16a34a',
        ninja: '#000000',
        tempest: '#d1d5db',
        zap: '#fbbf24'
    };
    
    const heroNames = {
        knight: 'Knight',
        mage: 'Mage',
        archer: 'Archer',
        ninja: 'Ninja',
        tempest: 'Tempest',
        zap: 'Zap'
    };
    
    // Get top 3 heroes by kills
    const heroKills = saveData.stats.heroKills || { knight: 0, mage: 0, archer: 0, ninja: 0, tempest: 0, zap: 0 };
    const sortedHeroes = Object.entries(heroKills)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3);
    
    // Update 1st place
    if (sortedHeroes[0]) {
        const [hero, kills] = sortedHeroes[0];
        document.getElementById('hero1stBlock').style.backgroundColor = heroColors[hero];
        document.getElementById('hero1stName').textContent = heroNames[hero];
        document.getElementById('hero1stKills').textContent = kills + ' kills';
    }
    
    // Update 2nd place
    if (sortedHeroes[1]) {
        const [hero, kills] = sortedHeroes[1];
        document.getElementById('hero2ndBlock').style.backgroundColor = heroColors[hero];
        document.getElementById('hero2ndName').textContent = heroNames[hero];
        document.getElementById('hero2ndKills').textContent = kills + ' kills';
    } else {
        document.getElementById('hero2ndBlock').style.backgroundColor = '#4b5563';
        document.getElementById('hero2ndName').textContent = '---';
        document.getElementById('hero2ndKills').textContent = '0';
    }
    
    // Update 3rd place
    if (sortedHeroes[2]) {
        const [hero, kills] = sortedHeroes[2];
        document.getElementById('hero3rdBlock').style.backgroundColor = heroColors[hero];
        document.getElementById('hero3rdName').textContent = heroNames[hero];
        document.getElementById('hero3rdKills').textContent = kills + ' kills';
    } else {
        document.getElementById('hero3rdBlock').style.backgroundColor = '#4b5563';
        document.getElementById('hero3rdName').textContent = '---';
        document.getElementById('hero3rdKills').textContent = '0';
    }
}

function startGame(type) {
    showScreen('game');
    // Apply performance mode if enabled
if (saveData.performanceMode) {
    canvas.width = 640;
    canvas.height = 480;
}
    // Hide trader icon during gameplay
document.getElementById('traderIcon').classList.add('hidden');
    // Remove theme effects during gameplay
const hearts = document.getElementById('floatingHearts');
if (hearts) hearts.style.display = 'none';
const lanterns = document.getElementById('floatingLanterns');
if (lanterns) lanterns.style.display = 'none';
    
    // Pick random map
    const mapNames = Object.keys(GAME_CONFIG.MAPS);
    const randomMap = mapNames[Math.floor(Math.random() * mapNames.length)];
    currentMap = randomMap;
    
    // Generate map objects
    generateMapObjects(randomMap);
    
    // Show map name
    const mapData = GAME_CONFIG.MAPS[randomMap];
    floatingTexts.push(new FloatingText(canvas.width/2 - 100, 100, `${mapData.name}`, '#fbbf24', 24));
    
    player = new Player(canvas.width/2, canvas.height/2, type);

// Team Mode: Override HP to 30
if (isTeamMode) {
    player.maxHp = 30;
    player.hp = 30;
    document.getElementById('teamLivesUI').classList.remove('hidden');
    updateTeamLivesUI();
}
    // Practice Mode Setup
   if (isPracticeMode) {
    document.getElementById('practiceUI').classList.remove('hidden');
    trainingDummies = [
        new TrainingDummy(canvas.width/2 - 40, 100, 50, 80),  // Big dummy: 50 HP, 80 size
        new TrainingDummy(canvas.width/2 - 180, canvas.height/2, 10, 40),  // Small dummy: 10 HP, 40 size
        new TrainingDummy(canvas.width/2 + 100, canvas.height/2, 10, 40)   // Small dummy: 10 HP, 40 size
    ];
    wave = 999; // Prevent wave spawning
}
    enemies = [];
    projectiles = [];
    effects = [];
    drops = [];
    turrets = [];
    floatingTexts = [];
    keys = {};
    kills = 0;
    sessionCoins = 0;
    frameCount = 0;
    
    // Load Inventory
    sessionTurrets = saveData.inventory.turrets || 0;
    ui.hudTurretCount.textContent = sessionTurrets;
    if(sessionTurrets > 0) ui.turretHud.classList.remove('hidden');
    else ui.turretHud.classList.add('hidden');
    sessionBombs = saveData.inventory.bombs || 0;
    sessionLoveBursts = saveData.inventory.loveBursts || 0;
sessionBurnWaves = saveData.inventory.burnWaves || 0;

const loveBurstHud = document.getElementById('loveBurstHud');
const burnWaveHud = document.getElementById('burnWaveHud');

if(sessionLoveBursts > 0) loveBurstHud.classList.remove('hidden');
else loveBurstHud.classList.add('hidden');
document.getElementById('hudLoveBurstCount').textContent = sessionLoveBursts;

if(sessionBurnWaves > 0) burnWaveHud.classList.remove('hidden');
else burnWaveHud.classList.add('hidden');
document.getElementById('hudBurnWaveCount').textContent = sessionBurnWaves;
    ui.hudBombCount.textContent = sessionBombs;
    if(sessionBombs > 0) ui.bombHud.classList.remove('hidden');
    else ui.bombHud.classList.add('hidden');

    // Wave Reset
    wave = 1;
    waveTimer = GAME_CONFIG.WAVES.DURATION * 60; 
    enemySpawnTimer = 0;
    difficultyMultiplier = 1;
    bossActive = false;
    currentBoss = null;
    bossWaveCount = 0;
    
    isGameOver = false;
    isPaused = false;
document.getElementById('pauseScreen').classList.add('hidden');
    
    player.updateUI();
    ui.kills.textContent = 0;
    updateAbilitySidebar();
    ui.gameCoins.textContent = 0;
    ui.wave.textContent = 1;
    
    // FIX: Reset wave message text properly
    document.getElementById('waveMsgText').textContent = 'WAVE 1';
    document.getElementById('waveMsgText').className = 'text-4xl sm:text-6xl text-red-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold';
    ui.waveMsg.classList.remove('hidden');
    setTimeout(() => ui.waveMsg.classList.add('hidden'), 2000);

    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoop();
}

            
function gameLoop() {
    gameLoopId = requestAnimationFrame(gameLoop);
    if (isGameOver || isPaused) {
        // Still render the game but don't update game state
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        
        // Draw background
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();
        
        // Draw everything frozen in place
        effects.forEach(e => e.draw());
        turrets.forEach(t => t.draw());
        projectiles.forEach(p => p.draw());
        enemies.forEach(e => e.draw());
        if (player) player.draw();

// Team Mode: Invincibility shield visual
if (isTeamMode && invincibilityTimer > 0) {
    ctx.save();
    const shieldAlpha = 0.3 + Math.sin(frameCount * 0.2) * 0.2;
    ctx.strokeStyle = `rgba(0, 255, 255, ${shieldAlpha})`;
    ctx.lineWidth = 4;
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(player.x + player.w/2, player.y + player.h/2, player.w/2 + 15, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
    
    // Floating text
    if (frameCount % 30 === 0) {
        floatingTexts.push(new FloatingText(player.x, player.y - 30, 'INVINCIBLE', '#00ffff', 12));
    }
}
        drops.forEach(d => d.draw());
        floatingTexts.forEach(ft => ft.draw());
        
        return; // Don't update, just render
    }
// Draw map background
if (currentMap && !isPracticeMode) {
    const mapData = GAME_CONFIG.MAPS[currentMap];
    ctx.fillStyle = mapData.bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Background grid
    
        ctx.strokeStyle = mapData.gridColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
        ctx.stroke();
    
    // Draw map objects
    mapObjects.forEach(obj => obj.draw());
} else {
    // Fallback
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid (only if NOT in performance mode)
if (!saveData.performanceMode) {
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i, canvas.height); }
    for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(canvas.width, i); }
    ctx.stroke();
}
}
                // --- WAVE LOGIC ---
frameCount++;

// Team Mode: Invincibility countdown
if (invincibilityTimer > 0) {
    invincibilityTimer--;
}
if (!isPracticeMode) {
    waveTimer--;
}
                
                if (frameCount % 30 === 0) { 
                    ui.waveTimer.textContent = `Next: ${Math.ceil(waveTimer/60)}s`;
                }

                if (waveTimer <= 0) {
    wave++;
    waveTimer = GAME_CONFIG.WAVES.DURATION * 60; 
    // SMOOTH SCALING: Gradual difficulty increase
    const rawMultiplier = 1 + (wave * GAME_CONFIG.WAVES.HP_SCALING);
    difficultyMultiplier = Math.min(rawMultiplier, GAME_CONFIG.WAVES.HP_SCALING_CAP);
    
    // BONUS: Slightly increase enemy speed every 5 waves (subtle)
    if (wave % 5 === 0 && wave > 1) {
        Object.keys(GAME_CONFIG.ENEMIES).forEach(key => {
            if (GAME_CONFIG.ENEMIES[key].speed) {
                GAME_CONFIG.ENEMIES[key].speed *= 1.03; // 3% speed boost per 5 waves
            }
        });
    }
    
    ui.wave.textContent = wave;
   // CHECK IF BOSS WAVE
    if (wave % 5 === 0) {
        bossActive = true;
        bossWaveCount++;
        
        // ‚ú® EPIC BOSS ENTRANCE
        ctx.save();
        ctx.fillStyle = 'rgba(88, 28, 135, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        
        document.getElementById('waveMsgText').textContent = '‚ö†Ô∏è BOSS INCOMING ‚ö†Ô∏è';
        document.getElementById('waveMsgText').className = 'text-4xl sm:text-6xl text-purple-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold';
    } else {
        document.getElementById('waveMsgText').textContent = 'WAVE ' + wave;
        document.getElementById('waveMsgText').className = 'text-4xl sm:text-6xl text-red-500 drop-shadow-[0_4px_0_#000] animate-bounce font-bold';
    }
    
    ui.waveMsg.classList.remove('hidden');
    setTimeout(() => ui.waveMsg.classList.add('hidden'), 3000);
}
                // --- SPAWNING LOGIC ---
if (!isPracticeMode) {
    enemySpawnTimer--;
}
if (enemySpawnTimer <= 0 && !isPracticeMode) {
                    // SPAWN BOSS IF IT'S BOSS WAVE
                    if (bossActive && !currentBoss) {
                        const bossX = canvas.width / 2 - 50;
                        const bossY = -120;
                        currentBoss = new Enemy(bossX, bossY, 'boss', 1 + (bossWaveCount * 0.5));
                        currentBoss.isBoss = true;
                        enemies.push(currentBoss);
                        bossActive = false;
                    }
                    
                   // NORMAL ENEMY SPAWNS (don't spawn during boss wave)
if (wave % 5 !== 0) {
    const rand = Math.random();
    let type = 'normal';

    // Map-based spawn bonuses (20% increased chance for map-specific enemies)
    const mapBonus = 0.16;
    let mapRoll = Math.random();
    
    if (currentMap === 'desert' && mapRoll < mapBonus && wave >= 1) {
        type = 'ranger'; // Cactus map = more rangers
    }
    else if (currentMap === 'volcano' && mapRoll < mapBonus && wave >= 3) {
        type = 'brute'; // Volcano = more brutes
    }
    else if (currentMap === 'ice' && mapRoll < mapBonus && wave >= 5) {
        type = 'frosty'; // Ice = more frosties
    }
    else if (currentMap === 'forest' && mapRoll < mapBonus && wave >= 6) {
        type = Math.random() < 0.5 ? 'elite_splitter' : 'elite_tank'; // Forest = more splitters/tanks
    }
    else if (currentMap === 'swamp' && mapRoll < mapBonus && wave >= 7) {
        type = 'elite_specter'; // Swamp = more specters
    }
    else {

    // FIXED SPAWN LOGIC - Check spawn waves and roll separately
    // Ranger spawning (from wave 1)
    if (rand < 0.20) {
        type = 'ranger';
    }
    // Elite enemies (check wave requirement first)
    else if (wave >= GAME_CONFIG.ENEMIES.elite_specter.spawn_wave && rand >= 0.20 && rand < 0.28) {
        type = 'elite_specter';
    }
    else if (wave >= GAME_CONFIG.ENEMIES.elite_tank.spawn_wave && rand >= 0.28 && rand < 0.40) {
        type = 'elite_tank';
    }
    else if (wave >= GAME_CONFIG.ENEMIES.elite_splitter.spawn_wave && rand >= 0.40 && rand < 0.52) {
        type = 'elite_splitter';
    }
    // Brute (from wave 3)
    else if (wave >= GAME_CONFIG.ENEMIES.brute.spawn_wave && rand >= 0.52 && rand < 0.67) {
        type = 'brute';
    }
    // Frosty (from wave 5)
    else if (wave >= GAME_CONFIG.ENEMIES.frosty.spawn_wave && rand >= 0.67 && rand < 0.85) {
        type = 'frosty';
    }
    // Normal enemy (fallback)
    else {
        type = 'normal';
    }
    }
                        let ex, ey;
                        if (Math.random() < 0.5) {
                            ex = Math.random() < 0.5 ? -40 : canvas.width + 40;
                            ey = Math.random() * canvas.height;
                        } else {
                            ex = Math.random() * canvas.width;
                            ey = Math.random() < 0.5 ? -40 : canvas.height + 40;
                        }
                        enemies.push(new Enemy(ex, ey, type, difficultyMultiplier));
                    }
                    
                    // REDUCED spawn rate - enemies spawn SLOWER
                    let spawnRate = Math.max(20, 200 * Math.pow(0.92, wave - 1));
                    enemySpawnTimer = spawnRate;
                }
                // --- UPDATES ---
// ‚ú® LOW HEALTH RED SCREEN VIGNETTE
if (player && player.hp > 0) {
    const healthPercent = player.hp / player.maxHp;
    
    if (healthPercent < 0.3) {
        // Critical health - pulsing red vignette
        const pulseIntensity = Math.sin(frameCount * 0.1) * 0.2 + 0.3;
        const vignette = ctx.createRadialGradient(
            canvas.width/2, canvas.height/2, canvas.width * 0.3,
            canvas.width/2, canvas.height/2, canvas.width * 0.7
        );
        vignette.addColorStop(0, 'rgba(139, 0, 0, 0)');
        vignette.addColorStop(1, `rgba(139, 0, 0, ${pulseIntensity * (1 - healthPercent)})`);
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Heartbeat flash
        if (healthPercent < 0.15 && frameCount % 60 === 0) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }
}

// ‚ú® Screen shake on damage
if (player && player.lastHp !== undefined && player.hp < player.lastHp) {
    const shakeIntensity = 8;
    canvas.style.transform = `translate(${(Math.random() - 0.5) * shakeIntensity}px, ${(Math.random() - 0.5) * shakeIntensity}px)`;
    

    setTimeout(() => {
        canvas.style.transform = 'translate(0, 0)';
    }, 100);
}
if (player) player.lastHp = player.hp;
                effects.forEach((e, i) => {
                    e.update(); e.draw();
                    if (e.life <= 0) effects.splice(i, 1);
                });

               for (let i = drops.length - 1; i >= 0; i--) {
    const collected = drops[i].update();
    drops[i].draw();
    if (collected) drops.splice(i, 1);
}

                turrets.forEach((t, i) => {
                    t.update(); t.draw();
                    if(t.life <= 0) turrets.splice(i, 1);
                });

                player.update();

                player.update();
                // Update skeletons
if (window.skeletons) {
    for (let i = window.skeletons.length - 1; i >= 0; i--) {
        const skeleton = window.skeletons[i];
        skeleton.update();
        skeleton.draw();
        if (skeleton.lifetime <= 0) {
            window.skeletons.splice(i, 1);
        }
    }
}

                // Mino continuous shooting
if (player && player.type === 'mino' && player.shootContinuously && player.waterTank > 0) {
    if (player.weaponCooldown <= 0) {
        player.shoot();
    }
}
                
                
        
                
              // FIXED: Use reverse loop to prevent array mutation issues
for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    const shouldRemove = p.update(); // Boomerangs can request removal
    
    // Remove boomerangs that expired
    if (shouldRemove) {
        projectiles.splice(i, 1);
        continue;
    }
    
    // Remove projectiles that go off screen
    if (p.x < -50 || p.x > canvas.width+50 || p.y < -50 || p.y > canvas.height+50) {
        projectiles.splice(i, 1);
        continue;
    }

    // Check if enemy projectile hits player
if (p.isEnemyProjectile && player && rectCollision(p, player)) {
    // Knight shield deflection
    if (player.type === 'knight' && player.shieldMode) {
        // Check if projectile is coming from the front
        const angleToProjectile = Math.atan2(p.y - player.y, p.x - player.x);
        let angleDiff = Math.abs(angleToProjectile - player.angle);
        if (angleDiff > Math.PI) angleDiff = 2*Math.PI - angleDiff;
        
        // Deflect if within 90 degrees of where shield is facing
        if (angleDiff < Math.PI/2) {
            floatingTexts.push(new FloatingText(player.x, player.y, 'BLOCKED!', '#3b82f6', 14));
            effects.push(new Effect(p.x, p.y, 25, 'rgba(59, 130, 246, 0.8)', 'explosion'));
            projectiles.splice(i, 1);
            continue;
        }
    }
    
    if (!player.isDashing) {
        let damage = p.damage;
        
        // Take damage normally
        player.hp -= damage;
floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
        player.updateUI();
        floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
        effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 25, 'rgba(255, 0, 0, 0.6)', 'explosion'));
        
        if (player.hp <= 0) {
            endGame();
        }
    }
    projectiles.splice(i, 1);
    continue;
}
    
// Check collision with enemies (SKIP if enemy projectile)
let projectileHit = false;
let enemiesHitThisFrame = 0;

if (!p.isEnemyProjectile) {
    // Track which enemies this projectile already hit (for pierce)
    if (!p.hitEnemies) p.hitEnemies = new Set();
    
    for (let j = enemies.length - 1; j >= 0; j--) {
        // PIERCE FIX: Skip if already hit this enemy
        if (p.hitEnemies.has(enemies[j])) continue;
        
        if (rectCollision(p, enemies[j])) {
            // ‚úÖ Skip if this is a split arrow that should ignore this enemy
        if (p.ignoreEnemy === enemies[j]) continue;
            // Mark this enemy as hit
            p.hitEnemies.add(enemies[j]);
            if (p.type === 'necroOrb') {
    // NECRO ORB EXPLOSION - Smaller AOE with slow
    const explosionRadius = 50;  // Smaller than fireball (70)
    
    // Purple explosion effect
    effects.push(new Effect(p.x, p.y, explosionRadius, 'rgba(168, 85, 247, 0.7)', 'explosion'));
    
    // Purple soul particles explosion
    for (let particle = 0; particle < 8; particle++) {
        const angle = (particle / 8) * Math.PI * 2;
        effects.push({
            x: p.x,
            y: p.y,
            vx: Math.cos(angle) * 4,
            vy: Math.sin(angle) * 4,
            life: 20,
            lifeMax: 20,
            type: 'necro_particle',
            update: function() {
                this.life--;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95;
                this.vy *= 0.95;
            },
            draw: function() {
                if (this.life <= 0) return;
                const alpha = this.life / this.lifeMax;
                ctx.save();
                ctx.shadowColor = '#a855f7';
                ctx.shadowBlur = 10;
                ctx.fillStyle = `rgba(168, 85, 247, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        });
    }
    
    // Damage and slow ALL enemies in radius
    for (let k = enemies.length - 1; k >= 0; k--) {
        const e = enemies[k];
        const dist = Math.hypot((e.x+e.w/2)-p.x, (e.y+e.h/2)-p.y);
        if (dist < explosionRadius) {
            // Deal reduced AOE damage (half of orb damage)
            hitEnemy(e, p.damage * 0.5);
            
            // Apply slow effect
            if (!e.necroSlowed) {
                e.necroSlowed = true;
                e.originalSpeed = e.speed;
                e.slowTimer = 90;  // 1.5 seconds
            }
            e.speed = e.originalSpeed * 0.6;  // 40% slow
            
            // Visual feedback
            floatingTexts.push(new FloatingText(e.x, e.y, 'üíÄ', '#a855f7', 12));
        }
    }
    projectileHit = true;
} 
            if (p.type === 'fireball') {
                // FIREBALL EXPLOSION - Hit ALL enemies in radius
                const explosionRadius = GAME_CONFIG.PROJECTILES.fireball.explosionRadius;
                effects.push(new Effect(p.x, p.y, explosionRadius, 'rgba(255, 140, 0, A)', 'explosion'));
                
                for (let k = enemies.length - 1; k >= 0; k--) {
                    const e = enemies[k];
                    const dist = Math.hypot((e.x+e.w/2)-p.x, (e.y+e.h/2)-p.y);
                    if (dist < explosionRadius) {
                        hitEnemy(e, p.damage);
                    }
                }
                projectileHit = true;
            } else {
                // Regular projectile hit
                if (p.knockback > 0 && enemies[j]) {
                    enemies[j].pushbackX += Math.cos(p.angle) * p.knockback;
                    enemies[j].pushbackY += Math.sin(p.angle) * p.knockback;
                }
                
                const damageToApply = p.currentDamage !== undefined ? p.currentDamage : p.damage;
              // Apply damage with pierce reduction if applicable
if (player && player.upgrades.piercingShots > 0 && enemiesHitThisFrame > 0) {
    const damageReduction = 0.8; // UPDATED: 80% damage per pierce (was 60%)
    const reducedDamage = damageToApply * Math.pow(damageReduction, enemiesHitThisFrame);
    hitEnemy(enemies[j], reducedDamage);
} else {
    hitEnemy(enemies[j], damageToApply);
// Cupid arrow splitting - only split ONCE per arrow into 3 shots
if (p.isCupidArrow && !p.hasSplit && enemies[j]) {
    p.hasSplit = true;
    const hitX = p.x;
    const hitY = p.y;
    
    // Mark the hit enemy so splits don't hit it
    const hitEnemyId = enemies[j];
    
    // Create 3 splitting arrows with MORE reduced damage
    for (let s = 0; s < 3; s++) {
        const spreadAngle = (s - 1) * 0.4;
        const splitArrow = new Projectile(hitX + Math.cos(p.angle + spreadAngle) * 30, 
                                         hitY + Math.sin(p.angle + spreadAngle) * 30, 
                                         p.angle + spreadAngle, 'cupidArrow',
            p.damage * 0.30);
        splitArrow.pierce = true;
        splitArrow.color = '#f472b6';
        splitArrow.w = 8;
        splitArrow.h = 8;
        splitArrow.hasSplit = true;
        splitArrow.ignoreEnemy = hitEnemyId; // ‚úÖ Don't hit the same enemy
        projectiles.push(splitArrow);
    }
    
    effects.push(new Effect(hitX, hitY, 40, 'rgba(236, 72, 153, 0.8)', 'explosion'));
}
// Dragon flame burn
if (p.isDragonFlame && enemies[j]) {
    if (!enemies[j].isBurning) {
        enemies[j].isBurning = true;
        enemies[j].burnTimer = 180; // 3 seconds
        enemies[j].burnDamage = p.damage * 0.5;
    }
}
}
                enemiesHitThisFrame++;
                
                // Explosive Shots upgrade
                if (player && player.upgrades.explosiveShots > 0) {
                    const explosionRadius = 40 * player.upgrades.explosiveShots;
                    effects.push(new Effect(enemies[j].x + enemies[j].w/2, enemies[j].y + enemies[j].h/2, 
                                           explosionRadius, 'rgba(255, 100, 0, 0.6)', 'explosion'));
                    
                    for (let k = enemies.length - 1; k >= 0; k--) {
                        if (k === j) continue;
                        const e = enemies[k];
                        const dist = Math.hypot((e.x + e.w/2) - (enemies[j].x + enemies[j].w/2),
                                               (e.y + e.h/2) - (enemies[j].y + enemies[j].h/2));
                        if (dist < explosionRadius) {
                            hitEnemy(e, damageToApply * 0.5);
                        }
                    }
                }
                
                // Split Shot upgrade
                if (player && player.upgrades.splitShot > 0 && (p.type === 'arrow' || p.type === 'turret')) {
                    for (let s = 0; s < player.upgrades.splitShot; s++) {
                        const spreadAngle = (Math.random() - 0.5) * Math.PI / 3;
                        const splitProj = new Projectile(
                            enemies[j].x + enemies[j].w/2,
                            enemies[j].y + enemies[j].h/2,
                            p.angle + spreadAngle,
                            p.type,
                            p.damage * 0.6
                        );
                        splitProj.w = p.w * 0.7;
                        splitProj.h = p.h * 0.7;
                        projectiles.push(splitProj);
                    }
                }
                
                // CHARGED LIGHTNING - Chain to nearby enemies
                if (p.type === 'lightning' && p.isCharged && !p.hasChained) {
                    p.hasChained = true;
                    const hitX = enemies[j].x + enemies[j].w/2;
                    const hitY = enemies[j].y + enemies[j].h/2;
                    const chainRange = 120;
                    
                    // Find up to 3 nearby enemies to chain to
                    let chainedEnemies = [];
                    for (let k = enemies.length - 1; k >= 0; k--) {
                        if (k === j) continue; // Skip the hit enemy
                        const e = enemies[k];
                        const dist = Math.hypot((e.x + e.w/2) - hitX, (e.y + e.h/2) - hitY);
                        
                        if (dist < chainRange) {
                            chainedEnemies.push({ enemy: e, dist: dist });
                        }
                    }
                    
                    // Sort by distance and take closest 3
                    chainedEnemies.sort((a, b) => a.dist - b.dist);
                    chainedEnemies = chainedEnemies.slice(0, 3);
                    
                    // Chain lightning to each
                    chainedEnemies.forEach(target => {
                        // Draw lightning arc
                        effects.push({
                            x: hitX,
                            y: hitY,
                            targetX: target.enemy.x + target.enemy.w/2,
                            targetY: target.enemy.y + target.enemy.h/2,
                            life: 8,
                            lifeMax: 8,
                            type: 'lightning_arc',
                            update: function() { this.life--; },
                            draw: function() {
                                if (this.life <= 0) return;
                                ctx.save();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 3;
                                ctx.shadowColor = '#fbbf24';
                                ctx.shadowBlur = 15;
                                ctx.beginPath();
                                ctx.moveTo(this.x, this.y);
                                // Jagged lightning path
                                const segments = 4;
                                for (let s = 1; s <= segments; s++) {
                                    const t = s / segments;
                                    const x = this.x + (this.targetX - this.x) * t + (Math.random() - 0.5) * 20;
                                    const y = this.y + (this.targetY - this.y) * t + (Math.random() - 0.5) * 20;
                                    ctx.lineTo(x, y);
                                }
                                ctx.stroke();
                                ctx.restore();
                            }
                        });
                        
                        // Deal damage to chained enemy
                        hitEnemy(target.enemy, p.damage * 0.6); // 60% of main damage
                        floatingTexts.push(new FloatingText(target.enemy.x, target.enemy.y, '‚ö°', '#fbbf24', 14));
                    });
                    
                    if (chainedEnemies.length > 0) {
                        floatingTexts.push(new FloatingText(hitX, hitY - 20, `CHAIN x${chainedEnemies.length}!`, '#fff', 16));
                    }
                }
                
              // PIERCING MECHANIC - HEAVILY NERFED DAMAGE
if (player && player.upgrades.piercingShots > 0) {
    const maxPierces = player.upgrades.piercingShots + 1;
    
    // HEAVY NERF: Reduce damage by 50% for each enemy pierced
    const damageReduction = 0.5; // 50% damage after first hit (was 70%)
    const reducedDamage = damageToApply * Math.pow(damageReduction, enemiesHitThisFrame);
    hitEnemy(enemies[j], reducedDamage);
    
    if (enemiesHitThisFrame >= maxPierces) {
        projectileHit = true;
    }
    // Otherwise keep going through enemies!
} else if (p.pierce) {
                    // Ricochet arrows have their own pierce
                    if (enemiesHitThisFrame >= 3) {
                        projectileHit = true;
                    }
                } else {
                    projectileHit = true; // Normal projectiles stop on first hit
                }
            }
            break;
       }
    }
}
    
    // Remove projectile after it hits (unless piercing)
    if (projectileHit) {
        projectiles.splice(i, 1);
    }
}

// Practice Mode: Update dummies
if (isPracticeMode && trainingDummies.length > 0) {
    trainingDummies.forEach(dummy => {
        dummy.update();
        dummy.draw();
        
        // Check projectile collisions
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            if (!p.isEnemyProjectile && !dummy.isDead) {
                if (rectCollision(p, dummy)) {
                    dummy.takeDamage(p.damage || 5);
                    projectiles.splice(i, 1);
                }
            }
        }
    });
}
                
enemies.forEach(e => {
   // Dragon burn effect - FIXED: Check if enemy has burn properties first
if (e.isBurning !== undefined && e.isBurning && e.burnTimer > 0) {
    e.burnTimer--;
    if (frameCount % 30 === 0) {
        e.hp -= e.burnDamage;
        floatingTexts.push(new FloatingText(e.x, e.y, 'üî•', '#f97316', 12));
        
// ‚úÖ DRAGON RAGE CHARGING
if (player && player.type === 'dragon') {
    if (!player.rageCharge) player.rageCharge = 0;
    player.rageCharge = Math.min(player.rageCharge + 5, player.rageMax);
            player.updateUI();
            
            
        }
        
        // ‚úÖ Check if enemy died from burn
        if (e.hp <= 0) {
            const idx = enemies.indexOf(e);
            if (idx > -1) {
                drops.push(new DropItem(e.x + e.w/2, e.y + e.h/2, 'xp', e.xpValue));
                enemies.splice(idx, 1);
                kills++;
            }
        }
    }
    if (e.burnTimer <= 0) {
        e.isBurning = false;
    }
}
    e.update();
   if (rectCollision(player, e)) {
    if (!player.isDashing && invincibilityTimer <= 0) {
            // Check dodge chance
            if (player.upgrades.dodgeChance > 0) {
                const dodgeChance = player.upgrades.dodgeChance * 0.08;
                if (Math.random() < dodgeChance) {
                    floatingTexts.push(new FloatingText(player.x, player.y, 'DODGE!', '#00ffff', 14));
                    effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 30, 'rgba(0, 255, 255, 0.6)', 'explosion'));
                    return; // Skip damage entirely
                }
            }
            
            let damage = e.isBoss ? GAME_CONFIG.ENEMIES.boss.damage : 1;
            
// Take damage normally
player.hp -= damage;
floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
            player.updateUI();
            if (frameCount % 20 === 0) { 
               floatingTexts.push(new FloatingText(player.x, player.y, `-${Math.round(damage)} HP`, "red"));
            }

// Thorns upgrade (NERFED - only 15% reflection)
if (player.upgrades.thorns > 0) {
    const thornsDamage = damage * 0.15 * player.upgrades.thorns; // NERFED: Was 0.3, now 0.15
                e.hp -= thornsDamage;
                floatingTexts.push(new FloatingText(e.x, e.y, 'üåµ -' + Math.floor(thornsDamage), '#22c55e', 12));
                effects.push(new Effect(e.x + e.w/2, e.y + e.h/2, 25, 'rgba(34, 197, 94, 0.6)', 'explosion'));
                
                if (e.hp <= 0) {
                    const idx = enemies.indexOf(e);
                    if (idx > -1) {
                        enemies.splice(idx, 1);
                        kills++;
                    }
                }
            }
            
            if (player.hp <= 0) {
                endGame();
            }
        }
    }
});

// ADD THIS LINE TO UPDATE KILL COUNTER EVERY FRAME:
ui.kills.textContent = kills;
                
for (let i = floatingTexts.length - 1; i >= 0; i--) {
    if (floatingTexts[i]) {
        floatingTexts[i].update();
        floatingTexts[i].draw();
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }
}
}
function togglePause() {
    if (isGameOver) return; // Can't pause if game over
    if (screens.game.classList.contains('hidden')) return; // Can only pause during gameplay
    
    isPaused = !isPaused;
    
    if (isPaused) {
        document.getElementById('pauseScreen').classList.remove('hidden');
    } else {
        document.getElementById('pauseScreen').classList.add('hidden');
    }
}

            function endGame() {
    // Team Mode: Check if we have more lives
    if (isTeamMode && currentTeamIndex < 2) {
        teamRespawning = true;
        isGameOver = true; // Pause briefly
        
        // Epic death effect
        effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 150, 'rgba(255, 0, 0, 0.8)', 'explosion'));
        
        // Show respawn message
        const respawnMsg = document.createElement('div');
        respawnMsg.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-80 z-50';
        respawnMsg.innerHTML = `
            <div class="text-center animate-bounce">
                <div class="text-8xl mb-4">${teamHeroes[currentTeamIndex].icon}</div>
                <div class="text-4xl text-red-500 font-bold mb-4">HERO DOWN!</div>
                <div class="text-6xl mb-4">${teamHeroes[currentTeamIndex + 1].icon}</div>
                <div class="text-3xl text-cyan-400 font-bold">NEXT: ${teamHeroes[currentTeamIndex + 1].name.toUpperCase()}</div>
            </div>
        `;
        document.body.appendChild(respawnMsg);
        
        // Wait 2 seconds then respawn
        setTimeout(() => {
            currentTeamIndex++;
            
            // Spawn new hero at same position
            const oldX = player.x;
            const oldY = player.y;
            player = new Player(oldX, oldY, teamHeroes[currentTeamIndex].type);
            player.maxHp = 30;
            player.hp = 30;
            invincibilityTimer = 180; // 3 seconds invincibility
            
            // Epic spawn effect
            effects.push(new Effect(player.x + player.w/2, player.y + player.h/2, 200, 'rgba(0, 255, 255, 0.8)', 'explosion'));
            floatingTexts.push(new FloatingText(player.x, player.y - 40, '‚ö° RESPAWN! ‚ö°', '#00ffff', 24));
            
            updateTeamLivesUI();
            player.updateUI();
            
            document.body.removeChild(respawnMsg);
            isGameOver = false;
            teamRespawning = false;
        }, 2000);
        
        return;
    }
    
// Original endGame code
    isGameOver = true;
    
    // ‚úÖ FIX: No rewards in Team Mode
    const cappedSessionCoins = isTeamMode ? 0 : Math.min(sessionCoins, 1000);
    saveData.coins = parseInt(saveData.coins) + parseInt(cappedSessionCoins);
    saveData.stats.kills = (saveData.stats.kills || 0) + parseInt(kills);
    if (!saveData.stats.heroKills) {
        saveData.stats.heroKills = { knight: 0, mage: 0, archer: 0, ninja: 0, tempest: 0, zap: 0 };
    }
    saveData.stats.heroKills[player.type] = (saveData.stats.heroKills[player.type] || 0) + parseInt(kills);
    saveData.stats.deaths = parseInt(saveData.stats.deaths) + 1;
    
    const timeAlive = frameCount / 60;
    // ‚úÖ FIX: No PAC in Team Mode
    const rawPAC = isTeamMode ? 0 : calculatePACCoins(wave, kills, timeAlive);
    const earnedPAC = isTeamMode ? 0 : Math.min(rawPAC, 800);
    if (earnedPAC > 0) {
        updatePACRank(earnedPAC);
    }
    saveData.inventory.turrets = parseInt(sessionTurrets);
    saveData.inventory.bombs = parseInt(sessionBombs);
    saveData.inventory.loveBursts = parseInt(sessionLoveBursts);
    saveData.inventory.burnWaves = parseInt(sessionBurnWaves);
    
    if (wave > saveData.stats.bestWave) saveData.stats.bestWave = parseInt(wave);
    if (player.level > saveData.stats.bestLevel) saveData.stats.bestLevel = parseInt(player.level);
    
    saveDataToStorage();
    
    setTimeout(() => {
        const verification = localStorage.getItem(GAME_CONFIG.STORAGE_KEY);
        if (verification) {
            console.log('‚úÖ Save verified');
        } else {
            console.error('‚ùå Save failed - attempting recovery');
            saveDataToStorage();
        }
    }, 100);

    showScreen('gameOver');
    ui.finalKills.textContent = kills;
    ui.statTotalKills.textContent = saveData.stats.kills;
    ui.finalCoins.textContent = cappedSessionCoins + (sessionCoins > 5000 ? ' (CAPPED)' : '');
    ui.finalWave.textContent = wave;
    document.getElementById('finalPAC').textContent = earnedPAC + (rawPAC > 2000 ? ' (CAPPED)' : '');
    
    // Reset team mode
    isTeamMode = false;
    teamHeroes = [];
    currentTeamIndex = 0;
    document.getElementById('teamLivesUI').classList.add('hidden');
}
            
           function rectCollision(r1, r2) {
    // Simple rectangle collision - no special hitboxes
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

            // --- SHOP LOGIC ---
            function buyUpgrade(type) {
                // Initialize cosmetic if it doesn't exist
    const cosmeticTypes = ['crown', 'halo', 'astronaut', 'partyHat', 'topHat', 'sunglasses', 'monocle', 'mustache'];
    if (cosmeticTypes.includes(type)) {
        if (!saveData.cosmetics[type]) {
            saveData.cosmetics[type] = { owned: false, equipped: false };
        }
    }
                if (type === 'health') {
                    const cost = GAME_CONFIG.SHOP.HEALTH_BASE * (saveData.upgrades.health + 1);
                    if (saveData.coins >= cost && saveData.upgrades.health < 5) {
                        saveData.coins -= cost;
                        saveData.upgrades.health++;
                        saveDataToStorage();
                    }
                }
                if (type === 'magnet') {
                    const cost = GAME_CONFIG.SHOP.MAGNET_BASE * (saveData.upgrades.magnet + 1);
                    if (saveData.coins >= cost && saveData.upgrades.magnet < 5) {
                        saveData.coins -= cost;
                        saveData.upgrades.magnet++;
                        saveDataToStorage();
                    }
                }
                if (type === 'turret') {
                    if(saveData.coins >= GAME_CONFIG.TURRET.COST) {
                        saveData.coins -= GAME_CONFIG.TURRET.COST;
                        saveData.inventory.turrets++;
                        saveDataToStorage();
                    }
                }
                if (type === 'bomb') {
                    if(saveData.coins >= GAME_CONFIG.BOMB.COST) {
                        saveData.coins -= GAME_CONFIG.BOMB.COST;
                        saveData.inventory.bombs++;
                        saveDataToStorage();
                    }
                }
                if (type === 'loveBurst') {
    if (saveData.eventPass && saveData.eventPass.type === 'valentine' && (saveData.eventPass.roses || 0) >= 10) {
        saveData.eventPass.roses -= 20;
        saveData.inventory.loveBursts++;
        saveDataToStorage();
        updateEventPassUI();
    }
}
if (type === 'burnWave') {
    if (saveData.eventPass && saveData.eventPass.type === 'lunar' && (saveData.eventPass.fireworks || 0) >= 10) {
        saveData.eventPass.fireworks -= 20;
        saveData.inventory.burnWaves++;
        saveDataToStorage();
        updateEventPassUI();
    }
}
                if (type === 'skin') {
                    if (!saveData.upgrades.goldSkin && saveData.coins >= GAME_CONFIG.SHOP.SKIN) {
                        // Purchase skin
                        saveData.coins -= GAME_CONFIG.SHOP.SKIN;
                        saveData.upgrades.goldSkin = true;
                        saveData.upgrades.goldSkinEquipped = true;
                        saveDataToStorage();
                    } else if (saveData.upgrades.goldSkin) {
                        // Equip/unequip skin
                        saveData.upgrades.goldSkinEquipped = true;
                        saveDataToStorage();
                        updateShopUI();
        updateChristmasUI();
                    }
                }


                if (type === 'obsidianSkin') {
    if (!saveData.upgrades.obsidianSkin && saveData.coins >= 1500) {
        // Purchase obsidian skin
        saveData.coins -= 1500;
        saveData.upgrades.obsidianSkin = true;
        saveData.upgrades.obsidianSkinEquipped = true;
        // Unequip other skins
        saveData.upgrades.goldSkinEquipped = false;
        saveDataToStorage();
    } else if (saveData.upgrades.obsidianSkin) {
        // Equip obsidian skin
        saveData.upgrades.obsidianSkinEquipped = true;
        // Unequip other skins
        saveData.upgrades.goldSkinEquipped = false;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
    }
}
if (type === 'crown') {
    if (!saveData.cosmetics.crown) {
        saveData.cosmetics.crown = { owned: false, equipped: false };
    }
    if (saveData.coins >= 1000 && !saveData.cosmetics.crown.owned) {
        saveData.coins -= 1000;
        saveData.cosmetics.crown.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Crown Purchased!');
    } else if (saveData.cosmetics.crown.owned) {
        alert('‚ùå Already owned!');
    }
    return; // Exit function after handling
}
// Handle all 700 gold cosmetics
const gold700Items = ['halo', 'astronaut', 'partyHat', 'topHat', 'sunglasses', 'monocle'];
if (gold700Items.includes(type)) {
    if (!saveData.cosmetics[type]) {
        saveData.cosmetics[type] = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics[type].owned) {
        saveData.coins -= 700;
        saveData.cosmetics[type].owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ ' + type + ' Purchased!');
    }
    return;
}

if (type === 'halo') {
    if (!saveData.cosmetics.halo) {
        saveData.cosmetics.halo = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics.halo.owned) {
        saveData.coins -= 700;
        saveData.cosmetics.halo.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Halo Purchased!');
    } else if (saveData.cosmetics.halo.owned) {
        alert('‚ùå Already owned!');
    }
    return;
}

if (type === 'astronaut') {
    if (!saveData.cosmetics.astronaut) {
        saveData.cosmetics.astronaut = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics.astronaut.owned) {
        saveData.coins -= 700;
        saveData.cosmetics.astronaut.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Astronaut Purchased!');
    } else if (saveData.cosmetics.astronaut.owned) {
        alert('‚ùå Already owned!');
    }
    return;
}

if (type === 'partyHat') {
    if (!saveData.cosmetics.partyHat) {
        saveData.cosmetics.partyHat = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics.partyHat.owned) {
        saveData.coins -= 700;
        saveData.cosmetics.partyHat.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Party Hat Purchased!');
    } else if (saveData.cosmetics.partyHat.owned) {
        alert('‚ùå Already owned!');
    }
    return;
}

if (type === 'topHat') {
    if (!saveData.cosmetics.topHat) {
        saveData.cosmetics.topHat = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics.topHat.owned) {
        saveData.coins -= 700;
        saveData.cosmetics.topHat.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Top Hat Purchased!');
    } else if (saveData.cosmetics.topHat.owned) {
        alert('‚ùå Already owned!');
    }
    return;
}

if (type === 'sunglasses') {
    if (!saveData.cosmetics.sunglasses) {
        saveData.cosmetics.sunglasses = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics.sunglasses.owned) {
        saveData.coins -= 700;
        saveData.cosmetics.sunglasses.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Sunglasses Purchased!');
    } else if (saveData.cosmetics.sunglasses.owned) {
        alert('‚ùå Already owned!');
    }
    return;
}

if (type === 'monocle') {
    if (!saveData.cosmetics.monocle) {
        saveData.cosmetics.monocle = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics.monocle.owned) {
        saveData.coins -= 700;
        saveData.cosmetics.monocle.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Monocle Purchased!');
    } else if (saveData.cosmetics.monocle.owned) {
        alert('‚ùå Already owned!');
    }
    return;
}

if (type === 'mustache') {
    if (!saveData.cosmetics.mustache) {
        saveData.cosmetics.mustache = { owned: false, equipped: false };
    }
    if (saveData.coins >= 700 && !saveData.cosmetics.mustache.owned) {
        saveData.coins -= 700;
        saveData.cosmetics.mustache.owned = true;
        saveDataToStorage();
        updateShopUI();
        updateChristmasUI();
        alert('‚úÖ Mustache Purchased!');
    } else if (saveData.cosmetics.mustache.owned) {
        alert('‚ùå Already owned!');
    }
    return;
}
updateShopUI();
updateChristmasUI();
            }
            // --- CODE REDEMPTION SYSTEM ---
const REWARD_CODES = {
    'TEAMHEART': { cosmetic: 'cupidBow', description: 'üíò Cupid\'s Bow Unlocked! (Archer Only)' },
    'ELEPH': { coins: 100000, description: '+100,000 Coins! üéâ' },
    'ELEPHPAC': { pac: 10000, description: '+10,000 PAC Points! üèÜ' },
    'ELEPHTRADE': { traderTokens: 120, description: '+120 Trader Tokens! ‚ú®' },
    'ELEPHROSE': { roses: 10000, description: '+10000 Roses! üåπ Complete Valentine Pass!' },
    'ELEPHFIREWORK': { fireworks: 10000, description: '+10000 Fireworks! üéÜ Complete Lunar Pass!' },
    'GAMETESTER': { coins: 10000, description: '+10,000 Coins! üéâ' },
    'TESTROSE': { roses: 100, description: '+100 Roses! üåπ Complete Valentine Pass!' },
    'TESTFIREWORK': { fireworks: 100, description: '+100 Fireworks! üéÜ Complete Lunar Pass!' },
    'DRAGONUNLOCK': { dragon: true, description: 'üê≤ Dragon Hero Unlocked!' },
    'WGAME': { traderTokens: 15, description: '+15 Trader Tokens! ‚ú®' },
    'BLOCKYLEGENDSLIVES': { coins: 800, description: '+800 Coins! üéâ' },
'THREEPOINTOH': { turrets: 3, bombs: 3, description: '+3 Turrets & +3 Bombs! üí£üî´' },
'LATECHRISTMAS': { cosmetic: 'christmasTree', description: 'üéÑ Christmas Tree Sword Unlocked! (Knight Only)' },

};

function redeemCode(code) {
    const upperCode = code.toUpperCase().trim();
    const msgEl = document.getElementById('codeMessage');
    
    // Check if code exists
    if (!REWARD_CODES[upperCode]) {
        msgEl.textContent = '‚ùå Invalid code';
        msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    
    // Check if already redeemed
    if (saveData.redeemedCodes.includes(upperCode)) {
        msgEl.textContent = '‚ö†Ô∏è Already redeemed';
        msgEl.className = 'text-[10px] mt-2 text-center text-yellow-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    
    // SUCCESS! Give rewards
const reward = REWARD_CODES[upperCode];
if (reward.coins) saveData.coins += reward.coins;
if (reward.turrets) {
    if (!saveData.inventory.turrets) saveData.inventory.turrets = 0;
    saveData.inventory.turrets += reward.turrets;
}
if (reward.bombs) {
    if (!saveData.inventory.bombs) saveData.inventory.bombs = 0;
    saveData.inventory.bombs += reward.bombs;
}
if (reward.pac) {
    updatePACRank(reward.pac);
}
if (reward.traderTokens) {
    if (!saveData.traderTokens) saveData.traderTokens = 0;
    saveData.traderTokens += reward.traderTokens;
}
saveData.redeemedCodes.push(upperCode);
// Handle cosmetic rewards FIRST (before roses/fireworks checks)
if (reward.cosmetic) {
    if (!saveData.cosmetics[reward.cosmetic]) {
        saveData.cosmetics[reward.cosmetic] = { owned: false, equipped: false };
    }
    saveData.cosmetics[reward.cosmetic].owned = true;
    saveDataToStorage();
    updateShopUI();
    updateChristmasUI();
}

if (reward.roses) {
    if (!saveData.eventPass.active) {
        msgEl.textContent = '‚ùå Event pass not active!';
        msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    if (saveData.eventPass.type === 'valentine') {
        saveData.eventPass.roses += reward.roses;
    } else {
        msgEl.textContent = '‚ùå Wrong event type!';
        msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
}
if (reward.dragon) {
    saveData.dragonUnlocked = true;
    checkHeroUnlocks();
    updateHeroCards();
}
if (reward.fireworks) {
    if (!saveData.eventPass.active) {
        msgEl.textContent = '‚ùå Event pass not active!';
        msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    if (saveData.eventPass.type === 'lunar') {
        saveData.eventPass.fireworks += reward.fireworks;
    } else {
        msgEl.textContent = '‚ùå Wrong event type!';
        msgEl.className = 'text-[10px] mt-2 text-center text-red-400';
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 3000);
        return;
    }
    // Update event pass UI if roses/fireworks were given
    if (reward.roses || reward.fireworks) {
        updateEventPassUI();
    }
}
saveDataToStorage();
    
    msgEl.textContent = `‚úÖ ${reward.description}`;
    msgEl.className = 'text-[10px] mt-2 text-center text-green-400';
    msgEl.classList.remove('hidden');
    document.getElementById('codeInput').value = '';
    
    setTimeout(() => msgEl.classList.add('hidden'), 3000);
}

            // --- EVENT LISTENERS ---
            
            // --- EVENT LISTENERS ---

// Navigation Buttons
document.getElementById('btnStandardMode').addEventListener('click', () => {
    isPracticeMode = false;
    isTeamMode = false; // ‚úÖ FIX: Force disable team mode
    teamHeroes = []; // ‚úÖ FIX: Clear team heroes array
    showScreen('hero');
    updateHeroCards();
});

document.getElementById('btnPracticeMode').addEventListener('click', () => {
    isPracticeMode = true;
    isTeamMode = false; // ‚úÖ FIX: Force disable team mode
    teamHeroes = []; // ‚úÖ FIX: Clear team heroes array
    showScreen('hero');
    updateHeroCards();
});

document.getElementById('btnBackFromTeamSelect').addEventListener('click', () => {
    document.getElementById('teamSelectScreen').classList.add('hidden');
    isTeamMode = false;
    teamHeroes = [];
    showScreen('gameMode');
});

document.getElementById('btnBackFromGameMode').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnPlay').addEventListener('click', () => {
    showScreen('gameMode');
});
document.getElementById('btnMore').addEventListener('click', () => showScreen('more'));
// PAC Rank Display Click
document.getElementById('pacDisplayMenu').addEventListener('click', () => {
    showScreen('pac');
    document.getElementById('gameTitle').classList.add('hidden');
    document.getElementById('coinDisplayMenu').classList.add('hidden');
    document.getElementById('pacDisplayMenu').classList.add('hidden');
});
document.getElementById('btnStats').addEventListener('click', () => { 
    updateStats(); 
    showScreen('stats'); 
});
document.getElementById('btnShop').addEventListener('click', () => { 
    updateShopUI();
    updateChristmasUI(); // Force update cosmetics
    showScreen('shop'); 
});

// Back Buttons - ALL OF THEM
document.getElementById('btnBackFromStats').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromSelect').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromShop').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromSettings').addEventListener('click', () => {
    screens.settings.classList.add('hidden');
    showScreen('menu');
});
document.getElementById('btnBackFromPerks').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnBackFromMore').addEventListener('click', () => showScreen('menu'));
document.getElementById('btnSettingsMore').addEventListener('click', () => showScreen('settings'));
document.getElementById('btnPerksMore').addEventListener('click', () => { 
    updatePerksUI(); 
    showScreen('perks'); 
});
// Trader Icon Click
document.getElementById('traderIcon').addEventListener('click', () => {
    updateTraderUI();
    showScreen('menu');
    document.getElementById('traderScreen').classList.remove('hidden');
    screens.menu.classList.add('hidden');
});

document.getElementById('btnBackFromTrader').addEventListener('click', () => {
    document.getElementById('traderScreen').classList.add('hidden');
    showScreen('menu');
});
document.getElementById('btnBackFromPac').addEventListener('click', () => {
    // Hide PAC screen FIRST
    document.getElementById('pacRankScreen').classList.add('hidden');
    
    // Then show menu elements
    showScreen('menu');
    document.getElementById('gameTitle').classList.remove('hidden');
    document.getElementById('coinDisplayMenu').classList.remove('hidden');
    document.getElementById('pacDisplayMenu').classList.remove('hidden');
});
// Event Pass Buttons
document.getElementById('eventPassDisplay').addEventListener('click', () => {
    if (!saveData.eventPass || !saveData.eventPass.active) {
        // First time - show selection
        document.getElementById('eventSelectScreen').classList.remove('hidden');
    } else {
        // Already chose - show progress screen
        document.getElementById('eventPassScreen').classList.remove('hidden');
        screens.menu.classList.add('hidden');
        updateEventPassUI();
    }
});
document.getElementById('selectValentine').addEventListener('click', () => selectEventType('valentine'));
document.getElementById('selectLunar').addEventListener('click', () => selectEventType('lunar'));
document.getElementById('btnEventPass').addEventListener('click', () => {
    if (!saveData.eventPass || !saveData.eventPass.active) {
        document.getElementById('eventSelectScreen').classList.remove('hidden');
        screens.menu.classList.add('hidden');
    } else {
        showEventPass();
    }
});
document.getElementById('btnBackFromEventPass').addEventListener('click', () => {
    document.getElementById('eventPassScreen').classList.add('hidden');
    showScreen('menu');
});
document.getElementById('btnResume').addEventListener('click', togglePause);
document.getElementById('btnQuitToMenu').addEventListener('click', () => {
    isPaused = false;
    document.getElementById('pauseScreen').classList.add('hidden');
    endGame();
});
document.getElementById('restartButton').addEventListener('click', () => showScreen('menu'));

// Code Redemption
document.getElementById('btnRedeem').addEventListener('click', () => {
    const code = document.getElementById('codeInput').value;
    redeemCode(code);
});

document.getElementById('codeInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        redeemCode(e.target.value);
    }
});

// Shop Tab Switching
document.getElementById('tabUpgrades').addEventListener('click', () => {
    document.getElementById('upgradesTab').classList.remove('hidden');
    document.getElementById('skinsTab').classList.add('hidden');
    document.getElementById('outfitsTab').classList.add('hidden');
    document.getElementById('tabUpgrades').className = 'game-btn px-6 py-3 text-sm bg-yellow-500 border-yellow-700 text-white';
    document.getElementById('tabSkins').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabOutfits').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
});

document.getElementById('tabOutfits').addEventListener('click', () => {
    document.getElementById('upgradesTab').classList.add('hidden');
    document.getElementById('skinsTab').classList.add('hidden');
    document.getElementById('outfitsTab').classList.remove('hidden');
    document.getElementById('tabUpgrades').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabSkins').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabOutfits').className = 'game-btn px-6 py-3 text-sm bg-cyan-500 border-cyan-700 text-white';
});

document.getElementById('tabSkins').addEventListener('click', () => {
    document.getElementById('upgradesTab').classList.add('hidden');
    document.getElementById('skinsTab').classList.remove('hidden');
    document.getElementById('outfitsTab').classList.add('hidden');
    document.getElementById('tabUpgrades').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
    document.getElementById('tabSkins').className = 'game-btn px-6 py-3 text-sm bg-purple-500 border-purple-700 text-white';
    document.getElementById('tabOutfits').className = 'game-btn px-6 py-3 text-sm bg-gray-600 border-gray-800 text-white';
});


// Shop Buttons
ui.btnHealth.addEventListener('click', () => buyUpgrade('health'));
ui.btnMagnet.addEventListener('click', () => buyUpgrade('magnet'));
ui.btnTurret.addEventListener('click', () => buyUpgrade('turret'));
ui.btnBomb.addEventListener('click', () => buyUpgrade('bomb'));
document.getElementById('buyLoveBurst').addEventListener('click', () => buyUpgrade('loveBurst'));
document.getElementById('buyBurnWave').addEventListener('click', () => buyUpgrade('burnWave'));
ui.btnSkin.addEventListener('click', () => buyUpgrade('skin'));
document.getElementById('unequipSkin').addEventListener('click', () => {
    saveData.upgrades.goldSkinEquipped = false;
    saveDataToStorage();
});

document.getElementById('buyObsidianSkin').addEventListener('click', () => buyUpgrade('obsidianSkin'));
document.getElementById('unequipObsidianSkin').addEventListener('click', () => {
    saveData.upgrades.obsidianSkinEquipped = false;
    saveDataToStorage();
});
document.getElementById('buyCrown').addEventListener('click', () => buyUpgrade('crown'));
document.getElementById('toggleCrown').addEventListener('click', () => toggleCosmetic('crown'));
document.getElementById('buyHalo').addEventListener('click', () => buyUpgrade('halo'));
document.getElementById('toggleHalo').addEventListener('click', () => toggleCosmetic('halo'));
document.getElementById('buyAstronaut').addEventListener('click', () => buyUpgrade('astronaut'));
document.getElementById('toggleAstronaut').addEventListener('click', () => toggleCosmetic('astronaut'));
document.getElementById('buyPartyHat').addEventListener('click', () => buyUpgrade('partyHat'));
document.getElementById('togglePartyHat').addEventListener('click', () => toggleCosmetic('partyHat'));
document.getElementById('buyTopHat').addEventListener('click', () => buyUpgrade('topHat'));
document.getElementById('toggleTopHat').addEventListener('click', () => toggleCosmetic('topHat'));
document.getElementById('buySunglasses').addEventListener('click', () => buyUpgrade('sunglasses'));
document.getElementById('toggleSunglasses').addEventListener('click', () => toggleCosmetic('sunglasses'));
document.getElementById('buyMonocle').addEventListener('click', () => buyUpgrade('monocle'));
document.getElementById('toggleMonocle').addEventListener('click', () => toggleCosmetic('monocle'));
document.getElementById('buyMustache').addEventListener('click', () => buyUpgrade('mustache'));
document.getElementById('toggleMustache').addEventListener('click', () => toggleCosmetic('mustache'));
document.getElementById('toggleHeartCrown').addEventListener('click', () => toggleCosmetic('heartCrown'));
document.getElementById('toggleRedLantern').addEventListener('click', () => toggleCosmetic('redLantern'));
document.getElementById('toggleLoveRibbon').addEventListener('click', () => toggleCosmetic('loveRibbon'));
document.getElementById('toggleLuckyEnvelope').addEventListener('click', () => toggleCosmetic('luckyEnvelope'));
document.getElementById('toggleHeartEyes').addEventListener('click', () => toggleCosmetic('heartEyes'));
document.getElementById('toggleDragonMask').addEventListener('click', () => toggleCosmetic('dragonMask'));
document.getElementById('toggleGiftBox').addEventListener('click', () => toggleCosmetic('giftBox'));
document.getElementById('toggleFortuneCoin').addEventListener('click', () => toggleCosmetic('fortuneCoin'));
document.getElementById('toggleCupidBow').addEventListener('click', () => toggleCosmetic('cupidBow'));
document.getElementById('toggleChristmasTree').addEventListener('click', () => toggleCosmetic('christmasTree'));
// Performance Toggle
document.getElementById('performanceToggle').addEventListener('click', togglePerformance);
// Perk Buttons
document.getElementById('btnKnightPerk').addEventListener('click', () => buyPerk('knightBladestorm'));
document.getElementById('btnArcherPerk').addEventListener('click', () => buyPerk('archerRicochet'));
document.getElementById('btnMagePerk').addEventListener('click', () => buyPerk('mageMeteor'));

// Hero Select Cards
document.querySelectorAll('.char-select-card').forEach(b => b.addEventListener('click', (e) => {
    e.stopPropagation();
    const heroType = b.dataset.type;
    
    // Check if hero is locked
    if (heroType === 'zap' && !saveData.zapUnlocked) {
        alert('üîí Reach Legend Rank to unlock Zap!');
        return;
    }
    if (heroType === 'unit7' && !saveData.unit7Unlocked) {
        alert('üîí Reach Elite Rank to unlock Unit-7!');
        return;
    }
    if (heroType === 'cupid' && !saveData.cupidUnlocked) {
    alert('üîí Complete Valentine Event Pass to unlock Cupid!');
    return;
}
if (heroType === 'dragon' && !saveData.dragonUnlocked) {
    alert('üîí Complete Lunar Event Pass to unlock Dragon!');
    return;
}
    
    startGame(heroType);
}));
// Keyboard Controls
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space' && !isGameOver && player) {
        player.dash(); 
    }
    if (e.code === 'KeyP') {
    togglePause();
}
// Practice Mode: Switch heroes with Q
    if (e.code === 'KeyF' && isPracticeMode && !isGameOver) {
        showScreen('hero');
        isPaused = true;
    }
});
window.addEventListener('keyup', e => {
    keys[e.code] = false;
    
    // Stop Mino spray when E is released
    if (e.code === 'KeyE' && player && player.type === 'mino') {
        player.isSpraying = false;
        player.shootContinuously = false;
    }
});
// Team Hero Selection
function attachTeamCardListeners() {
    document.querySelectorAll('.team-hero-card').forEach(card => {
        // Remove old listeners
        const newCard = card.cloneNode(true);
        card.parentNode.replaceChild(newCard, card);
        
        newCard.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const hero = newCard.dataset.hero;
            const icon = newCard.dataset.icon;
            const color = newCard.dataset.color;
            const name = hero.charAt(0).toUpperCase() + hero.slice(1);
            
            // Check if already selected
            const alreadySelected = teamHeroes.some(h => h.type === hero);
            
            if (alreadySelected) {
                // Remove from team
                const index = teamHeroes.findIndex(h => h.type === hero);
                teamHeroes.splice(index, 1);
                newCard.classList.remove('selected');
            } else {
                // Add to team (max 3)
                if (teamHeroes.length < 3) {
                    teamHeroes.push({ type: hero, icon: icon, color: color, name: name });
                    newCard.classList.add('selected');
                }
            }
            
            updateTeamSlots();
        });
    });
}

// Call when showing team select screen
document.getElementById('btnTeamMode').addEventListener('click', () => {
    isTeamMode = true;
    teamHeroes = [];
    currentTeamIndex = 0;
    showScreen('menu');
    document.getElementById('teamSelectScreen').classList.remove('hidden');
    screens.menu.classList.add('hidden');
    updateTeamSlots();
    attachTeamCardListeners(); // Attach listeners
});

function updateTeamSlots() {
    // Update slot displays
    for (let i = 1; i <= 3; i++) {
        const slot = document.getElementById(`teamSlot${i}`);
        if (teamHeroes[i-1]) {
            const hero = teamHeroes[i-1];
            slot.innerHTML = `<span class="text-6xl">${hero.icon}</span>`;
            slot.style.backgroundColor = hero.color;
        } else {
            slot.innerHTML = `<span class="text-6xl text-gray-600">?</span>`;
            slot.style.backgroundColor = '#1f2937';
        }
    }
    
    // Enable start button if 3 heroes selected
    const startBtn = document.getElementById('btnStartTeamGame');
    if (teamHeroes.length === 3) {
        startBtn.disabled = false;
        startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    } else {
        startBtn.disabled = true;
        startBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }
}

function updateTeamLivesUI() {
    if (!isTeamMode) return;
    
    for (let i = 0; i < 3; i++) {
        const hero = teamHeroes[i];
        const lifeDiv = document.getElementById(`teamLife${i+1}`);
        const icon = document.getElementById(`teamIcon${i+1}`);
        const name = document.getElementById(`teamName${i+1}`);
        const status = document.getElementById(`teamStatus${i+1}`);
        
        icon.textContent = hero.icon;
        name.textContent = hero.name;
        
        if (i < currentTeamIndex) {
            // Dead
            lifeDiv.className = 'flex items-center gap-2 p-2 bg-gray-900 rounded border-2 border-red-600 opacity-50';
            status.textContent = 'DEAD';
            status.className = 'text-xs text-red-500 ml-auto font-bold';
        } else if (i === currentTeamIndex) {
            // Active
            lifeDiv.className = 'flex items-center gap-2 p-2 bg-gray-900 rounded border-2 border-cyan-500 shadow-lg shadow-cyan-500/50';
            status.textContent = 'ACTIVE';
            status.className = 'text-xs text-green-400 ml-auto font-bold animate-pulse';
        } else {
            // Ready
            lifeDiv.className = 'flex items-center gap-2 p-2 bg-gray-900 rounded border-2 border-gray-600';
            status.textContent = 'READY';
            status.className = 'text-xs text-gray-400 ml-auto';
        }
    }
}

document.getElementById('btnStartTeamGame').addEventListener('click', () => {
    if (teamHeroes.length === 3) {
        isPracticeMode = false; // ‚úÖ FIX: Force disable practice mode
        isTeamMode = true; // ‚úÖ FIX: Ensure team mode is enabled
        currentTeamIndex = 0;
        document.getElementById('teamSelectScreen').classList.add('hidden');
        startGame(teamHeroes[0].type);
    }
});

window.addEventListener('mouseup', () => {
    if (player) {
        if (player.type === 'volt' && player.whipCharging) {
            player.whipCharging = false;
            player.shoot();
        } else if (player.type === 'mino') {
            player.isSpraying = false;
            player.shootContinuously = false;
        }
    }
});

// Mouse Controls
window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    mousePos.x = (e.clientX - rect.left) * scaleX; 
    mousePos.y = (e.clientY - rect.top) * scaleY;
});

window.addEventListener('mousedown', (e) => { 
    if (screens.game.classList.contains('hidden')) return;
    if (!isGameOver && player) {
        if (player.waitingForMeteorTarget) {
            player.useMeteorShower(mousePos.x, mousePos.y);
            player.waitingForMeteorTarget = false;
        } else if (player.type === 'volt') {
            player.whipCharging = true;
        } else if (player.type === 'mino') {
            player.isSpraying = true;
            player.shootContinuously = true;
        } else {
            player.shoot();
        }
    }
});
// E key to shoot
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyE' && !isGameOver && player && !screens.game.classList.contains('hidden')) {
        if (player.type === 'mino') {
            player.isSpraying = true;
            player.shootContinuously = true;
        } else if (!player.waitingForMeteorTarget) {
            player.shoot();
        }
    }
});
// Necromancer C key handler - DEDICATED
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyC' && !isGameOver && player && player.type === 'necromancer' && !screens.game.classList.contains('hidden')) {
        e.preventDefault();
        console.log('üî• C KEY PRESSED - Necromancer detected');
        console.log('Soul charge:', player.soulCharge, '/', player.soulChargeMax);
        
        if (player.soulCharge >= player.soulChargeMax) {
            console.log('‚úÖ SUMMONING SKELETONS!');
            player.soulCharge = 0;
            player.updateUI();
            
            // Epic summoning circle effect
            effects.push({
                x: player.x + player.w/2,
                y: player.y + player.h/2,
                radius: 100,
                life: 60,
                lifeMax: 60,
                type: 'summon_ring',
                update: function() { this.life--; },
                draw: function() {
                    if (this.life <= 0) return;
                    const alpha = this.life / this.lifeMax;
                    ctx.save();
                    
                    // Purple glowing circle
                    ctx.strokeStyle = `rgba(168, 85, 247, ${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#a855f7';
                    ctx.shadowBlur = 30;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner pentagram pattern
                    ctx.strokeStyle = `rgba(124, 58, 237, ${alpha * 0.6})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 5; i++) {
                        const angle1 = (i * Math.PI * 2 / 5) - Math.PI / 2;
                        const angle2 = ((i + 2) * Math.PI * 2 / 5) - Math.PI / 2;
                        ctx.beginPath();
                        ctx.moveTo(this.x + Math.cos(angle1) * this.radius, this.y + Math.sin(angle1) * this.radius);
                        ctx.lineTo(this.x + Math.cos(angle2) * this.radius, this.y + Math.sin(angle2) * this.radius);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });
            
            // Summon 7 skeletons over 2 seconds
            for (let i = 0; i < 7; i++) {
                setTimeout(() => {
                    const angle = (i / 10) * Math.PI * 2;
                    const spawnX = player.x + player.w/2 + Math.cos(angle) * 100 + (Math.random() - 0.5) * 40;
const spawnY = player.y + player.h/2 + Math.sin(angle) * 100 + (Math.random() - 0.5) * 40;
                    
                    // Epic spawn portal effect
                    effects.push({
                        x: spawnX,
                        y: spawnY,
                        radius: 5,
                        maxRadius: 30,
                        life: 20,
                        lifeMax: 20,
                        type: 'spawn_portal',
                        update: function() {
                            this.life--;
                            this.radius = this.maxRadius * (1 - this.life / this.lifeMax);
                        },
                        draw: function() {
                            if (this.life <= 0) return;
                            const alpha = this.life / this.lifeMax;
                            ctx.save();
                            ctx.fillStyle = `rgba(168, 85, 247, ${alpha * 0.6})`;
                            ctx.shadowColor = '#a855f7';
                            ctx.shadowBlur = 20;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            ctx.restore();
                        }
                    });
                    
                    if (!window.skeletons) window.skeletons = [];
                    window.skeletons.push({
                        x: spawnX,
                        y: spawnY,
                        w: 20,
                        h: 20,
                        speed: 2.5,
                        damage: 0.65,
                        lifetime: 600,
                        maxLifetime: 600,
                        update: function() {
                            this.lifetime--;
                            
                            let nearest = null;
                            let minDist = 999999;
                            enemies.forEach(e => {
                                const dist = Math.hypot((e.x + e.w/2) - (this.x + this.w/2),
                                                       (e.y + e.h/2) - (this.y + this.h/2));
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearest = e;
                                }
                            });
                            
                            if (nearest) {
                                // Anti-clumping: push away from other skeletons
if (window.skeletons) {
    for (let s = 0; s < window.skeletons.length; s++) {
        if (window.skeletons[s] === this) continue;
        const other = window.skeletons[s];
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 30 && dist > 0) {
            this.x += (dx / dist) * 1.5;
            this.y += (dy / dist) * 1.5;
        }
    }
}
                                const dx = (nearest.x + nearest.w/2) - (this.x + this.w/2);
                                const dy = (nearest.y + nearest.h/2) - (this.y + this.h/2);
                                const dist = Math.hypot(dx, dy);
                                
                                if (dist > 0) {
                                    this.x += (dx / dist) * this.speed;
                                    this.y += (dy / dist) * this.speed;
                                }
                                
                                if (dist < 25 && frameCount % 30 === 0) {
                                    nearest.hp -= this.damage;
                                    floatingTexts.push(new FloatingText(nearest.x, nearest.y, 'üíÄ -0.65', '#a855f7', 12));
                                    effects.push(new Effect(nearest.x + nearest.w/2, nearest.y + nearest.h/2, 30, 'rgba(168, 85, 247, 0.6)', 'explosion'));
                                    
                                    if (nearest.hp <= 0) {
                                        const idx = enemies.indexOf(nearest);
                                        if (idx > -1) enemies.splice(idx, 1);
                                    }
                                }
                            }
                        },
                        draw: function() {
                            const alpha = this.lifetime / this.maxLifetime;
                            ctx.save();
                            ctx.globalAlpha = alpha;
                            ctx.shadowColor = '#a855f7';
                            ctx.shadowBlur = 15;
                            ctx.fillStyle = '#d8b4fe';
                            ctx.fillRect(this.x, this.y, this.w, this.h);
                            ctx.fillStyle = '#7c3aed';
                            ctx.fillRect(this.x + 5, this.y + 5, 3, 3);
                            ctx.fillRect(this.x + 12, this.y + 5, 3, 3);
                            ctx.fillRect(this.x + 9, this.y + 10, 2, 3);
                            ctx.fillRect(this.x + 5, this.y + 14, 10, 2);
                            ctx.fillRect(this.x + 5, this.y + 16, 2, 2);
                            ctx.fillRect(this.x + 9, this.y + 16, 2, 2);
                            ctx.fillRect(this.x + 13, this.y + 16, 2, 2);
                            if (this.lifetime < 120) {
                                ctx.strokeStyle = '#ff0000';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(this.x - 2, this.y - 2, this.w + 4, this.h + 4);
                            }
                            ctx.shadowBlur = 0;
                            ctx.globalAlpha = 1;
                            ctx.restore();
                        }
                    });
                    
                    effects.push(new Effect(spawnX, spawnY, 40, 'rgba(168, 85, 247, 0.8)', 'explosion'));
                }, i * 200);
            }
            
            floatingTexts.push(new FloatingText(player.x, player.y, 'üíÄ SKELETON SWARM!', '#a855f7', 20));
        } else {
            console.log('‚ùå NOT READY - Need', player.soulChargeMax - player.soulCharge, 'more souls');
            floatingTexts.push(new FloatingText(player.x, player.y, 'NOT READY!', '#ff6600', 12));
        }
    }
});

// Initialize
loadData();
// Apply performance mode UI
if (saveData.performanceMode) {
    const btn = document.getElementById('performanceToggle');
    if (btn) {
        btn.textContent = 'ON';
        btn.className = 'game-btn px-4 py-2 text-xs bg-green-500 border-green-700 text-white';
    }
    canvas.width = 640;
    canvas.height = 480;
}
updateEventPassUI();
applyEventTheme();
updatePACUI();
checkHeroUnlocks();
updateHeroCards();

// Force unlock heroes based on current rank
const currentRank = saveData.pac.rank;
if (currentRank === 'legend' && !saveData.zapUnlocked) {
    saveData.zapUnlocked = true;
    saveDataToStorage();
}
if ((currentRank === 'elite' || currentRank === 'legend') && !saveData.unit7Unlocked) {
    saveData.unit7Unlocked = true;
    saveDataToStorage();
}
initMusic();

// Trader System
const TRADER_POOL = [
    // Repeatable Items ONLY
    { id: 'coins500', name: '500 Coins', type: 'coins', value: 500, icon: 'üí∞', minCost: 15, maxCost: 25, unique: false },
    { id: 'coins1000', name: '1000 Coins', type: 'coins', value: 1000, icon: 'üíé', minCost: 30, maxCost: 45, unique: false },
    { id: 'coins2000', name: '2000 Coins', type: 'coins', value: 2000, icon: 'üíµ', minCost: 50, maxCost: 70, unique: false },
    { id: 'turrets', name: '3 Turrets', type: 'turret', value: 3, icon: 'üî´', minCost: 20, maxCost: 35, unique: false },
    { id: 'bombs', name: '3 Bombs', type: 'bomb', value: 3, icon: 'üí£', minCost: 25, maxCost: 40, unique: false }
];

function generateTraderOffers() {
    const now = Date.now();
    const timeSinceRefresh = now - (saveData.lastTraderRefresh || 0);
    const refreshInterval = 12 * 60 * 60 * 1000; // 12 HOURS
    // Check if needs refresh
    if (!saveData.traderOffers || saveData.traderOffers.length === 0 || timeSinceRefresh >= refreshInterval) {
        saveData.lastTraderRefresh = now;
        
        // Filter out already purchased unique items
        const availablePool = TRADER_POOL.filter(item => {
            if (item.unique) {
                return !(saveData.purchasedUniqueItems || []).includes(item.id);
            }
            return true; // Repeatable items always available
        });
        
// Pick ONLY 2 random offers
        const shuffled = availablePool.sort(() => Math.random() - 0.5);
        saveData.traderOffers = shuffled.slice(0, 2).map(item => ({
            ...item,
            cost: Math.floor(Math.random() * (item.maxCost - item.minCost + 1)) + item.minCost
        }));
        
        saveDataToStorage();
    }
}
// Make buyTraderOffer globally accessible
window.buyTraderOffer = function(index) {
   const offer = saveData.traderOffers[index];
if (!offer) return;

// Check if already purchased
if (offer.unique && saveData.purchasedUniqueItems && saveData.purchasedUniqueItems.includes(offer.id)) {
    alert('‚ùå Already purchased!');
    return;
    updateChristmasUI(); // Update cosmetic UI after purchase
}
    
    if ((saveData.traderTokens || 0) >= offer.cost) {
        saveData.traderTokens -= offer.cost;
        
        if (offer.type === 'coins') {
            saveData.coins += offer.value;
        } else if (offer.type === 'turret') {
            saveData.inventory.turrets += offer.value;
        } else if (offer.type === 'bomb') {
            saveData.inventory.bombs += offer.value;
        } else if (offer.type === 'cosmetic') {
            if (!saveData.cosmetics[offer.id]) {
                saveData.cosmetics[offer.id] = { owned: false, equipped: false };
            }
            saveData.cosmetics[offer.id].owned = true;
            
            if (offer.unique) {
                if (!saveData.purchasedUniqueItems) saveData.purchasedUniqueItems = [];
                saveData.purchasedUniqueItems.push(offer.id);
            }
        }
        
        saveDataToStorage();
        updateTraderUI();
        updateShopUI();
        alert('‚úÖ Purchased ' + offer.name + '!');
    } else {
        alert('‚ùå Not enough tokens!');
    }
};

function updateTraderUI() {
    generateTraderOffers();
    
    document.getElementById('traderTokenCount').textContent = saveData.traderTokens || 0;
    
    // Update timer
    updateTraderTimer();
    
    const offersContainer = document.getElementById('traderOffers');
    offersContainer.innerHTML = '';
    
    if (!saveData.traderOffers || saveData.traderOffers.length === 0) {
        offersContainer.innerHTML = '<p class="text-gray-400 text-center col-span-2">No offers available</p>';
        return;
    }
    
    saveData.traderOffers.forEach((offer, i) => {
        const canBuy = (saveData.traderTokens || 0) >= offer.cost;
        const card = document.createElement('div');
        card.className = `bg-gradient-to-br from-gray-800 to-gray-900 p-4 rounded-lg border-2 ${offer.unique ? 'border-purple-500' : 'border-cyan-600'}`;
        card.innerHTML = `
            <div class="text-5xl text-center mb-2">${offer.icon}</div>
            ${offer.unique ? '<div class="text-[8px] text-purple-400 text-center mb-1">UNIQUE ITEM</div>' : ''}
            <h3 class="text-md text-cyan-300 text-center mb-3 font-bold">${offer.name}</h3>
            <button class="game-btn px-4 py-3 text-sm w-full ${canBuy ? 'bg-yellow-500 border-yellow-700' : 'bg-gray-600 border-gray-800'} text-white font-bold" ${canBuy ? '' : 'disabled'} onclick="buyTraderOffer(${i})">
                ${offer.cost} ‚ú® TOKENS
            </button>
        `;
        offersContainer.appendChild(card);
    });
}
function updateTraderTimer() {
    const now = Date.now();
    const timeSinceRefresh = now - (saveData.lastTraderRefresh || 0);
    const refreshInterval = 12 * 60 * 60 * 1000; // 12 HOURS
    const timeRemaining = Math.max(0, refreshInterval - timeSinceRefresh);
    
    const hours = Math.floor(timeRemaining / 3600000);
    const minutes = Math.floor((timeRemaining % 3600000) / 60000);
    const seconds = Math.floor((timeRemaining % 60000) / 1000);
    
    const timerEl = document.getElementById('traderTimer');
    if (timerEl) {
        timerEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
}


function updateHeroCards() {
    // Update Zap card
    const zapCard = document.getElementById('zapCard');
    if (zapCard && saveData.zapUnlocked) {
        zapCard.classList.remove('opacity-50', 'cursor-not-allowed');
        zapCard.classList.add('cursor-pointer');
        const lockIcon = zapCard.querySelector('.absolute.top-0.right-0');
        if (lockIcon) lockIcon.textContent = '‚úì';
        const lockText = zapCard.querySelector('.text-purple-500');
        if (lockText) {
            lockText.textContent = 'Unlocked!';
            lockText.className = 'text-[8px] sm:text-[10px] text-green-400 mt-1';
        }
    }
    
    // Update Unit-7 card
    const unit7Card = document.getElementById('unit7Card');
    if (unit7Card && saveData.unit7Unlocked) {
        unit7Card.classList.remove('opacity-50', 'cursor-not-allowed');
        unit7Card.classList.add('cursor-pointer');
        const lockIcon = unit7Card.querySelector('.absolute.top-0.right-0');
        if (lockIcon) lockIcon.textContent = '‚úì';
        const lockText = unit7Card.querySelector('.text-purple-500');
        if (lockText) {
            lockText.textContent = 'Unlocked!';
            lockText.className = 'text-[8px] sm:text-[10px] text-green-400 mt-1';
        }
    }
}

// Unlock Zap hero if Legend rank
function checkHeroUnlocks() {
    const currentRank = saveData.pac.rank;
    
    // Zap unlocks at Legend rank
    if (currentRank === 'legend' && !saveData.zapUnlocked) {
        saveData.zapUnlocked = true;
        saveDataToStorage();
    }
    
    // Unit-7 unlocks at Elite rank
    if ((currentRank === 'elite' || currentRank === 'legend') && !saveData.unit7Unlocked) {
        saveData.unit7Unlocked = true;
        saveDataToStorage();
    }
    
    // Update Zap card
    const zapCard = document.getElementById('zapCard');
    if (zapCard) {
        if (saveData.zapUnlocked) {
            zapCard.classList.remove('opacity-50', 'cursor-not-allowed');
            zapCard.classList.add('cursor-pointer');
            const lockIcon = zapCard.querySelector('.absolute.top-0.right-0');
            if (lockIcon) lockIcon.textContent = '‚úì';
            const lockText = zapCard.querySelector('.text-red-500');
            if (lockText) {
                lockText.textContent = 'Unlocked!';
                lockText.className = 'text-[8px] sm:text-[10px] text-green-400 mt-1';
            }
        } else {
            const lockText = zapCard.querySelector('.text-red-500');
            if (lockText) {
                lockText.textContent = 'Legend Rank Required';
                lockText.className = 'text-[8px] sm:text-[10px] text-purple-500 mt-1';
            }
        }
    }
    
    // Update Unit-7 card
    const unit7Card = document.getElementById('unit7Card');
    if (unit7Card) {
        if (saveData.unit7Unlocked) {
            unit7Card.classList.remove('opacity-50', 'cursor-not-allowed');
            unit7Card.classList.add('cursor-pointer');
            const lockIcon = unit7Card.querySelector('.absolute.top-0.right-0');
            if (lockIcon) lockIcon.textContent = '‚úì';
            const lockText = unit7Card.querySelector('.text-purple-500');
            if (lockText) {
                lockText.textContent = 'Unlocked!';
                lockText.className = 'text-[8px] sm:text-[10px] text-green-400 mt-1';
            }
        } else {
            const lockText = unit7Card.querySelector('.text-purple-500');
            if (lockText) {
                lockText.textContent = 'Elite Rank Required';
                lockText.className = 'text-[8px] sm:text-[10px] text-purple-500 mt-1';
            }
        }
    }
    
    // Update Hunter card - Coming Soon
    const hunterCard = document.getElementById('hunterCard');
    if (hunterCard) {
        const lockText = hunterCard.querySelector('.text-red-500');
        if (lockText) {
            lockText.textContent = 'Coming Soon';
            lockText.className = 'text-[8px] sm:text-[10px] text-gray-500 mt-1';
        }
    }
    // Update Cupid card
const cupidCard = document.getElementById('cupidCard');
if (cupidCard) {
    if (saveData.cupidUnlocked) {
        cupidCard.classList.remove('opacity-50', 'cursor-not-allowed');
        cupidCard.classList.add('cursor-pointer');
        const lockIcon = cupidCard.querySelector('.absolute.top-0.right-0');
        if (lockIcon) lockIcon.textContent = '‚úì';
        const lockText = cupidCard.querySelector('.text-purple-500');
        if (lockText) {
            lockText.textContent = 'Unlocked!';
            lockText.className = 'text-[8px] sm:text-[10px] text-green-400 mt-1';
        }
    }
}

// Update Dragon card
const dragonCard = document.getElementById('dragonCard');
if (dragonCard) {
    if (saveData.dragonUnlocked) {
        dragonCard.classList.remove('opacity-50', 'cursor-not-allowed');
        dragonCard.classList.add('cursor-pointer');
        const lockIcon = dragonCard.querySelector('.absolute.top-0.right-0');
        if (lockIcon) lockIcon.textContent = '‚úì';
        const lockText = dragonCard.querySelector('.text-purple-500');
        if (lockText) {
            lockText.textContent = 'Unlocked!';
            lockText.className = 'text-[8px] sm:text-[10px] text-green-400 mt-1';
        }
    }
}
}







// Christmas Cosmetic Toggles
document.getElementById('toggleSantaHat').addEventListener('click', () => toggleCosmetic('santaHat'));
document.getElementById('toggleElfHat').addEventListener('click', () => toggleCosmetic('elfHat'));
document.getElementById('toggleAntlers').addEventListener('click', () => toggleCosmetic('antlers'));
document.getElementById('toggleCarrot').addEventListener('click', () => toggleCosmetic('carrotNose'));

        });

    </script>
</body>
</html>
